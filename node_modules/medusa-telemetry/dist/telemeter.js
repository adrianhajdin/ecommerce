"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _fs = _interopRequireDefault(require("fs"));
var _isDocker = _interopRequireDefault(require("is-docker"));
var _os = _interopRequireDefault(require("os"));
var _path = require("path");
var _uuid = require("uuid");
var _store = _interopRequireDefault(require("./store"));
var _createFlush = _interopRequireDefault(require("./util/create-flush"));
var _getTermProgram = _interopRequireDefault(require("./util/get-term-program"));
var _isCi = require("./util/is-ci");
var _isTruthy = _interopRequireDefault(require("./util/is-truthy"));
var _showNotification = _interopRequireDefault(require("./util/show-notification"));
var MEDUSA_TELEMETRY_VERBOSE = process.env.MEDUSA_TELEMETRY_VERBOSE || false;
var Telemeter = /*#__PURE__*/function () {
  function Telemeter() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, Telemeter);
    this.store_ = new _store["default"]();
    this.flushAt = Math.max(options.flushAt, 1) || 20;
    this.maxQueueSize = options.maxQueueSize || 1024 * 500;
    this.flushInterval = options.flushInterval || 10 * 1000;
    this.flushed = false;
    this.queueSize_ = this.store_.getQueueSize();
    this.queueCount_ = this.store_.getQueueCount();
    this.featureFlags_ = new Set();
    this.modules_ = new Set();
    this.plugins_ = [];
  }
  (0, _createClass2["default"])(Telemeter, [{
    key: "getMachineId",
    value: function getMachineId() {
      if (this.machineId) {
        return this.machineId;
      }
      var machineId = this.store_.getConfig("telemetry.machine_id");
      if ((0, _typeof2["default"])(machineId) !== "string") {
        machineId = (0, _uuid.v4)();
        this.store_.setConfig("telemetry.machine_id", machineId);
      }
      this.machineId = machineId;
      return machineId;
    }
  }, {
    key: "isTrackingEnabled",
    value: function isTrackingEnabled() {
      // Cache the result
      if (this.trackingEnabled !== undefined) {
        return this.trackingEnabled;
      }
      var enabled = this.store_.getConfig("telemetry.enabled");
      if (enabled === undefined || enabled === null) {
        if (!(0, _isCi.isCI)()) {
          (0, _showNotification["default"])();
        }
        enabled = true;
        this.store_.setConfig("telemetry.enabled", enabled);
      }
      this.trackingEnabled = enabled;
      return enabled;
    }
  }, {
    key: "getOsInfo",
    value: function getOsInfo() {
      if (this.osInfo) {
        return this.osInfo;
      }
      var cpus = _os["default"].cpus();
      var osInfo = {
        node_version: process.version,
        platform: _os["default"].platform(),
        release: _os["default"].release(),
        cpus: cpus && cpus.length > 0 && cpus[0].model || undefined,
        is_ci: (0, _isCi.isCI)(),
        ci_name: (0, _isCi.getCIName)(),
        arch: _os["default"].arch(),
        docker: (0, _isDocker["default"])(),
        term_program: (0, _getTermProgram["default"])()
      };
      this.osInfo = osInfo;
      return osInfo;
    }
  }, {
    key: "getMedusaVersion",
    value: function getMedusaVersion() {
      try {
        var packageJson = require.resolve("@medusajs/medusa/package.json");
        var _JSON$parse = JSON.parse(_fs["default"].readFileSync(packageJson, "utf-8")),
          version = _JSON$parse.version;
        return version;
      } catch (e) {
        if ((0, _isTruthy["default"])(MEDUSA_TELEMETRY_VERBOSE)) {
          console.error("failed to get medusa version", e);
        }
      }
      return "-0.0.0";
    }
  }, {
    key: "getCliVersion",
    value: function getCliVersion() {
      try {
        var jsonfile = (0, _path.join)(require.resolve("@medusajs/medusa-cli") // Resolve where current gatsby-cli would be loaded from.
        .split(_path.sep).slice(0, -2) // drop lib/index.js
        .join(_path.sep), "package.json");
        var _require = require(jsonfile),
          version = _require.version;
        return version;
      } catch (e) {
        if ((0, _isTruthy["default"])(MEDUSA_TELEMETRY_VERBOSE)) {
          console.error("failed to get medusa version", e);
        }
      }
      return "-0.0.0";
    }
  }, {
    key: "setTelemetryEnabled",
    value: function setTelemetryEnabled(enabled) {
      this.trackingEnabled = enabled;
      this.store_.setConfig("telemetry.enabled", enabled);
    }
  }, {
    key: "track",
    value: function track(event, data) {
      return this.enqueue_(event, data);
    }
  }, {
    key: "enqueue_",
    value: function enqueue_(type, data) {
      var event = {
        id: "te_".concat((0, _uuid.v4)()),
        type: type,
        properties: data,
        timestamp: new Date(),
        machine_id: this.getMachineId(),
        os_info: this.getOsInfo(),
        medusa_version: this.getMedusaVersion(),
        cli_version: this.getCliVersion(),
        feature_flags: Array.from(this.featureFlags_),
        modules: Array.from(this.modules_),
        plugins: this.plugins_
      };
      this.store_.addEvent(event);
      this.queueCount_ += 1;
      this.queueSize_ += JSON.stringify(event).length;
      var hasReachedFlushAt = this.queueCount_ >= this.flushAt;
      var hasReachedQueueSize = this.queueSize_ >= this.maxQueueSize;
      if (hasReachedQueueSize || hasReachedFlushAt) {
        var flush = (0, _createFlush["default"])(this.isTrackingEnabled());
        flush && flush();
      }
      if (this.flushInterval && !this.timer) {
        var _flush = (0, _createFlush["default"])(this.isTrackingEnabled());
        if (_flush) {
          this.timer = setTimeout(_flush, this.flushInterval);
        }
      }
    }
  }, {
    key: "trackFeatureFlag",
    value: function trackFeatureFlag(flag) {
      if (flag) {
        this.featureFlags_.add(flag);
      }
    }
  }, {
    key: "trackModule",
    value: function trackModule(module) {
      if (module) {
        this.modules_.add(module);
      }
    }
  }, {
    key: "trackPlugin",
    value: function trackPlugin(plugin) {
      if (plugin) {
        this.plugins_.push(plugin);
      }
    }
  }]);
  return Telemeter;
}();
var _default = Telemeter;
exports["default"] = _default;