"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSqlPlatform = void 0;
const sqlstring_1 = require("sqlstring");
const core_1 = require("@mikro-orm/core");
const SqlEntityRepository_1 = require("./SqlEntityRepository");
const schema_1 = require("./schema");
class AbstractSqlPlatform extends core_1.Platform {
    usesPivotTable() {
        return true;
    }
    indexForeignKeys() {
        return true;
    }
    getRepositoryClass() {
        return SqlEntityRepository_1.SqlEntityRepository;
    }
    getSchemaHelper() {
        return this.schemaHelper;
    }
    /** @inheritDoc */
    lookupExtensions(orm) {
        schema_1.SchemaGenerator.register(orm);
    }
    // TODO remove in v6 (https://github.com/mikro-orm/mikro-orm/issues/3743)
    getSchemaGenerator(driver, em) {
        /* istanbul ignore next */
        return this.config.getCachedService(schema_1.SchemaGenerator, em ?? driver); // cast as `any` to get around circular dependencies
    }
    // TODO remove in v6 (https://github.com/mikro-orm/mikro-orm/issues/3743)
    getEntityGenerator(em) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { EntityGenerator } = require('@mikro-orm/entity-generator');
        return this.config.getCachedService(EntityGenerator, em);
    }
    // TODO remove in v6 (https://github.com/mikro-orm/mikro-orm/issues/3743)
    getMigrator(em) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { Migrator } = require('@mikro-orm/migrations');
        return this.config.getCachedService(Migrator, em);
    }
    quoteValue(value) {
        if (this.isRaw(value)) {
            return value;
        }
        /* istanbul ignore if */
        if (core_1.Utils.isPlainObject(value) || value?.[core_1.JsonProperty]) {
            return (0, sqlstring_1.escape)(JSON.stringify(value));
        }
        // @ts-ignore
        return (0, sqlstring_1.escape)(value, true, this.timezone);
    }
    formatQuery(sql, params) {
        if (params.length === 0) {
            return sql;
        }
        // fast string replace without regexps
        let j = 0;
        let pos = 0;
        let ret = '';
        while (pos < sql.length) {
            const idx = sql.indexOf('?', pos + 1);
            if (idx === -1) {
                ret += sql.substring(pos, sql.length);
                break;
            }
            if (sql.substr(idx - 1, 2) === '\\?') {
                ret += sql.substr(pos, idx - pos - 1) + '?';
                pos = idx + 1;
            }
            else if (sql.substr(idx, 2) === '??') {
                ret += sql.substr(pos, idx - pos) + this.quoteIdentifier(params[j++]);
                pos = idx + 2;
            }
            else {
                ret += sql.substr(pos, idx - pos) + this.quoteValue(params[j++]);
                pos = idx + 1;
            }
        }
        return ret;
    }
    getSearchJsonPropertySQL(path, type, aliased) {
        return this.getSearchJsonPropertyKey(path.split('->'), type, aliased);
    }
    getSearchJsonPropertyKey(path, type, aliased, value) {
        const [a, ...b] = path;
        const quoteKey = (key) => key.match(/^[a-z]\w*$/i) ? key : `"${key}"`;
        if (aliased) {
            return (0, core_1.expr)(alias => `json_extract(${this.quoteIdentifier(`${alias}.${a}`)}, '$.${b.map(quoteKey).join('.')}')`);
        }
        return `json_extract(${this.quoteIdentifier(a)}, '$.${b.map(quoteKey).join('.')}')`;
    }
    isRaw(value) {
        return super.isRaw(value) || (typeof value === 'object' && value !== null && value.client && ['Ref', 'Raw'].includes(value.constructor.name));
    }
    supportsSchemas() {
        return false;
    }
    /** @inheritDoc */
    generateCustomOrder(escapedColumn, values) {
        let ret = '(case ';
        values.forEach((v, i) => {
            ret += `when ${escapedColumn} = ${this.quoteValue(v)} then ${i} `;
        });
        return ret + 'else null end)';
    }
}
exports.AbstractSqlPlatform = AbstractSqlPlatform;
