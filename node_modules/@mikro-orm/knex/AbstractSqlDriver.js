"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSqlDriver = void 0;
const core_1 = require("@mikro-orm/core");
const query_1 = require("./query");
const SqlEntityManager_1 = require("./SqlEntityManager");
class AbstractSqlDriver extends core_1.DatabaseDriver {
    constructor(config, platform, connection, connector) {
        super(config, connector);
        this.replicas = [];
        this.connection = new connection(this.config);
        this.replicas = this.createReplicas(conf => new connection(this.config, conf, 'read'));
        this.platform = platform;
    }
    getPlatform() {
        return this.platform;
    }
    createEntityManager(useContext) {
        return new SqlEntityManager_1.SqlEntityManager(this.config, this, this.metadata, useContext);
    }
    async find(entityName, where, options = {}) {
        options = { populate: [], orderBy: [], ...options };
        const meta = this.metadata.find(entityName);
        if (meta?.virtual) {
            return this.findVirtual(entityName, where, options);
        }
        const populate = this.autoJoinOneToOneOwner(meta, options.populate, options.fields);
        const joinedProps = this.joinedProps(meta, populate);
        const qb = this.createQueryBuilder(entityName, options.ctx, options.connectionType, false);
        const fields = this.buildFields(meta, populate, joinedProps, qb, options.fields);
        const joinedPropsOrderBy = this.buildJoinedPropsOrderBy(entityName, qb, meta, joinedProps);
        if (core_1.Utils.isPrimaryKey(where, meta.compositePK)) {
            where = { [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: where };
        }
        qb.select(fields)
            .populate(populate, joinedProps.length > 0 ? options.populateWhere : undefined)
            .where(where)
            .orderBy([...core_1.Utils.asArray(options.orderBy), ...joinedPropsOrderBy])
            .groupBy(options.groupBy)
            .having(options.having)
            .indexHint(options.indexHint)
            .comment(options.comments)
            .hintComment(options.hintComments)
            .withSchema(this.getSchemaName(meta, options));
        if (options.limit !== undefined) {
            qb.limit(options.limit, options.offset);
        }
        if (options.lockMode) {
            qb.setLockMode(options.lockMode, options.lockTableAliases);
        }
        core_1.Utils.asArray(options.flags).forEach(flag => qb.setFlag(flag));
        return this.rethrow(qb.execute('all'));
    }
    async findOne(entityName, where, options) {
        const opts = { populate: [], ...(options || {}) };
        const meta = this.metadata.find(entityName);
        const populate = this.autoJoinOneToOneOwner(meta, opts.populate, opts.fields);
        const joinedProps = this.joinedProps(meta, populate);
        if (joinedProps.length === 0) {
            opts.limit = 1;
        }
        if (opts.limit > 0 && !opts.flags?.includes(core_1.QueryFlag.DISABLE_PAGINATE)) {
            opts.flags ?? (opts.flags = []);
            opts.flags.push(core_1.QueryFlag.DISABLE_PAGINATE);
        }
        const res = await this.find(entityName, where, opts);
        return res[0] || null;
    }
    async findVirtual(entityName, where, options) {
        return this.findFromVirtual(entityName, where, options, query_1.QueryType.SELECT);
    }
    async countVirtual(entityName, where, options) {
        return this.findFromVirtual(entityName, where, options, query_1.QueryType.COUNT);
    }
    async findFromVirtual(entityName, where, options, type) {
        const meta = this.metadata.get(entityName);
        /* istanbul ignore next */
        if (!meta.expression) {
            return type === query_1.QueryType.SELECT ? [] : 0;
        }
        if (typeof meta.expression === 'string') {
            return this.wrapVirtualExpressionInSubquery(meta, meta.expression, where, options, type);
        }
        const em = this.createEntityManager();
        em.setTransactionContext(options.ctx);
        const res = meta.expression(em, where, options);
        if (typeof res === 'string') {
            return this.wrapVirtualExpressionInSubquery(meta, res, where, options, type);
        }
        if (res instanceof query_1.QueryBuilder) {
            return this.wrapVirtualExpressionInSubquery(meta, res.getFormattedQuery(), where, options, type);
        }
        if (core_1.Utils.isObject(res)) {
            const { sql, bindings } = res.toSQL();
            const query = this.platform.formatQuery(sql, bindings);
            return this.wrapVirtualExpressionInSubquery(meta, query, where, options, type);
        }
        /* istanbul ignore next */
        return res;
    }
    async wrapVirtualExpressionInSubquery(meta, expression, where, options, type) {
        const qb = this.createQueryBuilder(meta.className, options?.ctx, options.connectionType, options.convertCustomTypes)
            .indexHint(options.indexHint)
            .comment(options.comments)
            .hintComment(options.hintComments);
        if (type !== query_1.QueryType.COUNT) {
            qb.limit(options?.limit, options?.offset);
            if (options.orderBy) {
                qb.orderBy(options.orderBy);
            }
        }
        qb.where(where);
        const kqb = qb.getKnexQuery().clear('select');
        if (type === query_1.QueryType.COUNT) {
            kqb.select(qb.raw('count(*) as count'));
        }
        else { // select
            kqb.select('*');
        }
        kqb.fromRaw(`(${expression}) as ${this.platform.quoteIdentifier(qb.alias)}`);
        const res = await this.execute(kqb);
        if (type === query_1.QueryType.COUNT) {
            return res[0].count;
        }
        return res.map(row => this.mapResult(row, meta));
    }
    mapResult(result, meta, populate = [], qb, map = {}) {
        const ret = super.mapResult(result, meta);
        /* istanbul ignore if */
        if (!ret) {
            return null;
        }
        if (qb) {
            // here we map the aliased results (cartesian product) to an object graph
            this.mapJoinedProps(ret, meta, populate, qb, ret, map);
        }
        return ret;
    }
    mapJoinedProps(result, meta, populate, qb, root, map, parentJoinPath) {
        const joinedProps = this.joinedProps(meta, populate);
        joinedProps.forEach(p => {
            const relation = meta.properties[p.field];
            /* istanbul ignore next */
            if (!relation) {
                return;
            }
            const meta2 = this.metadata.find(relation.type);
            const path = parentJoinPath ? `${parentJoinPath}.${relation.name}` : `${meta.name}.${relation.name}`;
            const relationAlias = qb.getAliasForJoinPath(path);
            const relationPojo = {};
            // If the primary key value for the relation is null, we know we haven't joined to anything
            // and therefore we don't return any record (since all values would be null)
            const hasPK = meta2.primaryKeys.every(pk => meta2.properties[pk].fieldNames.every(name => {
                return root[`${relationAlias}__${name}`] != null;
            }));
            if (!hasPK) {
                if ([core_1.ReferenceType.MANY_TO_MANY, core_1.ReferenceType.ONE_TO_MANY].includes(relation.reference)) {
                    result[relation.name] = result[relation.name] || [];
                }
                if ([core_1.ReferenceType.MANY_TO_ONE, core_1.ReferenceType.ONE_TO_ONE].includes(relation.reference)) {
                    result[relation.name] = null;
                }
                return;
            }
            meta2.props
                .filter(prop => prop.persist === false)
                .forEach(prop => {
                if (prop.fieldNames.length > 1) { // composite keys
                    relationPojo[prop.name] = prop.fieldNames.map(name => root[`${relationAlias}__${name}`]);
                }
                else {
                    const alias = `${relationAlias}__${prop.fieldNames[0]}`;
                    relationPojo[prop.name] = root[alias];
                }
            });
            const props = meta2.props.filter(prop => this.platform.shouldHaveColumn(prop, p.children || []));
            for (const prop of props) {
                if (prop.fieldNames.length > 1) { // composite keys
                    relationPojo[prop.name] = prop.fieldNames.map(name => root[`${relationAlias}__${name}`]);
                }
                else {
                    const alias = `${relationAlias}__${prop.fieldNames[0]}`;
                    relationPojo[prop.name] = root[alias];
                }
            }
            // properties can be mapped to multiple places, e.g. when sharing a column in multiple FKs,
            // so we need to delete them after everything is mapped from given level
            for (const prop of props) {
                prop.fieldNames.map(name => delete root[`${relationAlias}__${name}`]);
            }
            if ([core_1.ReferenceType.MANY_TO_MANY, core_1.ReferenceType.ONE_TO_MANY].includes(relation.reference)) {
                result[relation.name] = result[relation.name] || [];
                result[relation.name].push(relationPojo);
            }
            else {
                result[relation.name] = relationPojo;
            }
            const populateChildren = p.children || [];
            this.mapJoinedProps(relationPojo, meta2, populateChildren, qb, root, map, path);
        });
    }
    async count(entityName, where, options = {}) {
        const meta = this.metadata.find(entityName);
        if (meta?.virtual) {
            return this.countVirtual(entityName, where, options);
        }
        const qb = this.createQueryBuilder(entityName, options.ctx, options.connectionType, false)
            .indexHint(options.indexHint)
            .comment(options.comments)
            .hintComment(options.hintComments)
            .groupBy(options.groupBy)
            .having(options.having)
            .populate(options.populate ?? [])
            .withSchema(this.getSchemaName(meta, options))
            .where(where);
        return this.rethrow(qb.getCount());
    }
    async nativeInsert(entityName, data, options = {}) {
        options.convertCustomTypes ?? (options.convertCustomTypes = true);
        const meta = this.metadata.find(entityName);
        const collections = this.extractManyToMany(entityName, data);
        const pks = meta?.primaryKeys ?? [this.config.getNamingStrategy().referenceColumnName()];
        const qb = this.createQueryBuilder(entityName, options.ctx, 'write', options.convertCustomTypes).withSchema(this.getSchemaName(meta, options));
        const res = await this.rethrow(qb.insert(data).execute('run', false));
        res.row = res.row || {};
        let pk;
        if (pks.length > 1) { // owner has composite pk
            pk = core_1.Utils.getPrimaryKeyCond(data, pks);
        }
        else {
            /* istanbul ignore next */
            res.insertId = data[pks[0]] ?? res.insertId ?? res.row[pks[0]];
            pk = [res.insertId];
        }
        await this.processManyToMany(meta, pk, collections, false, options);
        return res;
    }
    async nativeInsertMany(entityName, data, options = {}) {
        options.processCollections ?? (options.processCollections = true);
        options.convertCustomTypes ?? (options.convertCustomTypes = true);
        const meta = this.metadata.find(entityName);
        const collections = options.processCollections ? data.map(d => this.extractManyToMany(entityName, d)) : [];
        const pks = this.getPrimaryKeyFields(entityName);
        const set = new Set();
        data.forEach(row => Object.keys(row).forEach(k => set.add(k)));
        const props = [...set].map(name => meta?.properties[name] ?? { name, fieldNames: [name] });
        let fields = core_1.Utils.flatten(props.map(prop => prop.fieldNames));
        const duplicates = core_1.Utils.findDuplicates(fields);
        const params = [];
        if (duplicates.length) {
            fields = core_1.Utils.unique(fields);
        }
        /* istanbul ignore next */
        const tableName = meta ? this.getTableName(meta, options) : this.platform.quoteIdentifier(entityName);
        let sql = `insert into ${tableName} `;
        sql += fields.length > 0 ? '(' + fields.map(k => this.platform.quoteIdentifier(k)).join(', ') + ')' : `(${this.platform.quoteIdentifier(pks[0])})`;
        if (fields.length > 0 || this.platform.usesDefaultKeyword()) {
            sql += ' values ';
        }
        else {
            sql += ' ' + data.map(() => `select null as ${this.platform.quoteIdentifier(pks[0])}`).join(' union all ');
        }
        const addParams = (prop, row) => {
            if (options.convertCustomTypes && prop.customType) {
                return params.push(prop.customType.convertToDatabaseValue(row[prop.name], this.platform, { key: prop.name, mode: 'query-data' }));
            }
            params.push(row[prop.name]);
        };
        if (fields.length > 0 || this.platform.usesDefaultKeyword()) {
            sql += data.map(row => {
                const keys = [];
                props.forEach(prop => {
                    if (prop.fieldNames.length > 1) {
                        const param = core_1.Utils.flatten([...row[prop.name] ?? prop.fieldNames.map(() => null)]);
                        const key = param.map(() => '?');
                        prop.fieldNames.forEach((field, idx) => {
                            if (!duplicates.includes(field)) {
                                params.push(param[idx]);
                                keys.push(key[idx]);
                            }
                        });
                    }
                    else if (prop.customType && 'convertToDatabaseValueSQL' in prop.customType && !this.platform.isRaw(row[prop.name])) {
                        keys.push(prop.customType.convertToDatabaseValueSQL('?', this.platform));
                        addParams(prop, row);
                    }
                    else {
                        addParams(prop, row);
                        keys.push('?');
                    }
                });
                return '(' + (keys.join(', ') || 'default') + ')';
            }).join(', ');
        }
        if (this.platform.usesReturningStatement()) {
            /* istanbul ignore next */
            const returningProps = meta.hydrateProps.filter(prop => prop.persist !== false && (prop.primary || prop.defaultRaw || prop.autoincrement));
            const returningFields = core_1.Utils.flatten(returningProps.map(prop => prop.fieldNames));
            /* istanbul ignore next */
            sql += returningFields.length > 0 ? ` returning ${returningFields.map(field => this.platform.quoteIdentifier(field)).join(', ')}` : '';
        }
        const res = await this.execute(sql, params, 'run', options.ctx);
        let pk;
        /* istanbul ignore next */
        if (pks.length > 1) { // owner has composite pk
            pk = data.map(d => core_1.Utils.getPrimaryKeyCond(d, pks));
        }
        else {
            res.row ?? (res.row = {});
            res.rows ?? (res.rows = []);
            pk = data.map((d, i) => d[pks[0]] ?? res.rows[i]?.[pks[0]]).map(d => [d]);
            res.insertId = res.insertId || res.row[pks[0]];
        }
        for (let i = 0; i < collections.length; i++) {
            await this.processManyToMany(meta, pk[i], collections[i], false, options);
        }
        return res;
    }
    async nativeUpdate(entityName, where, data, options = {}) {
        options.convertCustomTypes ?? (options.convertCustomTypes = true);
        const meta = this.metadata.find(entityName);
        const pks = this.getPrimaryKeyFields(entityName);
        const collections = this.extractManyToMany(entityName, data);
        let res = { affectedRows: 0, insertId: 0, row: {} };
        if (core_1.Utils.isPrimaryKey(where) && pks.length === 1) {
            /* istanbul ignore next */
            where = { [meta?.primaryKeys[0] ?? pks[0]]: where };
        }
        if (core_1.Utils.hasObjectKeys(data)) {
            const qb = this.createQueryBuilder(entityName, options.ctx, 'write', options.convertCustomTypes)
                .withSchema(this.getSchemaName(meta, options));
            if (options.upsert) {
                /* istanbul ignore next */
                const uniqueFields = options.onConflictFields ?? (core_1.Utils.isPlainObject(where) ? Object.keys(where) : meta.primaryKeys);
                const returning = (0, core_1.getOnConflictReturningFields)(meta, data, uniqueFields, options);
                qb.insert(data)
                    .onConflict(uniqueFields)
                    .returning(returning);
                if (!options.onConflictAction || options.onConflictAction === 'merge') {
                    const fields = (0, core_1.getOnConflictFields)(data, uniqueFields, options);
                    qb.merge(fields);
                }
                if (options.onConflictAction === 'ignore') {
                    qb.ignore();
                }
            }
            else {
                qb.update(data).where(where);
            }
            res = await this.rethrow(qb.execute('run', false));
        }
        /* istanbul ignore next */
        const pk = pks.map(pk => core_1.Utils.extractPK(data[pk] || where, meta));
        await this.processManyToMany(meta, pk, collections, true, options);
        return res;
    }
    async nativeUpdateMany(entityName, where, data, options = {}) {
        options.processCollections ?? (options.processCollections = true);
        options.convertCustomTypes ?? (options.convertCustomTypes = true);
        const meta = this.metadata.get(entityName);
        if (options.upsert) {
            const uniqueFields = options.onConflictFields ?? (core_1.Utils.isPlainObject(where[0]) ? Object.keys(where[0]).flatMap(key => core_1.Utils.splitPrimaryKeys(key)) : meta.primaryKeys);
            const qb = this.createQueryBuilder(entityName, options.ctx, 'write', options.convertCustomTypes).withSchema(this.getSchemaName(meta, options));
            const returning = (0, core_1.getOnConflictReturningFields)(meta, data[0], uniqueFields, options);
            qb.insert(data)
                .onConflict(uniqueFields)
                .returning(returning);
            if (!options.onConflictAction || options.onConflictAction === 'merge') {
                const fields = (0, core_1.getOnConflictFields)(data[0], uniqueFields, options);
                qb.merge(fields);
            }
            if (options.onConflictAction === 'ignore') {
                qb.ignore();
            }
            return this.rethrow(qb.execute('run', false));
        }
        const collections = options.processCollections ? data.map(d => this.extractManyToMany(entityName, d)) : [];
        const keys = new Set();
        const fields = new Set();
        data.forEach(row => Object.keys(row).forEach(k => keys.add(k)));
        const pkCond = core_1.Utils.flatten(meta.primaryKeys.map(pk => meta.properties[pk].fieldNames)).map(pk => `${this.platform.quoteIdentifier(pk)} = ?`).join(' and ');
        const params = [];
        let sql = `update ${this.getTableName(meta, options)} set `;
        keys.forEach(key => {
            const prop = meta.properties[key];
            prop.fieldNames.forEach((fieldName, fieldNameIdx) => {
                if (fields.has(fieldName)) {
                    return;
                }
                fields.add(fieldName);
                sql += `${this.platform.quoteIdentifier(fieldName)} = case`;
                where.forEach((cond, idx) => {
                    if (key in data[idx]) {
                        const pks = core_1.Utils.getOrderedPrimaryKeys(cond, meta);
                        sql += ` when (${pkCond}) then `;
                        if (prop.customType && 'convertToDatabaseValueSQL' in prop.customType && !this.platform.isRaw(data[idx][key])) {
                            sql += prop.customType.convertToDatabaseValueSQL('?', this.platform);
                        }
                        else {
                            sql += '?';
                        }
                        params.push(...pks, prop.fieldNames.length > 1 ? data[idx][key]?.[fieldNameIdx] : data[idx][key]);
                    }
                });
                sql += ` else ${this.platform.quoteIdentifier(fieldName)} end, `;
                return sql;
            });
        });
        if (meta.versionProperty) {
            const versionProperty = meta.properties[meta.versionProperty];
            const quotedFieldName = this.platform.quoteIdentifier(versionProperty.fieldNames[0]);
            sql += `${quotedFieldName} = `;
            if (versionProperty.type.toLowerCase() === 'date') {
                sql += this.platform.getCurrentTimestampSQL(versionProperty.length);
            }
            else {
                sql += `${quotedFieldName} + 1`;
            }
            sql += `, `;
        }
        sql = sql.substring(0, sql.length - 2) + ' where ';
        const pkProps = meta.primaryKeys.concat(...meta.concurrencyCheckKeys);
        const pks = core_1.Utils.flatten(pkProps.map(pk => meta.properties[pk].fieldNames));
        sql += pks.length > 1 ? `(${pks.map(pk => `${this.platform.quoteIdentifier(pk)}`).join(', ')})` : this.platform.quoteIdentifier(pks[0]);
        const conds = where.map(cond => {
            if (core_1.Utils.isPlainObject(cond) && core_1.Utils.getObjectKeysSize(cond) === 1) {
                cond = Object.values(cond)[0];
            }
            if (pks.length > 1) {
                pkProps.forEach(pk => {
                    if (Array.isArray(cond[pk])) {
                        params.push(...core_1.Utils.flatten(cond[pk]));
                    }
                    else {
                        params.push(cond[pk]);
                    }
                });
                return `(${new Array(pks.length).fill('?').join(', ')})`;
            }
            params.push(cond);
            return '?';
        });
        sql += ` in (${conds.join(', ')})`;
        const res = await this.rethrow(this.execute(sql, params, 'run', options.ctx));
        for (let i = 0; i < collections.length; i++) {
            await this.processManyToMany(meta, where[i], collections[i], false, options);
        }
        return res;
    }
    async nativeDelete(entityName, where, options = {}) {
        const meta = this.metadata.find(entityName);
        const pks = this.getPrimaryKeyFields(entityName);
        if (core_1.Utils.isPrimaryKey(where) && pks.length === 1) {
            where = { [pks[0]]: where };
        }
        const qb = this.createQueryBuilder(entityName, options.ctx, 'write', false).delete(where).withSchema(this.getSchemaName(meta, options));
        return this.rethrow(qb.execute('run', false));
    }
    async syncCollection(coll, options) {
        const wrapped = (0, core_1.helper)(coll.owner);
        const meta = wrapped.__meta;
        const pks = wrapped.getPrimaryKeys(true);
        const snap = coll.getSnapshot();
        const includes = (arr, item) => !!arr.find(i => core_1.Utils.equals(i, item));
        const snapshot = snap ? snap.map(item => (0, core_1.helper)(item).getPrimaryKeys(true)) : [];
        const current = coll.getItems(false).map(item => (0, core_1.helper)(item).getPrimaryKeys(true));
        const deleteDiff = snap ? snapshot.filter(item => !includes(current, item)) : true;
        const insertDiff = current.filter(item => !includes(snapshot, item));
        const target = snapshot.filter(item => includes(current, item)).concat(...insertDiff);
        const equals = core_1.Utils.equals(current, target);
        const ctx = options?.ctx;
        // wrong order if we just delete and insert to the end (only owning sides can have fixed order)
        if (coll.property.owner && coll.property.fixedOrder && !equals && Array.isArray(deleteDiff)) {
            deleteDiff.length = insertDiff.length = 0;
            deleteDiff.push(...snapshot);
            insertDiff.push(...current);
        }
        if (coll.property.reference === core_1.ReferenceType.ONE_TO_MANY) {
            const cols = coll.property.referencedColumnNames;
            const qb = this.createQueryBuilder(coll.property.type, ctx, 'write')
                .withSchema(this.getSchemaName(meta, options));
            if (coll.getSnapshot() === undefined) {
                if (coll.property.orphanRemoval) {
                    const kqb = qb.delete({ [coll.property.mappedBy]: pks })
                        .getKnexQuery()
                        .whereNotIn(cols, insertDiff);
                    return this.rethrow(this.execute(kqb));
                }
                const kqb = qb.update({ [coll.property.mappedBy]: null })
                    .getKnexQuery()
                    .whereNotIn(cols, insertDiff);
                return this.rethrow(this.execute(kqb));
            }
            const kqb = qb.update({ [coll.property.mappedBy]: pks })
                .getKnexQuery()
                .whereIn(cols, insertDiff);
            return this.rethrow(this.execute(kqb));
        }
        /* istanbul ignore next */
        const ownerSchema = wrapped.getSchema() === '*' ? this.config.get('schema') : wrapped.getSchema();
        const pivotMeta = this.metadata.find(coll.property.pivotEntity);
        if (pivotMeta.schema === '*') {
            /* istanbul ignore next */
            options ?? (options = {});
            options.schema = ownerSchema;
        }
        return this.rethrow(this.updateCollectionDiff(meta, coll.property, pks, deleteDiff, insertDiff, options));
    }
    async loadFromPivotTable(prop, owners, where = {}, orderBy, ctx, options) {
        const pivotProp2 = this.getPivotInverseProperty(prop);
        const ownerMeta = this.metadata.find(pivotProp2.type);
        const pivotMeta = this.metadata.find(prop.pivotEntity);
        const cond = { [`${prop.pivotEntity}.${pivotProp2.name}`]: { $in: ownerMeta.compositePK ? owners : owners.map(o => o[0]) } };
        /* istanbul ignore if */
        if (!core_1.Utils.isEmpty(where) && Object.keys(where).every(k => core_1.Utils.isOperator(k, false))) {
            where = cond;
        }
        else {
            where = { ...where, ...cond };
        }
        /* istanbul ignore if */
        options = { ...options };
        orderBy = this.getPivotOrderBy(prop, orderBy);
        const qb = this.createQueryBuilder(prop.type, ctx, options.connectionType)
            .indexHint(options.indexHint)
            .comment(options.comments)
            .hintComment(options.hintComments)
            .unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES)
            .withSchema(this.getSchemaName(prop.targetMeta, options));
        const populate = this.autoJoinOneToOneOwner(prop.targetMeta, [{ field: prop.pivotEntity }]);
        const fields = this.buildFields(prop.targetMeta, (options.populate ?? []), [], qb, options.fields);
        qb.select(fields).populate(populate).where(where).orderBy(orderBy).setLockMode(options.lockMode, options.lockTableAliases);
        if (owners.length === 1 && (options.offset != null || options.limit != null)) {
            qb.limit(options.limit, options.offset);
        }
        if (prop.targetMeta.schema !== '*' && pivotMeta.schema === '*' && options.schema) {
            // eslint-disable-next-line dot-notation
            qb['finalize']();
            // eslint-disable-next-line dot-notation
            Object.values(qb['_joins']).forEach(join => {
                join.schema = options.schema;
            });
        }
        const items = owners.length ? await this.rethrow(qb.execute('all', { mergeResults: false })) : [];
        const map = {};
        const pkProps = ownerMeta.getPrimaryProps();
        owners.forEach(owner => {
            const key = core_1.Utils.getPrimaryKeyHash(prop.joinColumns.map((col, idx) => {
                const pkProp = pkProps[idx];
                return pkProp.customType ? pkProp.customType.convertToJSValue(owner[idx], this.platform) : owner[idx];
            }));
            return map[key] = [];
        });
        items.forEach((item) => {
            const key = core_1.Utils.getPrimaryKeyHash(prop.joinColumns.map((col, idx) => {
                const pkProp = pkProps[idx];
                return pkProp.customType ? pkProp.customType.convertToJSValue(item[`fk__${col}`], this.platform) : item[`fk__${col}`];
            }));
            map[key].push(item);
            prop.joinColumns.forEach(col => delete item[`fk__${col}`]);
            prop.inverseJoinColumns.forEach(col => delete item[`fk__${col}`]);
        });
        return map;
    }
    async execute(queryOrKnex, params = [], method = 'all', ctx) {
        return this.rethrow(this.connection.execute(queryOrKnex, params, method, ctx));
    }
    /**
     * 1:1 owner side needs to be marked for population so QB auto-joins the owner id
     */
    autoJoinOneToOneOwner(meta, populate, fields = []) {
        if (!this.config.get('autoJoinOneToOneOwner')) {
            return populate;
        }
        const relationsToPopulate = populate.map(({ field }) => field);
        const toPopulate = meta.relations
            .filter(prop => prop.reference === core_1.ReferenceType.ONE_TO_ONE && !prop.owner && !relationsToPopulate.includes(prop.name))
            .filter(prop => fields.length === 0 || fields.some(f => prop.name === f || prop.name.startsWith(`${String(f)}.`)))
            .map(prop => ({ field: prop.name, strategy: prop.strategy }));
        return [...populate, ...toPopulate];
    }
    /**
     * @internal
     */
    joinedProps(meta, populate) {
        return populate.filter(p => {
            const prop = meta.properties[p.field] || {};
            return (p.strategy || prop.strategy || this.config.get('loadStrategy')) === core_1.LoadStrategy.JOINED && prop.reference !== core_1.ReferenceType.SCALAR && prop.reference !== core_1.ReferenceType.EMBEDDED;
        });
    }
    /**
     * @internal
     */
    mergeJoinedResult(rawResults, meta, joinedProps) {
        const res = [];
        const map = {};
        for (const item of rawResults) {
            const pk = core_1.Utils.getCompositeKeyHash(item, meta);
            if (map[pk]) {
                for (const hint of joinedProps) {
                    const prop = meta.properties[hint.field];
                    if (!item[hint.field]) {
                        continue;
                    }
                    switch (prop.reference) {
                        case core_1.ReferenceType.ONE_TO_MANY:
                        case core_1.ReferenceType.MANY_TO_MANY:
                            map[pk][hint.field] = this.mergeJoinedResult([...map[pk][hint.field], ...item[hint.field]], prop.targetMeta, hint.children ?? []);
                            break;
                        case core_1.ReferenceType.MANY_TO_ONE:
                        case core_1.ReferenceType.ONE_TO_ONE:
                            map[pk][hint.field] = this.mergeJoinedResult([map[pk][hint.field], item[hint.field]], prop.targetMeta, hint.children ?? [])[0];
                            break;
                    }
                }
            }
            else {
                map[pk] = item;
                res.push(item);
            }
        }
        return res;
    }
    getFieldsForJoinedLoad(qb, meta, explicitFields, populate = [], parentTableAlias, parentJoinPath) {
        const fields = [];
        const joinedProps = this.joinedProps(meta, populate);
        if (explicitFields?.includes('*')) {
            fields.push('*');
        }
        const shouldHaveColumn = (prop, populate, fields) => {
            if (!this.platform.shouldHaveColumn(prop, populate)) {
                return false;
            }
            if (!fields || prop.primary) {
                return !fields?.includes('*');
            }
            return fields.includes(prop.name);
        };
        // alias all fields in the primary table
        meta.props
            .filter(prop => shouldHaveColumn(prop, populate, explicitFields))
            .forEach(prop => fields.push(...this.mapPropToFieldNames(qb, prop, parentTableAlias)));
        joinedProps.forEach(relation => {
            const prop = meta.properties[relation.field];
            const meta2 = this.metadata.find(prop.type);
            const tableAlias = qb.getNextAlias(prop.name);
            const field = parentTableAlias ? `${parentTableAlias}.${prop.name}` : prop.name;
            const path = parentJoinPath ? `${parentJoinPath}.${prop.name}` : `${meta.name}.${prop.name}`;
            qb.join(field, tableAlias, {}, 'leftJoin', path);
            const childExplicitFields = explicitFields?.filter(f => core_1.Utils.isPlainObject(f)).map(o => o[prop.name])[0] || [];
            explicitFields?.forEach(f => {
                if (typeof f === 'string' && f.startsWith(`${prop.name}.`)) {
                    childExplicitFields.push(f.substring(prop.name.length + 1));
                }
            });
            fields.push(...this.getFieldsForJoinedLoad(qb, meta2, childExplicitFields.length === 0 ? undefined : childExplicitFields, relation.children, tableAlias, path));
        });
        return fields;
    }
    /**
     * @internal
     */
    mapPropToFieldNames(qb, prop, tableAlias) {
        const aliased = qb.ref(tableAlias ? `${tableAlias}__${prop.fieldNames[0]}` : prop.fieldNames[0]).toString();
        if (prop.customType?.convertToJSValueSQL && tableAlias) {
            const prefixed = qb.ref(prop.fieldNames[0]).withSchema(tableAlias).toString();
            return [qb.raw(prop.customType.convertToJSValueSQL(prefixed, this.platform) + ' as ' + aliased).toString()];
        }
        if (prop.formula) {
            const alias = qb.ref(tableAlias ?? qb.alias).toString();
            return [`${prop.formula(alias)} as ${aliased}`];
        }
        if (tableAlias) {
            return prop.fieldNames.map(fieldName => qb.ref(fieldName).withSchema(tableAlias).as(`${tableAlias}__${fieldName}`));
        }
        return prop.fieldNames;
    }
    /** @internal */
    createQueryBuilder(entityName, ctx, preferredConnectionType, convertCustomTypes) {
        const connectionType = this.resolveConnectionType({ ctx, connectionType: preferredConnectionType });
        const qb = new query_1.QueryBuilder(entityName, this.metadata, this, ctx, undefined, connectionType);
        if (!convertCustomTypes) {
            qb.unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES);
        }
        return qb;
    }
    resolveConnectionType(args) {
        if (args.ctx) {
            return 'write';
        }
        else if (args.connectionType) {
            return args.connectionType;
        }
        else if (this.config.get('preferReadReplicas') === true) {
            return 'read';
        }
        return 'write';
    }
    extractManyToMany(entityName, data) {
        if (!this.metadata.has(entityName)) {
            return {};
        }
        const ret = {};
        this.metadata.find(entityName).relations.forEach(prop => {
            if (prop.reference === core_1.ReferenceType.MANY_TO_MANY && data[prop.name]) {
                ret[prop.name] = data[prop.name].map((item) => core_1.Utils.asArray(item));
                delete data[prop.name];
            }
        });
        return ret;
    }
    async processManyToMany(meta, pks, collections, clear, options) {
        if (!meta) {
            return;
        }
        for (const prop of meta.relations) {
            if (collections[prop.name]) {
                await this.rethrow(this.updateCollectionDiff(meta, prop, pks, clear, collections[prop.name], options));
            }
        }
    }
    async updateCollectionDiff(meta, prop, pks, deleteDiff, insertDiff, options) {
        if (!deleteDiff) {
            deleteDiff = [];
        }
        const pivotMeta = this.metadata.find(prop.pivotEntity);
        if (deleteDiff === true || deleteDiff.length > 0) {
            const qb1 = this.createQueryBuilder(prop.pivotEntity, options?.ctx, 'write')
                .withSchema(this.getSchemaName(pivotMeta, options))
                .unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES);
            const knex = qb1.getKnex();
            if (Array.isArray(deleteDiff)) {
                knex.whereIn(prop.inverseJoinColumns, deleteDiff);
            }
            prop.joinColumns.forEach((joinColumn, idx) => knex.andWhere(joinColumn, pks[idx]));
            await this.execute(knex.delete());
        }
        if (insertDiff.length === 0) {
            return;
        }
        const items = insertDiff.map(item => {
            const cond = {};
            prop.joinColumns.forEach((joinColumn, idx) => cond[joinColumn] = pks[idx]);
            prop.inverseJoinColumns.forEach((inverseJoinColumn, idx) => cond[inverseJoinColumn] = item[idx]);
            return cond;
        });
        /* istanbul ignore else */
        if (this.platform.allowsMultiInsert()) {
            await this.nativeInsertMany(prop.pivotEntity, items, { ...options, convertCustomTypes: false, processCollections: false });
        }
        else {
            await core_1.Utils.runSerial(items, item => {
                return this.createQueryBuilder(prop.pivotEntity, options?.ctx, 'write')
                    .unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES)
                    .withSchema(this.getSchemaName(pivotMeta, options))
                    .insert(item)
                    .execute('run', false);
            });
        }
    }
    async lockPessimistic(entity, options) {
        const meta = (0, core_1.helper)(entity).__meta;
        const qb = this.createQueryBuilder(entity.constructor.name, options.ctx).unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES).withSchema(options.schema ?? meta.schema);
        const cond = core_1.Utils.getPrimaryKeyCond(entity, meta.primaryKeys);
        qb.select('1').where(cond).setLockMode(options.lockMode, options.lockTableAliases);
        await this.rethrow(qb.execute());
    }
    buildJoinedPropsOrderBy(entityName, qb, meta, populate, parentPath) {
        const orderBy = [];
        const joinedProps = this.joinedProps(meta, populate);
        joinedProps.forEach(relation => {
            const prop = meta.properties[relation.field];
            const propOrderBy = prop.orderBy;
            const path = `${parentPath ? parentPath : entityName}.${relation.field}`;
            const propAlias = qb.getAliasForJoinPath(path);
            if (propOrderBy) {
                Object.keys(propOrderBy).forEach(field => {
                    orderBy.push({ [`${propAlias}.${field}`]: propOrderBy[field] });
                });
            }
            if (relation.children) {
                const meta2 = this.metadata.find(prop.type);
                orderBy.push(...this.buildJoinedPropsOrderBy(prop.name, qb, meta2, relation.children, path));
            }
        });
        return orderBy;
    }
    normalizeFields(fields, prefix = '') {
        const ret = [];
        for (const field of fields) {
            if (typeof field === 'string') {
                ret.push(prefix + field);
                continue;
            }
            if (core_1.Utils.isPlainObject(field)) {
                for (const key of Object.keys(field)) {
                    ret.push(...this.normalizeFields(field[key], key + '.'));
                }
            }
        }
        return ret;
    }
    processField(meta, prop, field, ret, populate, joinedProps, qb) {
        if (!prop || (prop.reference === core_1.ReferenceType.ONE_TO_ONE && !prop.owner)) {
            return;
        }
        if (prop.reference === core_1.ReferenceType.EMBEDDED) {
            if (prop.object) {
                ret.push(prop.name);
                return;
            }
            const parts = field.split('.');
            const top = parts.shift();
            for (const key of Object.keys(prop.embeddedProps)) {
                if (!top || key === top) {
                    this.processField(meta, prop.embeddedProps[key], parts.join('.'), ret, populate, joinedProps, qb);
                }
            }
            return;
        }
        ret.push(prop.name);
    }
    buildFields(meta, populate, joinedProps, qb, fields) {
        const lazyProps = meta.props.filter(prop => prop.lazy && !populate.some(p => p.field === prop.name || p.all));
        const hasLazyFormulas = meta.props.some(p => p.lazy && p.formula);
        const requiresSQLConversion = meta.props.some(p => p.customType?.convertToJSValueSQL && p.persist !== false);
        const hasExplicitFields = !!fields;
        const ret = [];
        if (joinedProps.length > 0) {
            ret.push(...this.getFieldsForJoinedLoad(qb, meta, fields, populate));
        }
        else if (fields) {
            for (const field of this.normalizeFields(fields)) {
                if (field === '*') {
                    ret.push('*');
                    continue;
                }
                const parts = field.split('.');
                const rootPropName = parts.shift(); // first one is the `prop`
                const prop = core_1.QueryHelper.findProperty(rootPropName, {
                    metadata: this.metadata,
                    platform: this.platform,
                    entityName: meta.className,
                    where: {},
                    aliasMap: qb.getAliasMap(),
                });
                this.processField(meta, prop, parts.join('.'), ret, populate, joinedProps, qb);
            }
            ret.unshift(...meta.primaryKeys.filter(pk => !fields.includes(pk)));
        }
        else if (lazyProps.filter(p => !p.formula).length > 0) {
            const props = meta.props.filter(prop => this.platform.shouldHaveColumn(prop, populate, false));
            ret.push(...core_1.Utils.flatten(props.filter(p => !lazyProps.includes(p)).map(p => p.fieldNames)));
        }
        else if (hasLazyFormulas || requiresSQLConversion) {
            ret.push('*');
        }
        if (ret.length > 0 && !hasExplicitFields) {
            meta.props
                .filter(prop => prop.formula && !lazyProps.includes(prop))
                .forEach(prop => {
                const alias = qb.ref(qb.alias).toString();
                const aliased = qb.ref(prop.fieldNames[0]).toString();
                ret.push(`${prop.formula(alias)} as ${aliased}`);
            });
            meta.props
                .filter(prop => prop.hasConvertToDatabaseValueSQL || prop.hasConvertToJSValueSQL)
                .forEach(prop => ret.push(prop.name));
        }
        return ret.length > 0 ? core_1.Utils.unique(ret) : ['*'];
    }
}
exports.AbstractSqlDriver = AbstractSqlDriver;
