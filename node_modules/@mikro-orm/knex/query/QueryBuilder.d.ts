/// <reference types="node" />
import { inspect } from 'util';
import type { Knex } from 'knex';
import { LockMode, PopulateHint, QueryFlag, type AnyEntity, type ConnectionType, type Dictionary, type EntityData, type EntityName, type EntityProperty, type FlushMode, type GroupOperator, type MetadataStorage, type ObjectQuery, type PopulateOptions, type QBFilterQuery, type QBQueryOrderMap, type QueryResult, type RequiredEntityData } from '@mikro-orm/core';
import { QueryType } from './enums';
import type { AbstractSqlDriver } from '../AbstractSqlDriver';
import { QueryBuilderHelper, type Alias } from './QueryBuilderHelper';
import type { SqlEntityManager } from '../SqlEntityManager';
import type { Field } from '../typings';
export interface ExecuteOptions {
    mapResults?: boolean;
    mergeResults?: boolean;
}
/**
 * SQL query builder with fluent interface.
 *
 * ```ts
 * const qb = orm.em.createQueryBuilder(Publisher);
 * qb.select('*')
 *   .where({
 *     name: 'test 123',
 *     type: PublisherType.GLOBAL,
 *   })
 *   .orderBy({
 *     name: QueryOrder.DESC,
 *     type: QueryOrder.ASC,
 *   })
 *   .limit(2, 1);
 *
 * const publisher = await qb.getSingleResult();
 * ```
 */
export declare class QueryBuilder<T extends object = AnyEntity> {
    private readonly metadata;
    private readonly driver;
    private readonly context?;
    private connectionType?;
    private readonly em?;
    get mainAlias(): Alias<T>;
    get alias(): string;
    get helper(): QueryBuilderHelper;
    /** @internal */
    type?: QueryType;
    /** @internal */
    _fields?: Field<T>[];
    /** @internal */
    _populate: PopulateOptions<T>[];
    /** @internal */
    _populateWhere?: ObjectQuery<T> | PopulateHint;
    /** @internal */
    _populateMap: Dictionary<string>;
    private aliasCounter;
    private flags;
    private finalized;
    private _joins;
    private _explicitAlias;
    private _schema?;
    private _cond;
    private _data;
    private _orderBy;
    private _groupBy;
    private _having;
    private _returning?;
    private _onConflict?;
    private _limit?;
    private _offset?;
    private _distinctOn?;
    private _joinedProps;
    private _cache?;
    private _indexHint?;
    private _comments;
    private _hintComments;
    private flushMode?;
    private lockMode?;
    private lockTables?;
    private subQueries;
    private _mainAlias?;
    private _aliases;
    private _helper?;
    private readonly platform;
    private readonly knex;
    /**
     * @internal
     */
    constructor(entityName: EntityName<T> | QueryBuilder<T>, metadata: MetadataStorage, driver: AbstractSqlDriver, context?: Knex.Transaction<any, any[]> | undefined, alias?: string, connectionType?: ConnectionType | undefined, em?: SqlEntityManager<AbstractSqlDriver<import("..").AbstractSqlConnection, import("..").AbstractSqlPlatform>> | undefined);
    select(fields: Field<T> | Field<T>[], distinct?: boolean): SelectQueryBuilder<T>;
    addSelect(fields: Field<T> | Field<T>[]): SelectQueryBuilder<T>;
    distinct(): SelectQueryBuilder<T>;
    /** postgres only */
    distinctOn(fields: string | string[]): SelectQueryBuilder<T>;
    insert(data: RequiredEntityData<T> | RequiredEntityData<T>[]): InsertQueryBuilder<T>;
    update(data: EntityData<T>): UpdateQueryBuilder<T>;
    delete(cond?: QBFilterQuery): DeleteQueryBuilder<T>;
    truncate(): TruncateQueryBuilder<T>;
    count(field?: string | string[], distinct?: boolean): CountQueryBuilder<T>;
    join(field: string, alias: string, cond?: QBFilterQuery, type?: 'leftJoin' | 'innerJoin' | 'pivotJoin', path?: string): this;
    leftJoin(field: string, alias: string, cond?: QBFilterQuery): this;
    joinAndSelect(field: string, alias: string, cond?: QBFilterQuery, type?: 'leftJoin' | 'innerJoin' | 'pivotJoin', path?: string, fields?: string[]): SelectQueryBuilder<T>;
    leftJoinAndSelect(field: string, alias: string, cond?: QBFilterQuery, fields?: string[]): SelectQueryBuilder<T>;
    innerJoinAndSelect(field: string, alias: string, cond?: QBFilterQuery, fields?: string[]): SelectQueryBuilder<T>;
    protected getFieldsForJoinedLoad<U extends object>(prop: EntityProperty<U>, alias: string, explicitFields?: string[]): Field<U>[];
    withSubQuery(subQuery: Knex.QueryBuilder, alias: string): this;
    where(cond: QBFilterQuery<T>, operator?: keyof typeof GroupOperator): this;
    where(cond: string, params?: any[], operator?: keyof typeof GroupOperator): this;
    andWhere(cond: QBFilterQuery<T>): this;
    andWhere(cond: string, params?: any[]): this;
    orWhere(cond: QBFilterQuery<T>): this;
    orWhere(cond: string, params?: any[]): this;
    orderBy(orderBy: QBQueryOrderMap<T> | QBQueryOrderMap<T>[]): this;
    groupBy(fields: (string | keyof T) | readonly (string | keyof T)[]): this;
    having(cond?: QBFilterQuery | string, params?: any[]): this;
    onConflict(fields?: Field<T> | Field<T>[]): this;
    ignore(): this;
    merge(data?: EntityData<T> | Field<T>[]): this;
    returning(fields?: Field<T> | Field<T>[]): this;
    /**
     * @internal
     */
    populate(populate: PopulateOptions<T>[], populateWhere?: ObjectQuery<T> | PopulateHint): this;
    /**
     * @internal
     */
    ref(field: string): Knex.Ref<string, {
        [x: string]: string;
    }>;
    raw<R = Knex.Raw>(sql: string, bindings?: Knex.RawBinding[] | Knex.ValueDict): R;
    limit(limit?: number, offset?: number): this;
    offset(offset?: number): this;
    withSchema(schema?: string): this;
    setLockMode(mode?: LockMode, tables?: string[]): this;
    setFlushMode(flushMode?: FlushMode): this;
    setFlag(flag: QueryFlag): this;
    unsetFlag(flag: QueryFlag): this;
    cache(config?: boolean | number | [string, number]): this;
    /**
     * Adds index hint to the FROM clause.
     */
    indexHint(sql: string): this;
    /**
     * Prepend comment to the sql query using the syntax `/* ... *&#8205;/`. Some characters are forbidden such as `/*, *&#8205;/` and `?`.
     */
    comment(comment: string | string[]): this;
    /**
     * Add hints to the query using comment-like syntax `/*+ ... *&#8205;/`. MySQL and Oracle use this syntax for optimizer hints.
     * Also various DB proxies and routers use this syntax to pass hints to alter their behavior. In other dialects the hints
     * are ignored as simple comments.
     */
    hintComment(comment: string | string[]): this;
    /**
     * Specifies FROM which entity's table select/update/delete will be executed, removing all previously set FROM-s.
     * Allows setting a main string alias of the selection data.
     */
    from<T extends AnyEntity<T> = AnyEntity>(target: QueryBuilder<T>, aliasName?: string): QueryBuilder<T>;
    from<T extends AnyEntity<T> = AnyEntity>(target: EntityName<T>): QueryBuilder<T>;
    getKnexQuery(): Knex.QueryBuilder;
    /**
     * Returns the query with parameters as wildcards.
     */
    getQuery(): string;
    /**
     * Returns the list of all parameters for this query.
     */
    getParams(): readonly Knex.Value[];
    /**
     * Returns raw interpolated query string with all the parameters inlined.
     */
    getFormattedQuery(): string;
    /**
     * @internal
     */
    getAliasForJoinPath(path?: string): string | undefined;
    /**
     * @internal
     */
    getNextAlias(entityName?: string): string;
    /**
     * @internal
     */
    getAliasMap(): Dictionary<string>;
    /**
     * Executes this QB and returns the raw results, mapped to the property names (unless disabled via last parameter).
     * Use `method` to specify what kind of result you want to get (array/single/meta).
     */
    execute<U = any>(method?: 'all' | 'get' | 'run', options?: ExecuteOptions | boolean): Promise<U>;
    /**
     * Alias for `qb.getResultList()`
     */
    getResult(): Promise<T[]>;
    /**
     * Executes the query, returning array of results
     */
    getResultList(): Promise<T[]>;
    /**
     * Executes the query, returning the first result or null
     */
    getSingleResult(): Promise<T | null>;
    /**
     * Executes count query (without offset and limit), returning total count of results
     */
    getCount(field?: string | string[], distinct?: boolean): Promise<number>;
    /**
     * Executes the query, returning both array of results and total count query (without offset and limit).
     */
    getResultAndCount(): Promise<[T[], number]>;
    /**
     * Provides promise-like interface so we can await the QB instance.
     */
    then<TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<T[] | number | QueryResult<T>>;
    /**
     * Returns knex instance with sub-query aliased with given alias.
     * You can provide `EntityName.propName` as alias, then the field name will be used based on the metadata
     */
    as(alias: string): Knex.QueryBuilder;
    clone(): QueryBuilder<T>;
    getKnex(): Knex.QueryBuilder;
    private joinReference;
    private prepareFields;
    private init;
    private getQueryBase;
    private finalize;
    private processPopulateWhere;
    private hasToManyJoins;
    private wrapPaginateSubQuery;
    private wrapModifySubQuery;
    private autoJoinPivotTable;
    private getSchema;
    private createAlias;
    private createMainAlias;
    private fromSubQuery;
    private fromEntityName;
    private createQueryBuilderHelper;
    private ensureFromClause;
    private ensureNotFinalized;
    [inspect.custom](depth: number): string;
}
export interface RunQueryBuilder<T extends object> extends Omit<QueryBuilder<T>, 'getResult' | 'getSingleResult' | 'getResultList' | 'where'> {
    where(cond: QBFilterQuery<T> | string, params?: keyof typeof GroupOperator | any[], operator?: keyof typeof GroupOperator): this;
    execute<U = QueryResult<T>>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = QueryResult<T>, TResult2 = never>(onfulfilled?: ((value: QueryResult<T>) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<QueryResult<T>>;
}
export interface SelectQueryBuilder<T extends object> extends QueryBuilder<T> {
    execute<U = T[]>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    execute<U = T[]>(method: 'all', mapResults?: boolean): Promise<U>;
    execute<U = T>(method: 'get', mapResults?: boolean): Promise<U>;
    execute<U = QueryResult<T>>(method: 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = T[], TResult2 = never>(onfulfilled?: ((value: T[]) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<T[]>;
}
export interface CountQueryBuilder<T extends object> extends QueryBuilder<T> {
    execute<U = {
        count: number;
    }[]>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    execute<U = {
        count: number;
    }[]>(method: 'all', mapResults?: boolean): Promise<U>;
    execute<U = {
        count: number;
    }>(method: 'get', mapResults?: boolean): Promise<U>;
    execute<U = QueryResult<{
        count: number;
    }>>(method: 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = number, TResult2 = never>(onfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<number>;
}
export interface InsertQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface UpdateQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface DeleteQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface TruncateQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
