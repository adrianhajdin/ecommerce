"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseTable = void 0;
const core_1 = require("@mikro-orm/core");
/**
 * @internal
 */
class DatabaseTable {
    constructor(platform, name, schema) {
        this.platform = platform;
        this.name = name;
        this.schema = schema;
        this.columns = {};
        this.indexes = [];
        this.checks = [];
        this.foreignKeys = {};
        Object.defineProperties(this, {
            platform: { enumerable: false, writable: true },
        });
    }
    getColumns() {
        return Object.values(this.columns);
    }
    getColumn(name) {
        return this.columns[name];
    }
    removeColumn(name) {
        delete this.columns[name];
    }
    getIndexes() {
        return this.indexes;
    }
    getChecks() {
        return this.checks;
    }
    init(cols, indexes = [], checks = [], pks, fks = {}, enums = {}) {
        this.indexes = indexes;
        this.checks = checks;
        this.foreignKeys = fks;
        this.columns = cols.reduce((o, v) => {
            const index = indexes.filter(i => i.columnNames[0] === v.name);
            v.primary = v.primary || pks.includes(v.name);
            v.unique = index.some(i => i.unique && !i.primary);
            const type = v.name in enums ? 'enum' : v.type;
            v.mappedType = this.platform.getMappedType(type);
            v.default = v.default?.toString().startsWith('nextval(') ? null : v.default;
            v.enumItems = enums[v.name] || [];
            o[v.name] = v;
            return o;
        }, {});
    }
    addColumn(column) {
        this.columns[column.name] = column;
    }
    addColumnFromProperty(prop, meta, config) {
        prop.fieldNames.forEach((field, idx) => {
            var _a;
            const type = prop.enum ? 'enum' : prop.columnTypes[idx];
            const mappedType = this.platform.getMappedType(type);
            if (mappedType instanceof core_1.DecimalType) {
                const match = prop.columnTypes[idx].match(/\w+\((\d+), ?(\d+)\)/);
                /* istanbul ignore else */
                if (match) {
                    prop.precision ?? (prop.precision = +match[1]);
                    prop.scale ?? (prop.scale = +match[2]);
                    prop.length = undefined;
                }
            }
            if (mappedType instanceof core_1.DateTimeType) {
                const match = prop.columnTypes[idx].match(/\w+\((\d+)\)/);
                if (match) {
                    prop.length ?? (prop.length = +match[1]);
                }
                else {
                    prop.length ?? (prop.length = this.platform.getDefaultDateTimeLength());
                }
            }
            const primary = !meta.compositePK && !!prop.primary && prop.reference === core_1.ReferenceType.SCALAR && this.platform.isNumericColumn(mappedType);
            this.columns[field] = {
                name: prop.fieldNames[idx],
                type: prop.columnTypes[idx],
                mappedType,
                unsigned: prop.unsigned && this.platform.isNumericColumn(mappedType),
                autoincrement: prop.autoincrement ?? primary,
                primary,
                nullable: this.columns[field]?.nullable ?? !!prop.nullable,
                length: prop.length,
                precision: prop.precision,
                scale: prop.scale,
                default: prop.defaultRaw,
                enumItems: prop.items?.every(core_1.Utils.isString) ? prop.items : undefined,
                comment: prop.comment,
                extra: prop.extra,
                ignoreSchemaChanges: prop.ignoreSchemaChanges,
            };
            (_a = this.columns[field]).unsigned || (_a.unsigned = this.columns[field].autoincrement);
            const defaultValue = this.platform.getSchemaHelper().normalizeDefaultValue(prop.defaultRaw, prop.length);
            this.columns[field].default = defaultValue;
        });
        if ([core_1.ReferenceType.MANY_TO_ONE, core_1.ReferenceType.ONE_TO_ONE].includes(prop.reference)) {
            const constraintName = this.getIndexName(true, prop.fieldNames, 'foreign');
            let schema = prop.targetMeta.root.schema === '*' ? this.schema : (prop.targetMeta.root.schema ?? config.get('schema', this.platform.getDefaultSchemaName()));
            if (prop.referencedTableName.includes('.')) {
                schema = undefined;
            }
            this.foreignKeys[constraintName] = {
                constraintName,
                columnNames: prop.fieldNames,
                localTableName: this.getShortestName(),
                referencedColumnNames: prop.referencedColumnNames,
                referencedTableName: schema ? `${schema}.${prop.referencedTableName}` : prop.referencedTableName,
            };
            const cascade = prop.cascade.includes(core_1.Cascade.REMOVE) || prop.cascade.includes(core_1.Cascade.ALL);
            if (prop.onDelete || cascade || prop.nullable) {
                this.foreignKeys[constraintName].deleteRule = prop.onDelete || (cascade ? 'cascade' : 'set null');
            }
            if (prop.onUpdateIntegrity || prop.cascade.includes(core_1.Cascade.PERSIST) || prop.cascade.includes(core_1.Cascade.ALL)) {
                this.foreignKeys[constraintName].updateRule = prop.onUpdateIntegrity || 'cascade';
            }
        }
        if (prop.index) {
            this.indexes.push({
                columnNames: prop.fieldNames,
                composite: prop.fieldNames.length > 1,
                keyName: this.getIndexName(prop.index, prop.fieldNames, 'index'),
                primary: false,
                unique: false,
            });
        }
        if (prop.unique && !(prop.primary && !meta.compositePK)) {
            this.indexes.push({
                columnNames: prop.fieldNames,
                composite: prop.fieldNames.length > 1,
                keyName: this.getIndexName(prop.unique, prop.fieldNames, 'unique'),
                primary: false,
                unique: true,
            });
        }
    }
    getIndexName(value, columnNames, type) {
        if (core_1.Utils.isString(value)) {
            return value;
        }
        return this.platform.getIndexName(this.name, columnNames, type);
    }
    getEntityDeclaration(namingStrategy, schemaHelper) {
        let name = namingStrategy.getClassName(this.name, '_');
        name = name.match(/^\d/) ? 'E' + name : name;
        const schema = new core_1.EntitySchema({ name, collection: this.name, schema: this.schema });
        const compositeFkIndexes = {};
        const compositeFkUniques = {};
        for (const index of this.indexes.filter(index => index.columnNames.length > 1)) {
            const properties = index.columnNames.map(col => this.getPropertyName(namingStrategy, this.getColumn(col)));
            const ret = { name: index.keyName, properties: core_1.Utils.unique(properties) };
            if (ret.properties.length === 1) {
                const map = index.unique ? compositeFkUniques : compositeFkIndexes;
                map[ret.properties[0]] = { keyName: index.keyName };
                continue;
            }
            if (index.primary) {
                //
            }
            else if (index.unique) {
                schema.addUnique(ret);
            }
            else {
                schema.addIndex(ret);
            }
        }
        for (const column of this.getColumns()) {
            const prop = this.getPropertyDeclaration(column, namingStrategy, schemaHelper, compositeFkIndexes, compositeFkUniques);
            schema.addProperty(prop.name, prop.type, prop);
        }
        const meta = schema.init().meta;
        meta.relations
            .filter(prop => prop.primary && prop.reference === core_1.ReferenceType.MANY_TO_ONE && !meta.compositePK)
            .forEach(prop => prop.reference = core_1.ReferenceType.ONE_TO_ONE);
        return meta;
    }
    /**
     * The shortest name is stripped of the default namespace. All other namespaced elements are returned as full-qualified names.
     */
    getShortestName() {
        if (!this.schema || this.name.startsWith(this.schema + '.')) {
            return this.name;
        }
        return `${this.schema}.${this.name}`;
    }
    getForeignKeys() {
        return this.foreignKeys;
    }
    hasColumn(columnName) {
        return columnName in this.columns;
    }
    getIndex(indexName) {
        return this.indexes.find(i => i.keyName === indexName);
    }
    hasIndex(indexName) {
        return !!this.getIndex(indexName);
    }
    getCheck(checkName) {
        return this.checks.find(i => i.name === checkName);
    }
    hasCheck(checkName) {
        return !!this.getCheck(checkName);
    }
    getPrimaryKey() {
        return this.indexes.find(i => i.primary);
    }
    hasPrimaryKey() {
        return !!this.getPrimaryKey();
    }
    getPropertyDeclaration(column, namingStrategy, schemaHelper, compositeFkIndexes, compositeFkUniques) {
        const fk = Object.values(this.foreignKeys).find(fk => fk.columnNames.includes(column.name));
        const prop = this.getPropertyName(namingStrategy, column);
        const index = compositeFkIndexes[prop] || this.indexes.find(idx => idx.columnNames[0] === column.name && !idx.composite && !idx.unique && !idx.primary);
        const unique = compositeFkUniques[prop] || this.indexes.find(idx => idx.columnNames[0] === column.name && !idx.composite && idx.unique && !idx.primary);
        const reference = this.getReferenceType(fk, unique);
        const type = this.getPropertyType(namingStrategy, column, fk);
        const fkOptions = {};
        if (fk) {
            fkOptions.fieldNames = fk.columnNames;
            fkOptions.referencedTableName = fk.referencedTableName;
            fkOptions.referencedColumnNames = fk.referencedColumnNames;
            fkOptions.onUpdateIntegrity = fk.updateRule?.toLowerCase();
            fkOptions.onDelete = fk.deleteRule?.toLowerCase();
        }
        return {
            name: prop,
            type,
            reference,
            columnType: column.type,
            default: this.getPropertyDefaultValue(schemaHelper, column, type),
            defaultRaw: this.getPropertyDefaultValue(schemaHelper, column, type, true),
            nullable: column.nullable,
            primary: column.primary,
            fieldName: column.name,
            length: column.length,
            precision: column.precision,
            scale: column.scale,
            index: index ? index.keyName : undefined,
            unique: unique ? unique.keyName : undefined,
            enum: !!column.enumItems?.length,
            items: column.enumItems,
            ...fkOptions,
        };
    }
    getReferenceType(fk, unique) {
        if (fk && unique) {
            return core_1.ReferenceType.ONE_TO_ONE;
        }
        if (fk) {
            return core_1.ReferenceType.MANY_TO_ONE;
        }
        return core_1.ReferenceType.SCALAR;
    }
    getPropertyName(namingStrategy, column) {
        const fk = Object.values(this.foreignKeys).find(fk => fk.columnNames.includes(column.name));
        let field = column.name;
        if (fk) {
            const idx = fk.columnNames.indexOf(column.name);
            field = field.replace(new RegExp(`_${fk.referencedColumnNames[idx]}$`), '');
        }
        return namingStrategy.columnNameToProperty(field);
    }
    getPropertyType(namingStrategy, column, fk) {
        if (fk) {
            const parts = fk.referencedTableName.split('.', 2);
            return namingStrategy.getClassName(parts.length > 1 ? parts[1] : parts[0], '_');
        }
        // If this column is using an enum.
        if (column.enumItems?.length) {
            // We will create a new enum name for this type and set it as the property type as well.
            // The enum name will be a concatenation of the table name and the column name.
            return namingStrategy.getClassName(this.name + '_' + column.name, '_');
        }
        return column.mappedType?.compareAsType() ?? 'unknown';
    }
    getPropertyDefaultValue(schemaHelper, column, propType, raw = false) {
        const empty = raw ? 'null' : undefined;
        if (!column.default) {
            return empty;
        }
        const val = schemaHelper.normalizeDefaultValue(column.default, column.length);
        if (column.nullable && val === 'null') {
            return empty;
        }
        if (propType === 'boolean' && !raw) {
            return !['0', 'false', 'f', 'n', 'no', 'off'].includes('' + column.default);
        }
        if (propType === 'number') {
            return +column.default;
        }
        // unquote string defaults if `raw = false`
        const match = ('' + val).match(/^'(.*)'$/);
        if (!raw && match) {
            return match[1];
        }
        return '' + val;
    }
    addIndex(meta, index, type) {
        const properties = core_1.Utils.unique(core_1.Utils.flatten(core_1.Utils.asArray(index.properties).map(prop => meta.properties[prop].fieldNames)));
        if (properties.length === 0 && !index.expression) {
            return;
        }
        const name = this.getIndexName(index.name, properties, type);
        this.indexes.push({
            keyName: name,
            columnNames: properties,
            composite: properties.length > 1,
            primary: type === 'primary',
            unique: type !== 'index',
            type: index.type,
            expression: index.expression,
        });
    }
    addCheck(check) {
        this.checks.push(check);
    }
    toJSON() {
        const { platform, columns, ...rest } = this;
        const columnsMapped = Object.keys(columns).reduce((o, col) => {
            const { mappedType, ...restCol } = columns[col];
            o[col] = restCol;
            o[col].mappedType = Object.keys(core_1.t).find(k => core_1.t[k] === mappedType.constructor);
            return o;
        }, {});
        return { columns: columnsMapped, ...rest };
    }
}
exports.DatabaseTable = DatabaseTable;
