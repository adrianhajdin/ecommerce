"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractNamingStrategy = void 0;
class AbstractNamingStrategy {
    getClassName(file, separator = '-') {
        const name = file.split('.')[0];
        const ret = name.replace(new RegExp(`${separator}+(\\w)`, 'g'), m => m[1].toUpperCase());
        return ret.charAt(0).toUpperCase() + ret.slice(1);
    }
    classToMigrationName(timestamp, customMigrationName) {
        let migrationName = `Migration${timestamp}`;
        if (customMigrationName) {
            migrationName += `_${customMigrationName}`;
        }
        return migrationName;
    }
    indexName(tableName, columns, type) {
        /* istanbul ignore next */
        if (tableName.includes('.')) {
            tableName = tableName.substring(tableName.indexOf('.') + 1);
        }
        if (type === 'primary') {
            return `${tableName}_pkey`;
        }
        if (type === 'sequence') {
            return `${tableName}_${columns.join('_')}_seq`;
        }
        if (columns.length > 0) {
            return `${tableName}_${columns.join('_')}_${type}`;
        }
        return `${tableName}_${type}`;
    }
    columnNameToProperty(columnName) {
        return columnName.replace(/[_\- ](\w)/g, m => m[1].toUpperCase()).replace(/[_\- ]+/g, '');
    }
    aliasName(entityName, index) {
        // Take only the first letter of the prefix to keep character counts down since some engines have character limits
        return entityName.charAt(0).toLowerCase() + index;
    }
}
exports.AbstractNamingStrategy = AbstractNamingStrategy;
