import type { NamingStrategy } from '../naming-strategy';
import { type CacheAdapter } from '../cache';
import type { EntityRepository } from '../entity/EntityRepository';
import type { AnyEntity, Constructor, Dictionary, EntityClass, EntityClassGroup, FilterDef, Highlighter, HydratorConstructor, IHydrator, IMigrationGenerator, IPrimaryKey, MaybePromise, MigrationObject } from '../typings';
import { type Logger, type LoggerNamespace, type LoggerOptions } from '../logging';
import type { EntityManager } from '../EntityManager';
import type { Platform } from '../platforms';
import type { EntitySchema } from '../metadata/EntitySchema';
import type { MetadataProvider } from '../metadata/MetadataProvider';
import { MetadataStorage } from '../metadata/MetadataStorage';
import type { EventSubscriber } from '../events';
import type { IDatabaseDriver } from '../drivers/IDatabaseDriver';
import { FlushMode, LoadStrategy, PopulateHint } from '../enums';
import { EntityComparator } from './EntityComparator';
import type { Type } from '../types/Type';
import type { MikroORM } from '../MikroORM';
export declare class Configuration<D extends IDatabaseDriver = IDatabaseDriver> {
    static readonly DEFAULTS: MikroORMOptions;
    static readonly PLATFORMS: {
        mongo: {
            className: string;
            module: () => any;
        };
        mysql: {
            className: string;
            module: () => any;
        };
        mariadb: {
            className: string;
            module: () => any;
        };
        postgresql: {
            className: string;
            module: () => any;
        };
        sqlite: {
            className: string;
            module: () => any;
        };
        'better-sqlite': {
            className: string;
            module: () => any;
        };
    };
    private readonly options;
    private readonly logger;
    private readonly driver;
    private readonly platform;
    private readonly cache;
    private readonly extensions;
    constructor(options: Options, validate?: boolean);
    /**
     * Gets specific configuration option. Falls back to specified `defaultValue` if provided.
     */
    get<T extends keyof MikroORMOptions<D>, U extends MikroORMOptions<D>[T]>(key: T, defaultValue?: U): U;
    getAll(): MikroORMOptions<D>;
    /**
     * Overrides specified configuration value.
     */
    set<T extends keyof MikroORMOptions<D>, U extends MikroORMOptions<D>[T]>(key: T, value: U): void;
    /**
     * Resets the configuration to its default value
     */
    reset<T extends keyof MikroORMOptions<D>, U extends MikroORMOptions<D>[T]>(key: T): void;
    /**
     * Gets Logger instance.
     */
    getLogger(): Logger;
    /**
     * Gets current client URL (connection string).
     */
    getClientUrl(hidePassword?: boolean): string;
    /**
     * Gets current database driver instance.
     */
    getDriver(): D;
    registerExtension(name: string, instance: unknown): void;
    getExtension<T>(name: string): T | undefined;
    /**
     * Gets instance of NamingStrategy. (cached)
     */
    getNamingStrategy(): NamingStrategy;
    /**
     * Gets instance of Hydrator. (cached)
     */
    getHydrator(metadata: MetadataStorage): IHydrator;
    /**
     * Gets instance of Comparator. (cached)
     */
    getComparator(metadata: MetadataStorage): EntityComparator;
    /**
     * Gets instance of MetadataProvider. (cached)
     */
    getMetadataProvider(): MetadataProvider;
    /**
     * Gets instance of CacheAdapter. (cached)
     */
    getCacheAdapter(): CacheAdapter;
    /**
     * Gets instance of CacheAdapter for result cache. (cached)
     */
    getResultCacheAdapter(): CacheAdapter;
    /**
     * Gets EntityRepository class to be instantiated.
     */
    getRepositoryClass(customRepository: () => Constructor<EntityRepository<AnyEntity>>): MikroORMOptions<D>['entityRepository'];
    /**
     * Creates instance of given service and caches it.
     */
    getCachedService<T extends {
        new (...args: any[]): InstanceType<T>;
    }>(cls: T, ...args: ConstructorParameters<T>): InstanceType<T>;
    resetServiceCache(): void;
    private init;
    /**
     * Checks if `src` folder exists, it so, tries to adjust the migrations and seeders paths automatically to use it.
     * If there is a `dist` or `build` folder, it will be used for the JS variant (`path` option), while the `src` folder will be
     * used for the TS variant (`pathTs` option).
     *
     * If the default folder exists (e.g. `/migrations`), the config will respect that, so this auto-detection should not
     * break existing projects, only help with the new ones.
     */
    private detectSourceFolder;
    private validateOptions;
    private initDriver;
}
/**
 * Type helper to make it easier to use `mikro-orm.config.js`.
 */
export declare function defineConfig<D extends IDatabaseDriver>(options: Options<D>): Options<D>;
export interface DynamicPassword {
    password: string;
    expirationChecker?: () => boolean;
}
export interface ConnectionOptions {
    dbName?: string;
    schema?: string;
    name?: string;
    clientUrl?: string;
    host?: string;
    port?: number;
    user?: string;
    password?: string | (() => MaybePromise<string> | MaybePromise<DynamicPassword>);
    charset?: string;
    collate?: string;
    multipleStatements?: boolean;
    pool?: PoolConfig;
}
export type MigrationsOptions = {
    tableName?: string;
    path?: string;
    pathTs?: string;
    glob?: string;
    silent?: boolean;
    transactional?: boolean;
    disableForeignKeys?: boolean;
    allOrNothing?: boolean;
    dropTables?: boolean;
    safe?: boolean;
    snapshot?: boolean;
    snapshotName?: string;
    emit?: 'js' | 'ts' | 'cjs';
    generator?: Constructor<IMigrationGenerator>;
    fileName?: (timestamp: string, name?: string) => string;
    migrationsList?: MigrationObject[];
};
export type SeederOptions = {
    path?: string;
    pathTs?: string;
    glob?: string;
    defaultSeeder?: string;
    emit?: 'js' | 'ts';
    fileName?: (className: string) => string;
};
export interface PoolConfig {
    name?: string;
    afterCreate?: (...a: unknown[]) => unknown;
    min?: number;
    max?: number;
    refreshIdle?: boolean;
    idleTimeoutMillis?: number;
    reapIntervalMillis?: number;
    returnToHead?: boolean;
    priorityRange?: number;
    log?: (message: string, logLevel: string) => void;
    maxWaitingClients?: number;
    testOnBorrow?: boolean;
    acquireTimeoutMillis?: number;
    fifo?: boolean;
    autostart?: boolean;
    evictionRunIntervalMillis?: number;
    numTestsPerRun?: number;
    softIdleTimeoutMillis?: number;
    Promise?: any;
}
export interface MikroORMOptions<D extends IDatabaseDriver = IDatabaseDriver> extends ConnectionOptions {
    entities: (string | EntityClass<AnyEntity> | EntityClassGroup<AnyEntity> | EntitySchema)[];
    entitiesTs: (string | EntityClass<AnyEntity> | EntityClassGroup<AnyEntity> | EntitySchema)[];
    extensions: {
        register: (orm: MikroORM) => void;
    }[];
    subscribers: EventSubscriber[];
    filters: Dictionary<{
        name?: string;
    } & Omit<FilterDef, 'name'>>;
    discovery: {
        warnWhenNoEntities?: boolean;
        requireEntitiesArray?: boolean;
        checkDuplicateTableNames?: boolean;
        alwaysAnalyseProperties?: boolean;
        disableDynamicFileAccess?: boolean;
        getMappedType?: (type: string, platform: Platform) => Type<unknown> | undefined;
        checkDuplicateEntities?: boolean;
    };
    /** @deprecated type option will be removed in v6, use `defineConfig` exported from the driver package to define your ORM config */
    type?: keyof typeof Configuration.PLATFORMS;
    driver?: {
        new (config: Configuration): D;
    };
    driverOptions: Dictionary;
    namingStrategy?: {
        new (): NamingStrategy;
    };
    implicitTransactions?: boolean;
    disableTransactions?: boolean;
    connect: boolean;
    verbose: boolean;
    ignoreUndefinedInQuery?: boolean;
    autoJoinOneToOneOwner: boolean;
    propagateToOneOwner: boolean;
    populateAfterFlush: boolean;
    persistOnCreate: boolean;
    forceEntityConstructor: boolean | (Constructor<AnyEntity> | string)[];
    forceUndefined: boolean;
    forceUtcTimezone: boolean;
    timezone?: string;
    ensureDatabase: boolean;
    ensureIndexes: boolean;
    useBatchInserts?: boolean;
    useBatchUpdates?: boolean;
    batchSize: number;
    hydrator: HydratorConstructor;
    loadStrategy: LoadStrategy;
    populateWhere: PopulateHint;
    flushMode: FlushMode;
    entityRepository?: Constructor;
    replicas?: Partial<ConnectionOptions>[];
    strict: boolean;
    validate: boolean;
    validateRequired: boolean;
    context: (name: string) => EntityManager | undefined;
    contextName: string;
    allowGlobalContext: boolean;
    disableIdentityMap?: boolean;
    logger: (message: string) => void;
    loggerFactory?: (options: LoggerOptions) => Logger;
    findOneOrFailHandler: (entityName: string, where: Dictionary | IPrimaryKey) => Error;
    findExactlyOneOrFailHandler: (entityName: string, where: Dictionary | IPrimaryKey) => Error;
    debug: boolean | LoggerNamespace[];
    highlighter: Highlighter;
    tsNode?: boolean;
    baseDir: string;
    migrations: MigrationsOptions;
    schemaGenerator: {
        disableForeignKeys?: boolean;
        createForeignKeyConstraints?: boolean;
        ignoreSchema?: string[];
        managementDbName?: string;
    };
    entityGenerator: {
        bidirectionalRelations?: boolean;
        identifiedReferences?: boolean;
        entitySchema?: boolean;
        esmImport?: boolean;
    };
    cache: {
        enabled?: boolean;
        pretty?: boolean;
        adapter?: {
            new (...params: any[]): CacheAdapter;
        };
        options?: Dictionary;
    };
    resultCache: {
        expiration?: number;
        adapter?: {
            new (...params: any[]): CacheAdapter;
        };
        options?: Dictionary;
        global?: boolean | number | [string, number];
    };
    metadataProvider: {
        new (config: Configuration): MetadataProvider;
    };
    seeder: SeederOptions;
    preferReadReplicas: boolean;
    dynamicImportProvider: (id: string) => Promise<unknown>;
}
export type Options<D extends IDatabaseDriver = IDatabaseDriver> = Pick<MikroORMOptions<D>, Exclude<keyof MikroORMOptions<D>, keyof typeof Configuration.DEFAULTS>> & Partial<MikroORMOptions<D>>;
