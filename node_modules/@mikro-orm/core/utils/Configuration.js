"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineConfig = exports.Configuration = void 0;
const util_1 = require("util");
const fs_extra_1 = require("fs-extra");
const cache_1 = require("../cache");
const hydration_1 = require("../hydration");
const NullHighlighter_1 = require("../utils/NullHighlighter");
const logging_1 = require("../logging");
const Utils_1 = require("../utils/Utils");
const MetadataStorage_1 = require("../metadata/MetadataStorage");
const ReflectMetadataProvider_1 = require("../metadata/ReflectMetadataProvider");
const errors_1 = require("../errors");
const RequestContext_1 = require("./RequestContext");
const enums_1 = require("../enums");
const MemoryCacheAdapter_1 = require("../cache/MemoryCacheAdapter");
const EntityComparator_1 = require("./EntityComparator");
class Configuration {
    constructor(options, validate = true) {
        var _a;
        this.cache = new Map();
        this.extensions = new Map();
        if (options.dynamicImportProvider) {
            Utils_1.Utils.setDynamicImportProvider(options.dynamicImportProvider);
        }
        this.options = Utils_1.Utils.mergeConfig({}, Configuration.DEFAULTS, options);
        this.options.baseDir = Utils_1.Utils.absolutePath(this.options.baseDir);
        if (validate) {
            this.validateOptions();
        }
        (_a = this.options).loggerFactory ?? (_a.loggerFactory = (options) => new logging_1.DefaultLogger(options));
        this.logger = this.options.loggerFactory({
            debugMode: this.options.debug,
            usesReplicas: (this.options.replicas?.length ?? 0) > 0,
            highlighter: this.options.highlighter,
            writer: this.options.logger,
        });
        this.driver = this.initDriver();
        this.platform = this.driver.getPlatform();
        this.platform.setConfig(this);
        this.detectSourceFolder(options);
        this.init();
    }
    /**
     * Gets specific configuration option. Falls back to specified `defaultValue` if provided.
     */
    get(key, defaultValue) {
        if (typeof this.options[key] !== 'undefined') {
            return this.options[key];
        }
        return defaultValue;
    }
    getAll() {
        return this.options;
    }
    /**
     * Overrides specified configuration value.
     */
    set(key, value) {
        this.options[key] = value;
    }
    /**
     * Resets the configuration to its default value
     */
    reset(key) {
        this.options[key] = Configuration.DEFAULTS[key];
    }
    /**
     * Gets Logger instance.
     */
    getLogger() {
        return this.logger;
    }
    /**
     * Gets current client URL (connection string).
     */
    getClientUrl(hidePassword = false) {
        if (hidePassword) {
            return this.options.clientUrl.replace(/\/\/([^:]+):(.+)@/, '//$1:*****@');
        }
        return this.options.clientUrl;
    }
    /**
     * Gets current database driver instance.
     */
    getDriver() {
        return this.driver;
    }
    registerExtension(name, instance) {
        this.extensions.set(name, instance);
    }
    getExtension(name) {
        return this.extensions.get(name);
    }
    /**
     * Gets instance of NamingStrategy. (cached)
     */
    getNamingStrategy() {
        return this.getCachedService(this.options.namingStrategy || this.platform.getNamingStrategy());
    }
    /**
     * Gets instance of Hydrator. (cached)
     */
    getHydrator(metadata) {
        return this.getCachedService(this.options.hydrator, metadata, this.platform, this);
    }
    /**
     * Gets instance of Comparator. (cached)
     */
    getComparator(metadata) {
        return this.getCachedService(EntityComparator_1.EntityComparator, metadata, this.platform);
    }
    /**
     * Gets instance of MetadataProvider. (cached)
     */
    getMetadataProvider() {
        return this.getCachedService(this.options.metadataProvider, this);
    }
    /**
     * Gets instance of CacheAdapter. (cached)
     */
    getCacheAdapter() {
        return this.getCachedService(this.options.cache.adapter, this.options.cache.options, this.options.baseDir, this.options.cache.pretty);
    }
    /**
     * Gets instance of CacheAdapter for result cache. (cached)
     */
    getResultCacheAdapter() {
        return this.getCachedService(this.options.resultCache.adapter, { expiration: this.options.resultCache.expiration, ...this.options.resultCache.options });
    }
    /**
     * Gets EntityRepository class to be instantiated.
     */
    getRepositoryClass(customRepository) {
        if (customRepository) {
            return customRepository();
        }
        if (this.options.entityRepository) {
            return this.options.entityRepository;
        }
        return this.platform.getRepositoryClass();
    }
    /**
     * Creates instance of given service and caches it.
     */
    getCachedService(cls, ...args) {
        if (!this.cache.has(cls.name)) {
            const Class = cls;
            this.cache.set(cls.name, new Class(...args));
        }
        return this.cache.get(cls.name);
    }
    resetServiceCache() {
        this.cache.clear();
    }
    init() {
        if (!this.getMetadataProvider().useCache()) {
            this.options.cache.adapter = cache_1.NullCacheAdapter;
        }
        if (!('enabled' in this.options.cache)) {
            this.options.cache.enabled = this.getMetadataProvider().useCache();
        }
        if (!this.options.clientUrl) {
            this.options.clientUrl = this.driver.getConnection().getDefaultClientUrl();
        }
        if (!('implicitTransactions' in this.options)) {
            this.set('implicitTransactions', this.platform.usesImplicitTransactions());
        }
        const url = this.getClientUrl().match(/:\/\/.*\/([^?]+)/);
        if (url) {
            this.options.dbName = this.get('dbName', decodeURIComponent(url[1]));
        }
        if (!this.options.charset) {
            this.options.charset = this.platform.getDefaultCharset();
        }
        Object.keys(this.options.filters).forEach(key => {
            var _a;
            (_a = this.options.filters[key]).default ?? (_a.default = true);
        });
        const subscribers = Object.values(MetadataStorage_1.MetadataStorage.getSubscriberMetadata());
        this.options.subscribers = [...new Set([...this.options.subscribers, ...subscribers])];
        if (!logging_1.colors.enabled()) {
            this.options.highlighter = new NullHighlighter_1.NullHighlighter();
        }
    }
    /**
     * Checks if `src` folder exists, it so, tries to adjust the migrations and seeders paths automatically to use it.
     * If there is a `dist` or `build` folder, it will be used for the JS variant (`path` option), while the `src` folder will be
     * used for the TS variant (`pathTs` option).
     *
     * If the default folder exists (e.g. `/migrations`), the config will respect that, so this auto-detection should not
     * break existing projects, only help with the new ones.
     */
    detectSourceFolder(options) {
        if (!(0, fs_extra_1.pathExistsSync)(this.options.baseDir + '/src')) {
            return;
        }
        const migrationsPathExists = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + '/' + this.options.migrations.path);
        const seedersPathExists = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + '/' + this.options.seeder.path);
        const distDir = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + '/dist');
        const buildDir = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + '/build');
        // if neither `dist` nor `build` exist, we use the `src` folder as it might be a JS project without building, but with `src` folder
        const path = distDir ? './dist' : (buildDir ? './build' : './src');
        // only if the user did not provide any values and if the default path does not exist
        if (!options.migrations?.path && !options.migrations?.pathTs && !migrationsPathExists) {
            this.options.migrations.path = `${path}/migrations`;
            this.options.migrations.pathTs = './src/migrations';
        }
        // only if the user did not provide any values and if the default path does not exist
        if (!options.seeder?.path && !options.seeder?.pathTs && !seedersPathExists) {
            this.options.seeder.path = `${path}/seeders`;
            this.options.seeder.pathTs = './src/seeders';
        }
    }
    validateOptions() {
        if (!this.options.type && !this.options.driver) {
            throw new Error('No platform type specified, please fill in `type` or provide custom driver class in `driver` option. Available platforms types: ' + (0, util_1.inspect)(Object.keys(Configuration.PLATFORMS)));
        }
        if (this.options.type && !(this.options.type in Configuration.PLATFORMS)) {
            throw new Error(`Invalid platform type specified: '${this.options.type}', please fill in valid \`type\` or provide custom driver class in \`driver\` option. Available platforms types: ${(0, util_1.inspect)(Object.keys(Configuration.PLATFORMS))}`);
        }
        if (!this.options.dbName && !this.options.clientUrl) {
            throw new Error('No database specified, please fill in `dbName` or `clientUrl` option');
        }
        if (this.options.entities.length === 0 && this.options.discovery.warnWhenNoEntities) {
            throw new Error('No entities found, please use `entities` option');
        }
    }
    initDriver() {
        if (!this.options.driver) {
            const { className, module } = Configuration.PLATFORMS[this.options.type];
            this.options.driver = module()[className];
        }
        return new this.options.driver(this);
    }
}
exports.Configuration = Configuration;
Configuration.DEFAULTS = {
    pool: {},
    entities: [],
    entitiesTs: [],
    extensions: [],
    subscribers: [],
    filters: {},
    discovery: {
        warnWhenNoEntities: true,
        requireEntitiesArray: false,
        checkDuplicateTableNames: true,
        alwaysAnalyseProperties: true,
        disableDynamicFileAccess: false,
        checkDuplicateEntities: true,
    },
    strict: false,
    validate: false,
    validateRequired: true,
    context: (name) => RequestContext_1.RequestContext.getEntityManager(name),
    contextName: 'default',
    allowGlobalContext: false,
    // eslint-disable-next-line no-console
    logger: console.log.bind(console),
    findOneOrFailHandler: (entityName, where) => errors_1.NotFoundError.findOneFailed(entityName, where),
    findExactlyOneOrFailHandler: (entityName, where) => errors_1.NotFoundError.findExactlyOneFailed(entityName, where),
    baseDir: process.cwd(),
    hydrator: hydration_1.ObjectHydrator,
    flushMode: enums_1.FlushMode.AUTO,
    loadStrategy: enums_1.LoadStrategy.SELECT_IN,
    populateWhere: enums_1.PopulateHint.ALL,
    connect: true,
    ignoreUndefinedInQuery: false,
    autoJoinOneToOneOwner: true,
    propagateToOneOwner: true,
    populateAfterFlush: true,
    persistOnCreate: true,
    forceEntityConstructor: false,
    forceUndefined: false,
    forceUtcTimezone: false,
    ensureDatabase: true,
    ensureIndexes: false,
    batchSize: 300,
    debug: false,
    verbose: false,
    driverOptions: {},
    migrations: {
        tableName: 'mikro_orm_migrations',
        path: './migrations',
        glob: '!(*.d).{js,ts,cjs}',
        silent: false,
        transactional: true,
        disableForeignKeys: true,
        allOrNothing: true,
        dropTables: true,
        safe: false,
        snapshot: true,
        emit: 'ts',
        fileName: (timestamp, name) => `Migration${timestamp}${name ? '_' + name : ''}`,
    },
    schemaGenerator: {
        disableForeignKeys: true,
        createForeignKeyConstraints: true,
        ignoreSchema: [],
    },
    entityGenerator: {
        bidirectionalRelations: false,
        identifiedReferences: false,
    },
    cache: {
        pretty: false,
        adapter: cache_1.FileCacheAdapter,
        options: { cacheDir: process.cwd() + '/temp' },
    },
    resultCache: {
        adapter: MemoryCacheAdapter_1.MemoryCacheAdapter,
        expiration: 1000,
        options: {},
    },
    metadataProvider: ReflectMetadataProvider_1.ReflectMetadataProvider,
    highlighter: new NullHighlighter_1.NullHighlighter(),
    seeder: {
        path: './seeders',
        defaultSeeder: 'DatabaseSeeder',
        glob: '!(*.d).{js,ts}',
        emit: 'ts',
        fileName: (className) => className,
    },
    preferReadReplicas: true,
    dynamicImportProvider: /* istanbul ignore next */ (id) => import(id),
};
// TODO remove in v6 (https://github.com/mikro-orm/mikro-orm/issues/3743)
Configuration.PLATFORMS = {
    'mongo': { className: 'MongoDriver', module: () => require('@mikro-orm/mongodb') },
    'mysql': { className: 'MySqlDriver', module: () => require('@mikro-orm/mysql') },
    'mariadb': { className: 'MariaDbDriver', module: () => require('@mikro-orm/mariadb') },
    'postgresql': { className: 'PostgreSqlDriver', module: () => require('@mikro-orm/postgresql') },
    'sqlite': { className: 'SqliteDriver', module: () => require('@mikro-orm/sqlite') },
    'better-sqlite': { className: 'BetterSqliteDriver', module: () => require('@mikro-orm/better-sqlite') },
};
/**
 * Type helper to make it easier to use `mikro-orm.config.js`.
 */
function defineConfig(options) {
    return options;
}
exports.defineConfig = defineConfig;
