"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationLoader = void 0;
const dotenv_1 = __importDefault(require("dotenv"));
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const os_1 = require("os");
const url_1 = require("url");
const Configuration_1 = require("./Configuration");
const Utils_1 = require("./Utils");
const colors_1 = require("../logging/colors");
/**
 * @internal
 */
class ConfigurationLoader {
    static async getConfiguration(validate = true, options = {}) {
        await this.commonJSCompat(options);
        this.registerDotenv(options);
        const paths = await this.getConfigPaths();
        const env = this.loadEnvironmentVars();
        for (let path of paths) {
            path = Utils_1.Utils.absolutePath(path);
            path = Utils_1.Utils.normalizePath(path);
            if (await (0, fs_extra_1.pathExists)(path)) {
                const config = await Utils_1.Utils.dynamicImport(path);
                /* istanbul ignore next */
                let tmp = config.default ?? config;
                if (tmp instanceof Function) {
                    tmp = tmp();
                }
                if (tmp instanceof Promise) {
                    tmp = await tmp;
                }
                const esmConfigOptions = await this.isESM() ? { entityGenerator: { esmImport: true } } : {};
                return new Configuration_1.Configuration(Utils_1.Utils.mergeConfig({}, esmConfigOptions, tmp, options, env), validate);
            }
        }
        if (Utils_1.Utils.hasObjectKeys(env)) {
            return new Configuration_1.Configuration(Utils_1.Utils.mergeConfig({}, options, env), validate);
        }
        throw new Error(`MikroORM config file not found in ['${paths.join(`', '`)}']`);
    }
    static async getPackageConfig(basePath = process.cwd()) {
        if (await (0, fs_extra_1.pathExists)(`${basePath}/package.json`)) {
            /* istanbul ignore next */
            try {
                return await Utils_1.Utils.dynamicImport(`${basePath}/package.json`);
            }
            catch {
                return {};
            }
        }
        const parentFolder = await (0, fs_extra_1.realpath)(`${basePath}/..`);
        // we reached the root folder
        if (basePath === parentFolder) {
            return {};
        }
        return this.getPackageConfig(parentFolder);
    }
    static async getSettings() {
        const config = await ConfigurationLoader.getPackageConfig();
        const settings = { ...config['mikro-orm'] };
        const bool = (v) => ['true', 't', '1'].includes(v.toLowerCase());
        settings.useTsNode = process.env.MIKRO_ORM_CLI_USE_TS_NODE != null ? bool(process.env.MIKRO_ORM_CLI_USE_TS_NODE) : settings.useTsNode;
        settings.tsConfigPath = process.env.MIKRO_ORM_CLI_TS_CONFIG_PATH ?? settings.tsConfigPath;
        settings.alwaysAllowTs = process.env.MIKRO_ORM_CLI_ALWAYS_ALLOW_TS != null ? bool(process.env.MIKRO_ORM_CLI_ALWAYS_ALLOW_TS) : settings.alwaysAllowTs;
        if (process.env.MIKRO_ORM_CLI?.endsWith('.ts')) {
            settings.useTsNode = true;
        }
        return settings;
    }
    static async getConfigPaths() {
        const paths = [];
        const settings = await ConfigurationLoader.getSettings();
        if (process.env.MIKRO_ORM_CLI) {
            paths.push(process.env.MIKRO_ORM_CLI);
        }
        paths.push(...(settings.configPaths || []));
        if (settings.useTsNode || settings.alwaysAllowTs) {
            paths.push('./src/mikro-orm.config.ts');
            paths.push('./mikro-orm.config.ts');
        }
        const distDir = (0, fs_extra_1.pathExistsSync)(process.cwd() + '/dist');
        const buildDir = (0, fs_extra_1.pathExistsSync)(process.cwd() + '/build');
        /* istanbul ignore next */
        const path = distDir ? 'dist' : (buildDir ? 'build' : 'src');
        paths.push(`./${path}/mikro-orm.config.js`);
        paths.push('./mikro-orm.config.js');
        const tsNode = Utils_1.Utils.detectTsNode();
        return Utils_1.Utils.unique(paths).filter(p => p.endsWith('.js') || tsNode || settings.alwaysAllowTs);
    }
    static async isESM() {
        const config = await ConfigurationLoader.getPackageConfig();
        const type = config?.type ?? '';
        return type === 'module';
    }
    static async registerTsNode(configPath = 'tsconfig.json') {
        const tsConfigPath = (0, path_1.isAbsolute)(configPath) ? configPath : (0, path_1.join)(process.cwd(), configPath);
        const tsNode = Utils_1.Utils.tryRequire({
            module: 'ts-node',
            from: tsConfigPath,
            warning: 'ts-node not installed, support for working with TS files might not work',
        });
        /* istanbul ignore next */
        if (!tsNode) {
            return false;
        }
        const { options } = tsNode.register({
            project: tsConfigPath,
            transpileOnly: true,
            compilerOptions: {
                module: 'commonjs',
            },
        }).config;
        if (Object.entries(options?.paths ?? {}).length > 0) {
            Utils_1.Utils.requireFrom('tsconfig-paths', tsConfigPath).register({
                baseUrl: options.baseUrl ?? '.',
                paths: options.paths,
            });
        }
        return true;
    }
    static registerDotenv(options) {
        const baseDir = options instanceof Configuration_1.Configuration ? options.get('baseDir') : options?.baseDir;
        const path = process.env.MIKRO_ORM_ENV ?? ((baseDir ?? process.cwd()) + '/.env');
        dotenv_1.default.config({ path });
    }
    static loadEnvironmentVars() {
        const ret = {};
        const array = (v) => v.split(',').map(vv => vv.trim());
        const bool = (v) => ['true', 't', '1'].includes(v.toLowerCase());
        const num = (v) => +v;
        const read = (o, envKey, key, mapper = v => v) => {
            if (!(envKey in process.env)) {
                return;
            }
            const val = process.env[envKey];
            o[key] = mapper(val);
        };
        const cleanup = (o, k) => Utils_1.Utils.hasObjectKeys(o[k]) ? {} : delete o[k];
        read(ret, 'MIKRO_ORM_BASE_DIR', 'baseDir');
        read(ret, 'MIKRO_ORM_TYPE', 'type');
        read(ret, 'MIKRO_ORM_ENTITIES', 'entities', array);
        read(ret, 'MIKRO_ORM_ENTITIES_TS', 'entitiesTs', array);
        read(ret, 'MIKRO_ORM_CLIENT_URL', 'clientUrl');
        read(ret, 'MIKRO_ORM_HOST', 'host');
        read(ret, 'MIKRO_ORM_PORT', 'port', num);
        read(ret, 'MIKRO_ORM_USER', 'user');
        read(ret, 'MIKRO_ORM_PASSWORD', 'password');
        read(ret, 'MIKRO_ORM_DB_NAME', 'dbName');
        read(ret, 'MIKRO_ORM_SCHEMA', 'schema');
        read(ret, 'MIKRO_ORM_LOAD_STRATEGY', 'loadStrategy');
        read(ret, 'MIKRO_ORM_BATCH_SIZE', 'batchSize', num);
        read(ret, 'MIKRO_ORM_USE_BATCH_INSERTS', 'useBatchInserts', bool);
        read(ret, 'MIKRO_ORM_USE_BATCH_UPDATES', 'useBatchUpdates', bool);
        read(ret, 'MIKRO_ORM_STRICT', 'strict', bool);
        read(ret, 'MIKRO_ORM_VALIDATE', 'validate', bool);
        read(ret, 'MIKRO_ORM_ALLOW_GLOBAL_CONTEXT', 'allowGlobalContext', bool);
        read(ret, 'MIKRO_ORM_AUTO_JOIN_ONE_TO_ONE_OWNER', 'autoJoinOneToOneOwner', bool);
        read(ret, 'MIKRO_ORM_PROPAGATE_TO_ONE_OWNER', 'propagateToOneOwner', bool);
        read(ret, 'MIKRO_ORM_POPULATE_AFTER_FLUSH', 'populateAfterFlush', bool);
        read(ret, 'MIKRO_ORM_FORCE_ENTITY_CONSTRUCTOR', 'forceEntityConstructor', bool);
        read(ret, 'MIKRO_ORM_FORCE_UNDEFINED', 'forceUndefined', bool);
        read(ret, 'MIKRO_ORM_FORCE_UTC_TIMEZONE', 'forceUtcTimezone', bool);
        read(ret, 'MIKRO_ORM_TIMEZONE', 'timezone');
        read(ret, 'MIKRO_ORM_ENSURE_INDEXES', 'ensureIndexes', bool);
        read(ret, 'MIKRO_ORM_IMPLICIT_TRANSACTIONS', 'implicitTransactions', bool);
        read(ret, 'MIKRO_ORM_DEBUG', 'debug', bool);
        read(ret, 'MIKRO_ORM_VERBOSE', 'verbose', bool);
        ret.discovery = {};
        read(ret.discovery, 'MIKRO_ORM_DISCOVERY_WARN_WHEN_NO_ENTITIES', 'warnWhenNoEntities', bool);
        read(ret.discovery, 'MIKRO_ORM_DISCOVERY_REQUIRE_ENTITIES_ARRAY', 'requireEntitiesArray', bool);
        read(ret.discovery, 'MIKRO_ORM_DISCOVERY_ALWAYS_ANALYSE_PROPERTIES', 'alwaysAnalyseProperties', bool);
        read(ret.discovery, 'MIKRO_ORM_DISCOVERY_DISABLE_DYNAMIC_FILE_ACCESS', 'disableDynamicFileAccess', bool);
        cleanup(ret, 'discovery');
        ret.migrations = {};
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_TABLE_NAME', 'tableName');
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_PATH', 'path');
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_PATH_TS', 'pathTs');
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_GLOB', 'glob');
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_TRANSACTIONAL', 'transactional', bool);
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_DISABLE_FOREIGN_KEYS', 'disableForeignKeys', bool);
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_ALL_OR_NOTHING', 'allOrNothing', bool);
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_DROP_TABLES', 'dropTables', bool);
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_SAFE', 'safe', bool);
        read(ret.migrations, 'MIKRO_ORM_MIGRATIONS_EMIT', 'emit');
        cleanup(ret, 'migrations');
        ret.schemaGenerator = {};
        read(ret.schemaGenerator, 'MIKRO_ORM_SCHEMA_GENERATOR_DISABLE_FOREIGN_KEYS', 'disableForeignKeys', bool);
        read(ret.schemaGenerator, 'MIKRO_ORM_SCHEMA_GENERATOR_CREATE_FOREIGN_KEY_CONSTRAINTS', 'createForeignKeyConstraints', bool);
        cleanup(ret, 'schemaGenerator');
        ret.seeder = {};
        read(ret.seeder, 'MIKRO_ORM_SEEDER_PATH', 'path');
        read(ret.seeder, 'MIKRO_ORM_SEEDER_PATH_TS', 'pathTs');
        read(ret.seeder, 'MIKRO_ORM_SEEDER_GLOB', 'glob');
        read(ret.seeder, 'MIKRO_ORM_SEEDER_EMIT', 'emit');
        read(ret.seeder, 'MIKRO_ORM_SEEDER_DEFAULT_SEEDER', 'defaultSeeder');
        cleanup(ret, 'seeder');
        return ret;
    }
    static async getORMPackages() {
        const pkg = await this.getPackageConfig();
        return new Set([
            ...Object.keys(pkg.dependencies ?? {}),
            ...Object.keys(pkg.devDependencies ?? {}),
        ]);
    }
    /** @internal */
    static async commonJSCompat(options) {
        if (await this.isESM()) {
            return;
        }
        /* istanbul ignore next */
        options.dynamicImportProvider ?? (options.dynamicImportProvider = id => {
            if ((0, os_1.platform)() === 'win32') {
                try {
                    id = (0, url_1.fileURLToPath)(id);
                }
                catch {
                    // ignore
                }
            }
            return Utils_1.Utils.requireFrom(id);
        });
        Utils_1.Utils.setDynamicImportProvider(options.dynamicImportProvider);
    }
    static async getORMPackageVersion(name) {
        /* istanbul ignore next */
        try {
            const pkg = Utils_1.Utils.requireFrom(`${name}/package.json`);
            return pkg?.version;
        }
        catch (e) {
            return undefined;
        }
    }
    // inspired by https://github.com/facebook/mikro-orm/pull/3386
    static async checkPackageVersion() {
        const coreVersion = Utils_1.Utils.getORMVersion();
        if (process.env.MIKRO_ORM_ALLOW_VERSION_MISMATCH) {
            return coreVersion;
        }
        const deps = await this.getORMPackages();
        const exceptions = new Set(['nestjs', 'sql-highlighter', 'mongo-highlighter']);
        const ormPackages = [...deps].filter(d => d.startsWith('@mikro-orm/') && d !== '@mikro-orm/core' && !exceptions.has(d.substring('@mikro-orm/'.length)));
        for (const ormPackage of ormPackages) {
            const version = await this.getORMPackageVersion(ormPackage);
            if (version != null && version !== coreVersion) {
                throw new Error(`Bad ${colors_1.colors.cyan(ormPackage)} version ${colors_1.colors.yellow('' + version)}.\n` +
                    `All official @mikro-orm/* packages need to have the exact same version as @mikro-orm/core (${colors_1.colors.green(coreVersion)}).\n` +
                    `Only exceptions are packages that don't live in the 'mikro-orm' repository: ${[...exceptions].join(', ')}.\n` +
                    `Maybe you want to check, or regenerate your yarn.lock or package-lock.json file?`);
            }
        }
        return coreVersion;
    }
}
exports.ConfigurationLoader = ConfigurationLoader;
