"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseDriver = void 0;
const IDatabaseDriver_1 = require("./IDatabaseDriver");
const utils_1 = require("../utils");
const enums_1 = require("../enums");
const EntityManager_1 = require("../EntityManager");
const errors_1 = require("../errors");
const exceptions_1 = require("../exceptions");
const wrap_1 = require("../entity/wrap");
class DatabaseDriver {
    constructor(config, dependencies) {
        this.config = config;
        this.dependencies = dependencies;
        this.replicas = [];
        this.logger = this.config.getLogger();
    }
    async init() {
        // do nothing on this level
    }
    async nativeUpdateMany(entityName, where, data, options) {
        throw new Error(`Batch updates are not supported by ${this.constructor.name} driver`);
    }
    createEntityManager(useContext) {
        return new EntityManager_1.EntityManager(this.config, this, this.metadata, useContext);
    }
    /* istanbul ignore next */
    async findVirtual(entityName, where, options) {
        throw new Error(`Virtual entities are not supported by ${this.constructor.name} driver.`);
    }
    /* istanbul ignore next */
    async countVirtual(entityName, where, options) {
        throw new Error(`Counting virtual entities is not supported by ${this.constructor.name} driver.`);
    }
    async aggregate(entityName, pipeline) {
        throw new Error(`Aggregations are not supported by ${this.constructor.name} driver`);
    }
    async loadFromPivotTable(prop, owners, where, orderBy, ctx, options) {
        throw new Error(`${this.constructor.name} does not use pivot tables`);
    }
    async syncCollection(coll, options) {
        const pk = coll.property.targetMeta.primaryKeys[0];
        const data = { [coll.property.name]: coll.getIdentifiers(pk) };
        await this.nativeUpdate(coll.owner.constructor.name, (0, wrap_1.helper)(coll.owner).getPrimaryKey(), data, options);
    }
    mapResult(result, meta, populate = []) {
        if (!result || !meta) {
            return result ?? null;
        }
        return this.comparator.mapResult(meta.className, result);
    }
    async connect() {
        await this.connection.connect();
        await Promise.all(this.replicas.map(replica => replica.connect()));
        return this.connection;
    }
    async reconnect() {
        await this.close(true);
        await this.connect();
        await this.init();
        return this.connection;
    }
    getConnection(type = 'write') {
        if (type === 'write' || this.replicas.length === 0) {
            return this.connection;
        }
        const rand = utils_1.Utils.randomInt(0, this.replicas.length - 1);
        return this.replicas[rand];
    }
    async close(force) {
        await Promise.all(this.replicas.map(replica => replica.close(force)));
        await this.connection.close(force);
        if (this.config.getCacheAdapter()?.close) {
            await this.config.getCacheAdapter().close();
        }
        if (this.config.getResultCacheAdapter()?.close) {
            await this.config.getResultCacheAdapter().close();
        }
    }
    getPlatform() {
        return this.platform;
    }
    setMetadata(metadata) {
        this.metadata = metadata;
        this.comparator = new utils_1.EntityComparator(this.metadata, this.platform);
        this.connection.setMetadata(metadata);
        this.connection.setPlatform(this.platform);
        this.replicas.forEach(replica => {
            replica.setMetadata(metadata);
            replica.setPlatform(this.platform);
        });
    }
    getMetadata() {
        return this.metadata;
    }
    getDependencies() {
        return this.dependencies;
    }
    async ensureIndexes() {
        throw new Error(`${this.constructor.name} does not use ensureIndexes`);
    }
    inlineEmbeddables(meta, data, where) {
        Object.keys(data).forEach(k => {
            if (utils_1.Utils.isOperator(k)) {
                utils_1.Utils.asArray(data[k]).forEach(payload => this.inlineEmbeddables(meta, payload, where));
            }
        });
        meta.props.forEach(prop => {
            if (prop.reference === enums_1.ReferenceType.EMBEDDED && prop.object && !where && utils_1.Utils.isObject(data[prop.name])) {
                return;
            }
            if (prop.reference === enums_1.ReferenceType.EMBEDDED && utils_1.Utils.isObject(data[prop.name])) {
                const props = prop.embeddedProps;
                let unknownProp = false;
                Object.keys(data[prop.name]).forEach(kk => {
                    // explicitly allow `$exists`, `$eq` and `$ne` operators here as they can't be misused this way
                    const operator = Object.keys(data[prop.name]).some(f => utils_1.Utils.isOperator(f) && !['$exists', '$ne', '$eq'].includes(f));
                    if (operator) {
                        throw errors_1.ValidationError.cannotUseOperatorsInsideEmbeddables(meta.name, prop.name, data);
                    }
                    if (prop.object && where) {
                        const inline = (payload, sub, path) => {
                            if (sub.reference === enums_1.ReferenceType.EMBEDDED && utils_1.Utils.isObject(payload[sub.embedded[1]])) {
                                return Object.keys(payload[sub.embedded[1]]).forEach(kkk => {
                                    if (!sub.embeddedProps[kkk]) {
                                        throw errors_1.ValidationError.invalidEmbeddableQuery(meta.className, kkk, sub.type);
                                    }
                                    inline(payload[sub.embedded[1]], sub.embeddedProps[kkk], [...path, sub.embedded[1]]);
                                });
                            }
                            data[`${path.join('.')}.${sub.embedded[1]}`] = payload[sub.embedded[1]];
                        };
                        const parentPropName = kk.substring(0, kk.indexOf('.'));
                        // we might be using some native JSON operator, e.g. with mongodb's `$geoWithin` or `$exists`
                        if (props[kk]) {
                            inline(data[prop.name], props[kk] || props[parentPropName], [prop.name]);
                        }
                        else if (props[parentPropName]) {
                            data[`${prop.name}.${kk}`] = data[prop.name][kk];
                        }
                        else {
                            unknownProp = true;
                        }
                    }
                    else if (props[kk]) {
                        data[props[kk].name] = data[prop.name][props[kk].embedded[1]];
                    }
                    else {
                        throw errors_1.ValidationError.invalidEmbeddableQuery(meta.className, kk, prop.type);
                    }
                });
                if (!unknownProp) {
                    delete data[prop.name];
                }
            }
        });
    }
    getPivotOrderBy(prop, orderBy) {
        if (!utils_1.Utils.isEmpty(orderBy)) {
            return orderBy;
        }
        if (!utils_1.Utils.isEmpty(prop.orderBy)) {
            return utils_1.Utils.asArray(prop.orderBy);
        }
        if (prop.fixedOrder) {
            return [{ [`${prop.pivotEntity}.${prop.fixedOrderColumn}`]: enums_1.QueryOrder.ASC }];
        }
        return [];
    }
    getPrimaryKeyFields(entityName) {
        const meta = this.metadata.find(entityName);
        return meta ? utils_1.Utils.flatten(meta.getPrimaryProps().map(pk => pk.fieldNames)) : [this.config.getNamingStrategy().referenceColumnName()];
    }
    getPivotInverseProperty(prop) {
        const pivotMeta = this.metadata.find(prop.pivotEntity);
        if (prop.owner) {
            return pivotMeta.relations[0];
        }
        return pivotMeta.relations[1];
    }
    createReplicas(cb) {
        const replicas = this.config.get('replicas', []);
        const ret = [];
        const props = ['dbName', 'clientUrl', 'host', 'port', 'user', 'password', 'multipleStatements', 'pool', 'name'];
        replicas.forEach((conf) => {
            props.forEach(prop => conf[prop] = prop in conf ? conf[prop] : this.config.get(prop));
            ret.push(cb(conf));
        });
        return ret;
    }
    async lockPessimistic(entity, options) {
        throw new Error(`Pessimistic locks are not supported by ${this.constructor.name} driver`);
    }
    /**
     * @inheritDoc
     */
    convertException(exception) {
        if (exception instanceof exceptions_1.DriverException) {
            return exception;
        }
        return this.platform.getExceptionConverter().convertException(exception);
    }
    rethrow(promise) {
        return promise.catch(e => {
            throw this.convertException(e);
        });
    }
    /**
     * @internal
     */
    getTableName(meta, options) {
        const tableName = this.platform.quoteIdentifier(meta.tableName);
        const schema = this.getSchemaName(meta, options);
        if (schema) {
            return this.platform.quoteIdentifier(schema) + '.' + tableName;
        }
        return tableName;
    }
    /**
     * @internal
     */
    getSchemaName(meta, options) {
        if (meta?.schema && meta.schema !== '*') {
            return meta.schema;
        }
        if (options?.schema === '*') {
            return this.config.get('schema');
        }
        const schemaName = meta?.schema === '*' ? this.config.get('schema') : meta?.schema;
        return options?.schema ?? schemaName ?? this.config.get('schema');
    }
}
exports.DatabaseDriver = DatabaseDriver;
