"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const url_1 = require("url");
class Connection {
    constructor(config, options, type = 'write') {
        this.config = config;
        this.type = type;
        this.logger = this.config.getLogger();
        if (options) {
            this.options = options;
        }
        else {
            const props = ['dbName', 'clientUrl', 'host', 'port', 'user', 'password', 'multipleStatements', 'pool'];
            this.options = props.reduce((o, i) => {
                o[i] = this.config.get(i);
                return o;
            }, {});
        }
    }
    /**
     * Closes the database connection (aka disconnect)
     */
    async close(force) {
        Object.keys(this.options)
            .filter(k => k !== 'name')
            .forEach(k => delete this.options[k]);
    }
    async transactional(cb, options) {
        throw new Error(`Transactions are not supported by current driver`);
    }
    async begin(options) {
        throw new Error(`Transactions are not supported by current driver`);
    }
    async commit(ctx, eventBroadcaster) {
        throw new Error(`Transactions are not supported by current driver`);
    }
    async rollback(ctx, eventBroadcaster) {
        throw new Error(`Transactions are not supported by current driver`);
    }
    getConnectionOptions() {
        const ret = {};
        if (this.options.clientUrl) {
            const url = new url_1.URL(this.options.clientUrl);
            this.options.host = ret.host = this.options.host ?? decodeURIComponent(url.hostname);
            this.options.port = ret.port = this.options.port ?? +url.port;
            this.options.user = ret.user = this.options.user ?? decodeURIComponent(url.username);
            this.options.password = ret.password = this.options.password ?? decodeURIComponent(url.password);
            this.options.dbName = ret.database = this.options.dbName ?? decodeURIComponent(url.pathname).replace(/^\//, '');
        }
        else {
            const url = new url_1.URL(this.config.getClientUrl());
            this.options.host = ret.host = this.options.host ?? this.config.get('host', decodeURIComponent(url.hostname));
            this.options.port = ret.port = this.options.port ?? this.config.get('port', +url.port);
            this.options.user = ret.user = this.options.user ?? this.config.get('user', decodeURIComponent(url.username));
            this.options.password = ret.password = this.options.password ?? this.config.get('password', decodeURIComponent(url.password));
            this.options.dbName = ret.database = this.options.dbName ?? this.config.get('dbName', decodeURIComponent(url.pathname).replace(/^\//, ''));
        }
        return ret;
    }
    getClientUrl() {
        const options = this.getConnectionOptions();
        const url = new url_1.URL(this.config.getClientUrl(true));
        return `${url.protocol}//${options.user}${options.password ? ':*****' : ''}@${options.host}:${options.port}`;
    }
    setMetadata(metadata) {
        this.metadata = metadata;
    }
    setPlatform(platform) {
        this.platform = platform;
    }
    getPlatform() {
        return this.platform;
    }
    async executeQuery(query, cb, context) {
        const now = Date.now();
        try {
            const res = await cb();
            this.logQuery(query, { ...context, took: Date.now() - now, results: Array.isArray(res) ? res.length : undefined });
            return res;
        }
        catch (e) {
            this.logQuery(query, { ...context, took: Date.now() - now, level: 'error' });
            throw e;
        }
    }
    logQuery(query, context = {}) {
        this.logger.logQuery({
            level: 'info',
            connection: {
                type: this.type,
                name: this.options.name || this.config.get('name') || this.options.host,
            },
            ...context,
            query,
        });
    }
}
exports.Connection = Connection;
