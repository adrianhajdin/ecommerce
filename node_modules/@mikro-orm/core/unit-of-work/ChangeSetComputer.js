"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeSetComputer = void 0;
const utils_1 = require("../utils");
const ChangeSet_1 = require("./ChangeSet");
const entity_1 = require("../entity");
const enums_1 = require("../enums");
class ChangeSetComputer {
    constructor(validator, collectionUpdates, metadata, platform, config) {
        this.validator = validator;
        this.collectionUpdates = collectionUpdates;
        this.metadata = metadata;
        this.platform = platform;
        this.config = config;
        this.comparator = this.config.getComparator(this.metadata);
    }
    computeChangeSet(entity) {
        const meta = this.metadata.get(entity.constructor.name);
        if (meta.readonly) {
            return null;
        }
        const wrapped = (0, entity_1.helper)(entity);
        const type = wrapped.__originalEntityData ? ChangeSet_1.ChangeSetType.UPDATE : ChangeSet_1.ChangeSetType.CREATE;
        const map = new Map();
        // Execute `onCreate` and `onUpdate` on properties recursively, saves `onUpdate` results
        // to the `map` as we want to apply those only if something else changed.
        if (type === ChangeSet_1.ChangeSetType.CREATE) { // run update hooks only after we know there are other changes
            for (const prop of meta.hydrateProps) {
                this.processPropertyInitializers(entity, prop, type, map);
            }
        }
        if (type === ChangeSet_1.ChangeSetType.UPDATE && !wrapped.__initialized && !wrapped.isTouched()) {
            return null;
        }
        const changeSet = new ChangeSet_1.ChangeSet(entity, type, this.computePayload(entity), meta);
        changeSet.originalEntity = wrapped.__originalEntityData;
        if (this.config.get('validate')) {
            this.validator.validate(changeSet.entity, changeSet.payload, meta);
        }
        for (const prop of meta.relations.filter(prop => prop.persist !== false || prop.userDefined === false)) {
            this.processProperty(changeSet, prop);
        }
        if (changeSet.type === ChangeSet_1.ChangeSetType.UPDATE && !utils_1.Utils.hasObjectKeys(changeSet.payload)) {
            return null;
        }
        // Execute `onCreate` and `onUpdate` on properties recursively, saves `onUpdate` results
        // to the `map` as we want to apply those only if something else changed.
        if (type === ChangeSet_1.ChangeSetType.UPDATE) {
            for (const prop of meta.hydrateProps) {
                this.processPropertyInitializers(entity, prop, type, map);
            }
        }
        if (map.size > 0) {
            for (const [entity, pairs] of map) {
                for (const [prop, value] of pairs) {
                    entity[prop] = value;
                }
            }
            // Recompute the changeset, we need to merge this as here we ignore relations.
            const diff = this.computePayload(entity, true);
            utils_1.Utils.merge(changeSet.payload, diff);
        }
        return changeSet;
    }
    /**
     * Traverses entity graph and executes `onCreate` and `onUpdate` methods, assigning the values to given properties.
     */
    processPropertyInitializers(entity, prop, type, map, nested) {
        if (prop.onCreate && type === ChangeSet_1.ChangeSetType.CREATE && entity[prop.name] == null) {
            entity[prop.name] = prop.onCreate(entity);
        }
        if (prop.onUpdate && type === ChangeSet_1.ChangeSetType.UPDATE) {
            const pairs = map.get(entity) ?? [];
            pairs.push([prop.name, prop.onUpdate(entity)]);
            map.set(entity, pairs);
        }
        if (prop.reference === enums_1.ReferenceType.EMBEDDED && entity[prop.name]) {
            for (const embeddedProp of prop.targetMeta.hydrateProps) {
                this.processPropertyInitializers(entity[prop.name], embeddedProp, type, map, nested || prop.object);
            }
        }
    }
    computePayload(entity, ignoreUndefined = false) {
        const data = this.comparator.prepareEntity(entity);
        const entityName = (0, entity_1.helper)(entity).__meta.root.className;
        const originalEntityData = (0, entity_1.helper)(entity).__originalEntityData;
        if (originalEntityData) {
            const comparator = this.comparator.getEntityComparator(entityName);
            const diff = comparator(originalEntityData, data);
            if (ignoreUndefined) {
                Object.keys(diff)
                    .filter(k => diff[k] === undefined)
                    .forEach(k => delete diff[k]);
            }
            return diff;
        }
        return data;
    }
    processProperty(changeSet, prop, target) {
        if (!target) {
            const targets = utils_1.Utils.unwrapProperty(changeSet.entity, changeSet.meta, prop);
            targets.forEach(([t]) => this.processProperty(changeSet, prop, t));
            return;
        }
        if (utils_1.Utils.isCollection(target)) { // m:n or 1:m
            this.processToMany(prop, changeSet);
        }
        if ([enums_1.ReferenceType.MANY_TO_ONE, enums_1.ReferenceType.ONE_TO_ONE].includes(prop.reference)) {
            this.processToOne(prop, changeSet);
        }
    }
    processToOne(prop, changeSet) {
        const isToOneOwner = prop.reference === enums_1.ReferenceType.MANY_TO_ONE || (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && prop.owner);
        if (!isToOneOwner || prop.mapToPk) {
            return;
        }
        const targets = utils_1.Utils.unwrapProperty(changeSet.entity, changeSet.meta, prop);
        targets.forEach(([target, idx]) => {
            if (!target.__helper.hasPrimaryKey()) {
                utils_1.Utils.setPayloadProperty(changeSet.payload, this.metadata.find(changeSet.name), prop, target.__helper.__identifier, idx);
            }
        });
    }
    processToMany(prop, changeSet) {
        const target = changeSet.entity[prop.name];
        if (!target.isDirty()) {
            return;
        }
        if (prop.owner || target.getItems(false).filter(item => !item.__helper.__initialized).length > 0) {
            if (this.platform.usesPivotTable()) {
                this.collectionUpdates.add(target);
            }
            else {
                changeSet.payload[prop.name] = target.getItems(false).map((item) => item.__helper.__identifier ?? item.__helper.getPrimaryKey());
            }
        }
        else if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY && target.getSnapshot() === undefined) {
            this.collectionUpdates.add(target);
        }
        else {
            target.setDirty(false); // inverse side with only populated items, nothing to persist
        }
    }
}
exports.ChangeSetComputer = ChangeSetComputer;
