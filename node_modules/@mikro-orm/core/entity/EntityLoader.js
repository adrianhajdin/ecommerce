"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityLoader = void 0;
const QueryHelper_1 = require("../utils/QueryHelper");
const Utils_1 = require("../utils/Utils");
const errors_1 = require("../errors");
const enums_1 = require("../enums");
const Reference_1 = require("./Reference");
const wrap_1 = require("./wrap");
class EntityLoader {
    constructor(em) {
        this.em = em;
        this.metadata = this.em.getMetadata();
        this.driver = this.em.getDriver();
    }
    /**
     * Loads specified relations in batch. This will execute one query for each relation, that will populate it on all of the specified entities.
     */
    async populate(entityName, entities, populate, options) {
        var _a;
        if (entities.length === 0 || Utils_1.Utils.isEmpty(populate)) {
            return;
        }
        if (entities.some(e => !e.__helper)) {
            const entity = entities.find(e => !Utils_1.Utils.isEntity(e));
            const meta = this.metadata.find(entityName);
            throw errors_1.ValidationError.notDiscoveredEntity(entity, meta, 'populate');
        }
        const visited = (_a = options).visited ?? (_a.visited = new Set());
        options.where ?? (options.where = {});
        options.orderBy ?? (options.orderBy = {});
        options.filters ?? (options.filters = {});
        options.lookup ?? (options.lookup = true);
        options.validate ?? (options.validate = true);
        options.refresh ?? (options.refresh = false);
        options.convertCustomTypes ?? (options.convertCustomTypes = true);
        populate = this.normalizePopulate(entityName, populate, options.strategy, options.lookup);
        const invalid = populate.find(({ field }) => !this.em.canPopulate(entityName, field));
        /* istanbul ignore next */
        if (options.validate && invalid) {
            throw errors_1.ValidationError.invalidPropertyName(entityName, invalid.field);
        }
        for (const entity of entities) {
            const context = (0, wrap_1.helper)(entity).__serializationContext;
            context.populate ?? (context.populate = populate);
            visited.add(entity);
        }
        for (const pop of populate) {
            await this.populateField(entityName, entities, pop, options);
        }
    }
    normalizePopulate(entityName, populate, strategy, lookup = true) {
        const meta = this.metadata.find(entityName);
        if (populate === true || populate.some(p => p.all)) {
            populate = this.lookupAllRelationships(entityName);
        }
        else {
            populate = Utils_1.Utils.asArray(populate);
        }
        // convert nested `field` with dot syntax to PopulateOptions with `children` array
        this.expandDotPaths(populate, meta);
        if (lookup) {
            populate = this.lookupEagerLoadedRelationships(entityName, populate, strategy);
            // convert nested `field` with dot syntax produced by eager relations
            this.expandDotPaths(populate, meta);
        }
        // merge same fields
        return this.mergeNestedPopulate(populate);
    }
    expandDotPaths(normalized, meta) {
        normalized.forEach(p => {
            if (!p.field.includes('.')) {
                return;
            }
            const [f, ...parts] = p.field.split('.');
            p.field = f;
            p.children = p.children || [];
            const prop = meta.properties[f];
            p.strategy ?? (p.strategy = prop.strategy);
            p.children.push(this.expandNestedPopulate(prop.type, parts, p.strategy, p.all));
        });
    }
    /**
     * Merge multiple populates for the same entity with different children. Also skips `*` fields, those can come from
     * partial loading hints (`fields`) that are used to infer the `populate` hint if missing.
     */
    mergeNestedPopulate(populate) {
        const tmp = populate.reduce((ret, item) => {
            if (item.field === '*') {
                return ret;
            }
            if (!ret[item.field]) {
                ret[item.field] = item;
                return ret;
            }
            if (!ret[item.field].children && item.children) {
                ret[item.field].children = item.children;
            }
            else if (ret[item.field].children && item.children) {
                ret[item.field].children.push(...item.children);
            }
            return ret;
        }, {});
        return Object.values(tmp).map(item => {
            if (item.children) {
                item.children = this.mergeNestedPopulate(item.children);
            }
            return item;
        });
    }
    /**
     * Expands `books.perex` like populate to use `children` array instead of the dot syntax
     */
    expandNestedPopulate(entityName, parts, strategy, all) {
        const meta = this.metadata.find(entityName);
        const field = parts.shift();
        const prop = meta.properties[field];
        const ret = { field, strategy, all };
        if (parts.length > 0) {
            ret.children = [this.expandNestedPopulate(prop.type, parts, strategy)];
        }
        return ret;
    }
    /**
     * preload everything in one call (this will update already existing references in IM)
     */
    async populateMany(entityName, entities, populate, options) {
        const field = populate.field;
        const meta = this.metadata.find(entityName);
        const prop = meta.properties[field];
        if (prop.reference === enums_1.ReferenceType.SCALAR && prop.lazy) {
            const filtered = entities.filter(e => options.refresh || e[prop.name] === undefined);
            if (options.ignoreLazyScalarProperties || filtered.length === 0) {
                return entities;
            }
            const pk = Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
            const ids = Utils_1.Utils.unique(filtered.map(e => Utils_1.Utils.getPrimaryKeyValues(e, meta.primaryKeys, true)));
            const where = this.mergePrimaryCondition(ids, pk, options, meta, this.metadata, this.driver.getPlatform());
            const { filters, convertCustomTypes, lockMode, strategy, populateWhere, connectionType } = options;
            await this.em.find(meta.className, where, {
                filters, convertCustomTypes, lockMode, strategy, populateWhere, connectionType,
                fields: [prop.name],
                populate: [],
            });
            return entities;
        }
        if (prop.reference === enums_1.ReferenceType.EMBEDDED) {
            return [];
        }
        // set populate flag
        entities.forEach(entity => {
            const value = entity[field];
            if (Utils_1.Utils.isEntity(value, true)) {
                value.__helper.populated();
            }
            else if (Utils_1.Utils.isCollection(value)) {
                value.populated();
            }
        });
        const filtered = this.filterCollections(entities, field, options.refresh);
        const innerOrderBy = Utils_1.Utils.asArray(options.orderBy)
            .filter(orderBy => Utils_1.Utils.isObject(orderBy[prop.name]))
            .map(orderBy => orderBy[prop.name]);
        if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && this.driver.getPlatform().usesPivotTable()) {
            return this.findChildrenFromPivotTable(filtered, prop, options, innerOrderBy, populate);
        }
        const where = await this.extractChildCondition(options, prop);
        const data = await this.findChildren(entities, prop, populate, { ...options, where, orderBy: innerOrderBy });
        this.initializeCollections(filtered, prop, field, data);
        return data;
    }
    initializeCollections(filtered, prop, field, children) {
        if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            this.initializeOneToMany(filtered, children, prop, field);
        }
        if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && !prop.owner && !this.driver.getPlatform().usesPivotTable()) {
            this.initializeManyToMany(filtered, children, prop, field);
        }
    }
    initializeOneToMany(filtered, children, prop, field) {
        const mapToPk = prop.targetMeta.properties[prop.mappedBy].mapToPk;
        const map = {};
        filtered.forEach(entity => {
            const key = (0, wrap_1.helper)(entity).getSerializedPrimaryKey();
            return map[key] = [];
        });
        if (mapToPk) {
            children.forEach(child => {
                const pk = child.__helper.__data[prop.mappedBy] ?? child[prop.mappedBy];
                if (pk) {
                    const key = (0, wrap_1.helper)(this.em.getReference(prop.type, pk)).getSerializedPrimaryKey();
                    map[key]?.push(child);
                }
            });
        }
        else {
            children.forEach(child => {
                const entity = child.__helper.__data[prop.mappedBy] ?? child[prop.mappedBy];
                if (entity) {
                    const key = (0, wrap_1.helper)(entity).getSerializedPrimaryKey();
                    map[key]?.push(child);
                }
            });
        }
        filtered.forEach(entity => {
            const key = (0, wrap_1.helper)(entity).getSerializedPrimaryKey();
            entity[field].hydrate(map[key]);
        });
    }
    initializeManyToMany(filtered, children, prop, field) {
        for (const entity of filtered) {
            const items = children.filter(child => child[prop.mappedBy].contains(entity));
            entity[field].hydrate(items, true);
        }
    }
    async findChildren(entities, prop, populate, options) {
        const children = this.getChildReferences(entities, prop, options.refresh);
        const meta = this.metadata.find(prop.type);
        let fk = Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
        let schema = options.schema;
        if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY || (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && !prop.owner)) {
            fk = meta.properties[prop.mappedBy].name;
        }
        if (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && !prop.owner && populate.strategy !== enums_1.LoadStrategy.JOINED && !this.em.config.get('autoJoinOneToOneOwner')) {
            children.length = 0;
            fk = meta.properties[prop.mappedBy].name;
            children.push(...this.filterByReferences(entities, prop.name, options.refresh));
        }
        if (children.length === 0) {
            return [];
        }
        if (!schema && [enums_1.ReferenceType.ONE_TO_ONE, enums_1.ReferenceType.MANY_TO_ONE].includes(prop.reference)) {
            schema = children.find(e => e.__helper.__schema)?.__helper.__schema;
        }
        const ids = Utils_1.Utils.unique(children.map(e => e.__helper.getPrimaryKey()));
        const where = this.mergePrimaryCondition(ids, fk, options, meta, this.metadata, this.driver.getPlatform());
        const fields = this.buildFields(options.fields, prop);
        const { refresh, filters, convertCustomTypes, lockMode, strategy, populateWhere, connectionType } = options;
        return this.em.find(prop.type, where, {
            filters, convertCustomTypes, lockMode, populateWhere,
            orderBy: [...Utils_1.Utils.asArray(options.orderBy), ...Utils_1.Utils.asArray(prop.orderBy), { [fk]: enums_1.QueryOrder.ASC }],
            populate: populate.children ?? populate.all ?? [],
            strategy, fields, schema, connectionType,
            // @ts-ignore not a public option, will be propagated to the populate call
            refresh: refresh && !children.every(item => options.visited.has(item)),
            // @ts-ignore not a public option, will be propagated to the populate call
            visited: options.visited,
        });
    }
    mergePrimaryCondition(ids, pk, options, meta, metadata, platform) {
        const cond1 = QueryHelper_1.QueryHelper.processWhere({ where: { [pk]: { $in: ids } }, entityName: meta.name, metadata, platform, convertCustomTypes: !options.convertCustomTypes });
        return options.where[pk]
            ? { $and: [cond1, options.where] }
            : { ...cond1, ...options.where };
    }
    async populateField(entityName, entities, populate, options) {
        const prop = this.metadata.find(entityName).properties[populate.field];
        if (prop.reference === enums_1.ReferenceType.SCALAR && !prop.lazy) {
            return;
        }
        const populated = await this.populateMany(entityName, entities, populate, options);
        if (!populate.children && !populate.all) {
            return;
        }
        const children = [];
        for (const entity of entities) {
            if (Utils_1.Utils.isEntity(entity[populate.field])) {
                children.push(entity[populate.field]);
            }
            else if (Reference_1.Reference.isReference(entity[populate.field])) {
                children.push(entity[populate.field].unwrap());
            }
            else if (Utils_1.Utils.isCollection(entity[populate.field])) {
                children.push(...entity[populate.field].getItems());
            }
            else if (entity[populate.field] && prop.reference === enums_1.ReferenceType.EMBEDDED) {
                children.push(...Utils_1.Utils.asArray(entity[populate.field]));
            }
        }
        if (populated.length === 0 && !populate.children) {
            return;
        }
        const fields = this.buildFields(options.fields, prop);
        const innerOrderBy = Utils_1.Utils.asArray(options.orderBy)
            .filter(orderBy => Utils_1.Utils.isObject(orderBy[prop.name]))
            .map(orderBy => orderBy[prop.name]);
        const { refresh, filters, ignoreLazyScalarProperties, populateWhere, connectionType } = options;
        const filtered = Utils_1.Utils.unique(children.filter(e => !options.visited.has(e)));
        await this.populate(prop.type, filtered, populate.children ?? populate.all, {
            where: await this.extractChildCondition(options, prop, false),
            orderBy: innerOrderBy,
            fields,
            validate: false,
            lookup: false,
            filters,
            ignoreLazyScalarProperties,
            populateWhere,
            connectionType,
            // @ts-ignore not a public option, will be propagated to the populate call
            refresh: refresh && !filtered.every(item => options.visited.has(item)),
            // @ts-ignore not a public option, will be propagated to the populate call
            visited: options.visited,
        });
    }
    async findChildrenFromPivotTable(filtered, prop, options, orderBy, populate) {
        const ids = filtered.map(e => e.__helper.__primaryKeys);
        const refresh = options.refresh;
        const where = await this.extractChildCondition(options, prop, true);
        const fields = this.buildFields(options.fields, prop);
        const options2 = { ...options };
        delete options2.limit;
        delete options2.offset;
        options2.fields = fields;
        options2.populate = (populate?.children ?? []);
        if (prop.customType) {
            ids.forEach((id, idx) => ids[idx] = QueryHelper_1.QueryHelper.processCustomType(prop, id, this.driver.getPlatform()));
        }
        const map = await this.driver.loadFromPivotTable(prop, ids, where, orderBy, this.em.getTransactionContext(), options2);
        const children = [];
        for (const entity of filtered) {
            const items = map[entity.__helper.getSerializedPrimaryKey()].map(item => {
                const entity = this.em.getEntityFactory().create(prop.type, item, {
                    refresh,
                    merge: true,
                    convertCustomTypes: true,
                    schema: options.schema ?? this.em.config.get('schema'),
                });
                return this.em.getUnitOfWork().registerManaged(entity, item, { refresh, loaded: true });
            });
            entity[prop.name].hydrate(items, true);
            children.push(...items);
        }
        return children;
    }
    async extractChildCondition(options, prop, filters = false) {
        const subCond = Utils_1.Utils.isPlainObject(options.where[prop.name]) ? options.where[prop.name] : {};
        const meta2 = this.metadata.find(prop.type);
        const pk = Utils_1.Utils.getPrimaryKeyHash(meta2.primaryKeys);
        ['$and', '$or'].forEach(op => {
            if (options.where[op]) {
                const child = options.where[op]
                    .map((cond) => cond[prop.name])
                    .filter((sub) => sub != null && !(Utils_1.Utils.isPlainObject(sub) && Object.keys(sub).every(key => Utils_1.Utils.isOperator(key, false))))
                    .map((cond) => {
                    if (Utils_1.Utils.isPrimaryKey(cond)) {
                        return { [pk]: cond };
                    }
                    return cond;
                });
                if (child.length > 0) {
                    subCond[op] = child;
                }
            }
        });
        const operators = Object.keys(subCond).filter(key => Utils_1.Utils.isOperator(key, false));
        if (operators.length > 0) {
            operators.forEach(op => {
                subCond[pk] ?? (subCond[pk] = {});
                subCond[pk][op] = subCond[op];
                delete subCond[op];
            });
        }
        if (filters) {
            return this.em.applyFilters(prop.type, subCond, options.filters, 'read', options);
        }
        return subCond;
    }
    buildFields(fields = [], prop) {
        const ret = fields.reduce((ret, f) => {
            if (Utils_1.Utils.isPlainObject(f)) {
                Object.keys(f)
                    .filter(ff => ff === prop.name)
                    .forEach(ff => ret.push(...f[ff]));
            }
            else if (f.toString().includes('.')) {
                const parts = f.toString().split('.');
                const propName = parts.shift();
                const childPropName = parts.join('.');
                /* istanbul ignore else */
                if (propName === prop.name) {
                    ret.push(childPropName);
                }
            }
            return ret;
        }, []);
        if (ret.length === 0) {
            return undefined;
        }
        // we need to automatically select the FKs too, e.g. for 1:m relations to be able to wire them with the items
        if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            const owner = prop.targetMeta.properties[prop.mappedBy];
            if (!ret.includes(owner.name)) {
                ret.push(owner.name);
            }
        }
        return ret;
    }
    getChildReferences(entities, prop, refresh) {
        const filtered = this.filterCollections(entities, prop.name, refresh);
        const children = [];
        if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            children.push(...filtered.map(e => e[prop.name].owner));
        }
        else if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && prop.owner) {
            children.push(...filtered.reduce((a, b) => [...a, ...b[prop.name].getItems()], []));
        }
        else if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY) { // inverse side
            children.push(...filtered);
        }
        else { // MANY_TO_ONE or ONE_TO_ONE
            children.push(...this.filterReferences(entities, prop.name, refresh));
        }
        return children;
    }
    filterCollections(entities, field, refresh) {
        if (refresh) {
            return entities.filter(e => e[field]);
        }
        return entities.filter(e => Utils_1.Utils.isCollection(e[field]) && !e[field].isInitialized(true));
    }
    filterReferences(entities, field, refresh) {
        const children = entities.filter(e => Utils_1.Utils.isEntity(e[field], true));
        if (refresh) {
            return children.map(e => Reference_1.Reference.unwrapReference(e[field]));
        }
        return children.filter(e => !e[field].__helper.__initialized).map(e => Reference_1.Reference.unwrapReference(e[field]));
    }
    filterByReferences(entities, field, refresh) {
        /* istanbul ignore next */
        if (refresh) {
            return entities;
        }
        return entities.filter(e => !e[field]?.__helper?.__initialized);
    }
    lookupAllRelationships(entityName) {
        const ret = [];
        const meta = this.metadata.find(entityName);
        meta.relations.forEach(prop => {
            ret.push({
                field: this.getRelationName(meta, prop),
                // force select-in strategy when populating all relations as otherwise we could cause infinite loops when self-referencing
                strategy: enums_1.LoadStrategy.SELECT_IN,
                // no need to look up populate children recursively as we just pass `all: true` here
                all: true,
            });
        });
        return ret;
    }
    getRelationName(meta, prop) {
        if (!prop.embedded) {
            return prop.name;
        }
        return `${this.getRelationName(meta, meta.properties[prop.embedded[0]])}.${prop.embedded[1]}`;
    }
    lookupEagerLoadedRelationships(entityName, populate, strategy, prefix = '', visited = []) {
        const meta = this.metadata.find(entityName);
        if (!meta && !prefix) {
            return populate;
        }
        if (visited.includes(entityName) || !meta) {
            return [];
        }
        visited.push(entityName);
        const ret = prefix === '' ? [...populate] : [];
        meta.relations
            .filter(prop => prop.eager || populate.some(p => p.field === prop.name))
            .forEach(prop => {
            const field = this.getRelationName(meta, prop);
            const prefixed = prefix ? `${prefix}.${field}` : field;
            const nestedPopulate = populate.filter(p => p.field === prop.name).flatMap(p => p.children).filter(Boolean);
            const nested = this.lookupEagerLoadedRelationships(prop.type, nestedPopulate, strategy, prefixed, visited.slice());
            if (nested.length > 0) {
                ret.push(...nested);
            }
            else {
                const selfReferencing = [meta.className, meta.root.className, ...visited].includes(prop.type) && prop.eager;
                ret.push({
                    field: prefixed,
                    // enforce select-in strategy for self-referencing relations
                    strategy: selfReferencing ? enums_1.LoadStrategy.SELECT_IN : strategy ?? prop.strategy,
                });
            }
        });
        return ret;
    }
}
exports.EntityLoader = EntityLoader;
