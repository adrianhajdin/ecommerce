"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = void 0;
const ArrayCollection_1 = require("./ArrayCollection");
const Utils_1 = require("../utils/Utils");
const errors_1 = require("../errors");
const enums_1 = require("../enums");
const Reference_1 = require("./Reference");
const wrap_1 = require("./wrap");
class Collection extends ArrayCollection_1.ArrayCollection {
    constructor(owner, items, initialized = true) {
        super(owner, items);
        this.snapshot = []; // used to create a diff of the collection at commit time, undefined marks overridden values so we need to wipe when flushing
        this._populated = false;
        this._lazyInitialized = false;
        this.initialized = !!items || initialized;
    }
    /**
     * Creates new Collection instance, assigns it to the owning entity and sets the items to it (propagating them to their inverse sides)
     */
    static create(owner, prop, items, initialized) {
        const coll = new Collection(owner, undefined, initialized);
        coll.property = (0, wrap_1.helper)(owner).__meta.properties[prop];
        owner[prop] = coll;
        if (items) {
            coll.set(items);
        }
        return coll;
    }
    /**
     * Initializes the collection and returns the items
     */
    async loadItems(options) {
        if (!this.isInitialized(true)) {
            await this.init(options);
        }
        return super.getItems();
    }
    /**
     * Gets the count of collection items from database instead of counting loaded items.
     * The value is cached (unless you use the `where` option), use `refresh: true` to force reload it.
     */
    async loadCount(options = {}) {
        options = typeof options === 'boolean' ? { refresh: options } : options;
        if (!options.refresh && !options.where && Utils_1.Utils.isDefined(this._count)) {
            return this._count;
        }
        const em = this.getEntityManager();
        const pivotMeta = em.getMetadata().find(this.property.pivotEntity);
        if (!em.getPlatform().usesPivotTable() && this.property.reference === enums_1.ReferenceType.MANY_TO_MANY) {
            return this._count = this.length;
        }
        else if (this.property.pivotTable && !(this.property.inversedBy || this.property.mappedBy)) {
            const count = await em.count(this.property.type, this.createLoadCountCondition(options.where ?? {}, pivotMeta), { populate: [{ field: this.property.pivotEntity }] });
            if (!options.where) {
                this._count = count;
            }
            return count;
        }
        const count = await em.count(this.property.type, this.createLoadCountCondition(options.where ?? {}, pivotMeta));
        if (!options.where) {
            this._count = count;
        }
        return count;
    }
    async matching(options) {
        const em = this.getEntityManager();
        const { where, ctx, ...opts } = options;
        opts.orderBy = this.createOrderBy(opts.orderBy);
        let items;
        if (this.property.reference === enums_1.ReferenceType.MANY_TO_MANY && em.getPlatform().usesPivotTable()) {
            const cond = await em.applyFilters(this.property.type, where, options.filters ?? {}, 'read');
            const map = await em.getDriver().loadFromPivotTable(this.property, [(0, wrap_1.helper)(this.owner).__primaryKeys], cond, opts.orderBy, ctx, options);
            items = map[(0, wrap_1.helper)(this.owner).getSerializedPrimaryKey()].map((item) => em.merge(this.property.type, item, { convertCustomTypes: true }));
        }
        else {
            items = await em.find(this.property.type, this.createCondition(where), opts);
        }
        if (options.store) {
            this.hydrate(items, true);
            this.populated();
            this.readonly = true;
        }
        return items;
    }
    /**
     * Returns the items (the collection must be initialized)
     */
    getItems(check = true) {
        if (check) {
            this.checkInitialized();
        }
        return super.getItems();
    }
    toJSON() {
        if (!this.isInitialized()) {
            return [];
        }
        return super.toJSON();
    }
    add(entity, ...entities) {
        entities = Utils_1.Utils.asArray(entity).concat(entities);
        const unwrapped = entities.map(i => Reference_1.Reference.unwrapReference(i));
        unwrapped.forEach(entity => this.validateItemType(entity));
        this.modify('add', unwrapped);
        this.cancelOrphanRemoval(unwrapped);
    }
    set(items) {
        if (!this.initialized) {
            this.initialized = true;
            this.snapshot = undefined;
        }
        super.set(items);
    }
    /**
     * @internal
     */
    hydrate(items, forcePropagate) {
        this.initialized = true;
        super.hydrate(items);
        this.takeSnapshot(forcePropagate);
    }
    /**
     * @inheritDoc
     */
    remove(entity, ...entities) {
        if (entity instanceof Function) {
            for (const item of this.items) {
                if (entity(item)) {
                    this.remove(item);
                }
            }
            return;
        }
        entities = Utils_1.Utils.asArray(entity).concat(entities);
        const unwrapped = entities.map(i => Reference_1.Reference.unwrapReference(i));
        this.modify('remove', unwrapped);
        const em = this.getEntityManager(unwrapped, false);
        if (this.property.orphanRemoval && em) {
            for (const item of unwrapped) {
                em.getUnitOfWork().scheduleOrphanRemoval(item);
            }
        }
    }
    /**
     * @inheritDoc
     */
    removeAll() {
        this.checkInitialized();
        super.removeAll();
    }
    contains(item, check = true) {
        if (check) {
            this.checkInitialized();
        }
        return super.contains(item);
    }
    count() {
        this.checkInitialized();
        return super.count();
    }
    isEmpty() {
        this.checkInitialized();
        return super.isEmpty();
    }
    /**
     * @inheritDoc
     */
    slice(start, end) {
        this.checkInitialized();
        return super.slice(start, end);
    }
    /**
     * @inheritDoc
     */
    exists(cb) {
        this.checkInitialized();
        return super.exists(cb);
    }
    /**
     * @inheritDoc
     */
    find(cb) {
        this.checkInitialized();
        return super.find(cb);
    }
    /**
     * @inheritDoc
     */
    filter(cb) {
        this.checkInitialized();
        return super.filter(cb);
    }
    /**
     * @inheritDoc
     */
    map(mapper) {
        this.checkInitialized();
        return super.map(mapper);
    }
    /**
     * @inheritDoc
     */
    indexBy(key, valueKey) {
        this.checkInitialized();
        return super.indexBy(key, valueKey);
    }
    shouldPopulate() {
        return this._populated && !this._lazyInitialized;
    }
    populated(populated = true) {
        this._populated = populated;
        this._lazyInitialized = false;
    }
    async init(options = {}) {
        if (this.dirty) {
            const items = [...this.items];
            this.dirty = false;
            await this.init(options);
            items.forEach(i => this.add(i));
            return this;
        }
        const em = this.getEntityManager();
        if (!this.initialized && this.property.reference === enums_1.ReferenceType.MANY_TO_MANY && em.getPlatform().usesPivotTable()) {
            const cond = await em.applyFilters(this.property.type, options.where, {}, 'read');
            const map = await em.getDriver().loadFromPivotTable(this.property, [(0, wrap_1.helper)(this.owner).__primaryKeys], cond, options.orderBy, undefined, options);
            this.hydrate(map[(0, wrap_1.helper)(this.owner).getSerializedPrimaryKey()].map((item) => em.merge(this.property.type, item, { convertCustomTypes: true })), true);
            this._lazyInitialized = true;
            return this;
        }
        // do not make db call if we know we will get no results
        if (this.property.reference === enums_1.ReferenceType.MANY_TO_MANY && (this.property.owner || em.getPlatform().usesPivotTable()) && this.length === 0) {
            this.initialized = true;
            this.dirty = false;
            this._lazyInitialized = true;
            return this;
        }
        const where = this.createCondition(options.where);
        const order = [...this.items]; // copy order of references
        const customOrder = !!options.orderBy;
        const items = await em.find(this.property.type, where, {
            populate: options.populate,
            lockMode: options.lockMode,
            orderBy: this.createOrderBy(options.orderBy),
            connectionType: options.connectionType,
            schema: this.property.targetMeta.schema === '*'
                ? (0, wrap_1.helper)(this.owner).__schema
                : this.property.targetMeta.schema,
        });
        if (!customOrder) {
            this.reorderItems(items, order);
        }
        this.items.clear();
        let i = 0;
        items.forEach(item => {
            this.items.add(item);
            this[i++] = item;
        });
        this.initialized = true;
        this.dirty = false;
        this._lazyInitialized = true;
        return this;
    }
    /**
     * @internal
     */
    takeSnapshot(forcePropagate) {
        this.snapshot = [...this.items];
        this.setDirty(false);
        if (this.property.owner || forcePropagate) {
            this.items.forEach(item => {
                this.propagate(item, 'takeSnapshot');
            });
        }
    }
    /**
     * @internal
     */
    getSnapshot() {
        return this.snapshot;
    }
    getEntityManager(items = [], required = true) {
        let em = this._em ?? (0, wrap_1.helper)(this.owner).__em;
        if (!em) {
            for (const i of items) {
                if (i && (0, wrap_1.helper)(i).__em) {
                    em = (0, wrap_1.helper)(i).__em;
                    break;
                }
            }
        }
        if (em) {
            Object.defineProperty(this, '_em', { value: em });
        }
        if (!em && required) {
            throw errors_1.ValidationError.entityNotManaged(this.owner);
        }
        return em;
    }
    createCondition(cond = {}) {
        if (this.property.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            cond[this.property.mappedBy] = (0, wrap_1.helper)(this.owner).getPrimaryKey();
        }
        else { // MANY_TO_MANY
            this.createManyToManyCondition(cond);
        }
        return cond;
    }
    createOrderBy(orderBy = []) {
        if (Utils_1.Utils.isEmpty(orderBy) && this.property.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            const defaultOrder = this.property.referencedColumnNames.map(name => {
                return { [name]: enums_1.QueryOrder.ASC };
            });
            orderBy = this.property.orderBy || defaultOrder;
        }
        return Utils_1.Utils.asArray(orderBy);
    }
    createManyToManyCondition(cond) {
        if (this.property.owner || this.property.pivotTable) {
            // we know there is at least one item as it was checked in load method
            const pk = this.property.targetMeta.primaryKeys[0];
            cond[pk] = { $in: [] };
            this.items.forEach(item => cond[pk].$in.push((0, wrap_1.helper)(item).getPrimaryKey()));
        }
        else {
            cond[this.property.mappedBy] = (0, wrap_1.helper)(this.owner).getPrimaryKey();
        }
    }
    createLoadCountCondition(cond, pivotMeta) {
        const wrapped = (0, wrap_1.helper)(this.owner);
        const val = wrapped.__meta.compositePK ? { $in: wrapped.__primaryKeys } : wrapped.getPrimaryKey();
        if (this.property.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            cond[this.property.mappedBy] = val;
        }
        else if (pivotMeta && this.property.owner && !this.property.inversedBy) {
            const key = `${this.property.pivotEntity}.${pivotMeta.relations[0].name}`;
            cond[key] = val;
        }
        else {
            const key = this.property.owner ? this.property.inversedBy : this.property.mappedBy;
            cond[key] = val;
        }
        return cond;
    }
    modify(method, items) {
        if (method === 'remove') {
            this.checkInitialized();
        }
        this.validateModification(items);
        super[method](items);
        this.setDirty();
    }
    checkInitialized() {
        if (!this.isInitialized()) {
            throw new Error(`Collection<${this.property.type}> of entity ${this.owner.constructor.name}[${(0, wrap_1.helper)(this.owner).getSerializedPrimaryKey()}] not initialized`);
        }
    }
    /**
     * re-orders items after searching with `$in` operator
     */
    reorderItems(items, order) {
        if (this.property.reference === enums_1.ReferenceType.MANY_TO_MANY && this.property.owner) {
            items.sort((a, b) => order.indexOf(a) - order.indexOf(b));
        }
    }
    cancelOrphanRemoval(items) {
        const em = this.getEntityManager(items, false);
        if (!em) {
            return;
        }
        for (const item of items) {
            em.getUnitOfWork().cancelOrphanRemoval(item);
        }
    }
    validateItemType(item) {
        if (!Utils_1.Utils.isEntity(item)) {
            throw errors_1.ValidationError.notEntity(this.owner, this.property, item);
        }
    }
    validateModification(items) {
        if (this.readonly) {
            throw errors_1.ValidationError.cannotModifyReadonlyCollection(this.owner, this.property);
        }
        // currently we allow persisting to inverse sides only in SQL drivers
        if (this.property.pivotTable || !this.property.mappedBy) {
            return;
        }
        const check = (item) => {
            if (!item || (0, wrap_1.helper)(item).__initialized) {
                return false;
            }
            return !item[this.property.mappedBy] && this.property.reference === enums_1.ReferenceType.MANY_TO_MANY;
        };
        // throw if we are modifying inverse side of M:N collection when owning side is initialized (would be ignored when persisting)
        if (items.find(item => check(item))) {
            throw errors_1.ValidationError.cannotModifyInverseCollection(this.owner, this.property);
        }
    }
}
exports.Collection = Collection;
Object.defineProperties(Collection.prototype, {
    $: { get() { return this; } },
    get: { get() { return () => this; } },
});
