import { EntityMetadata, type AnyEntity, type Constructor, type DeepPartial, type Dictionary, type EntityName, type EntityProperty, type ExcludeFunctions, type ExpandProperty } from '../typings';
import type { EmbeddedOptions, EnumOptions, IndexOptions, ManyToManyOptions, ManyToOneOptions, OneToManyOptions, OneToOneOptions, PrimaryKeyOptions, PropertyOptions, SerializedPrimaryKeyOptions, UniqueOptions } from '../decorators';
import type { EntityRepository } from '../entity/EntityRepository';
import { ReferenceType } from '../enums';
import { Type } from '../types';
type TypeType = string | NumberConstructor | StringConstructor | BooleanConstructor | DateConstructor | ArrayConstructor | Constructor<Type<any>>;
type TypeDef<T> = {
    type: TypeType;
} | {
    customType: Type<any>;
} | {
    entity: string | (() => string | EntityName<T>);
};
export type EntitySchemaProperty<T, O> = ({
    reference: ReferenceType.MANY_TO_ONE | 'm:1';
} & TypeDef<T> & ManyToOneOptions<T, O>) | ({
    reference: ReferenceType.ONE_TO_ONE | '1:1';
} & TypeDef<T> & OneToOneOptions<T, O>) | ({
    reference: ReferenceType.ONE_TO_MANY | '1:m';
} & TypeDef<T> & OneToManyOptions<T, O>) | ({
    reference: ReferenceType.MANY_TO_MANY | 'm:n';
} & TypeDef<T> & ManyToManyOptions<T, O>) | ({
    reference: ReferenceType.EMBEDDED | 'embedded';
} & TypeDef<T> & EmbeddedOptions & PropertyOptions<O>) | ({
    enum: true;
} & EnumOptions<O>) | (TypeDef<T> & PropertyOptions<O>);
export type EntitySchemaMetadata<T, U> = Omit<Partial<EntityMetadata<T>>, 'name' | 'properties'> & ({
    name: string;
} | {
    class: Constructor<T>;
    name?: string;
}) & {
    properties?: {
        [K in keyof Omit<T, keyof U> as ExcludeFunctions<Omit<T, keyof U>, K>]-?: EntitySchemaProperty<ExpandProperty<NonNullable<T[K]>>, T>;
    };
};
export declare class EntitySchema<T = any, U = never> {
    private readonly _meta;
    private internal;
    private initialized;
    constructor(meta: EntitySchemaMetadata<T, U>);
    static fromMetadata<T = AnyEntity, U = never>(meta: EntityMetadata<T> | DeepPartial<EntityMetadata<T>>): EntitySchema<T, U>;
    addProperty(name: string & keyof T, type?: TypeType, options?: PropertyOptions<T> | EntityProperty): void;
    addEnum(name: string & keyof T, type?: TypeType, options?: EnumOptions<T>): void;
    addVersion(name: string & keyof T, type: TypeType, options?: PropertyOptions<T>): void;
    addPrimaryKey(name: string & keyof T, type: TypeType, options?: PrimaryKeyOptions<T>): void;
    addSerializedPrimaryKey(name: string & keyof T, type: TypeType, options?: SerializedPrimaryKeyOptions<T>): void;
    addEmbedded<K = AnyEntity>(name: string & keyof T, options: EmbeddedOptions): void;
    addManyToOne<K = AnyEntity>(name: string & keyof T, type: TypeType, options: ManyToOneOptions<K, T>): void;
    addManyToMany<K = AnyEntity>(name: string & keyof T, type: TypeType, options: ManyToManyOptions<K, T>): void;
    addOneToMany<K = AnyEntity>(name: string & keyof T, type: TypeType, options: OneToManyOptions<K, T>): void;
    addOneToOne<K = AnyEntity>(name: string & keyof T, type: TypeType, options: OneToOneOptions<K, T>): void;
    addIndex<T>(options: Required<Omit<IndexOptions<T>, 'name' | 'type' | 'options' | 'expression'>> & {
        name?: string;
        expression?: string;
        options?: Dictionary;
    }): void;
    addUnique<T>(options: Required<Omit<UniqueOptions<T>, 'name' | 'options' | 'expression'>> & {
        name?: string;
        options?: Dictionary;
    }): void;
    setCustomRepository(repository: () => Constructor<EntityRepository<any>>): void;
    setExtends(base: string): void;
    setClass(proto: Constructor<T>): void;
    get meta(): EntityMetadata<T>;
    get name(): EntityName<T>;
    /**
     * @internal
     */
    init(): this;
    private initProperties;
    private initPrimaryKeys;
    private normalizeType;
    private createProperty;
}
export {};
