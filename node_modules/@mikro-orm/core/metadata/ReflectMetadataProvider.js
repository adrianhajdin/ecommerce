"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReflectMetadataProvider = void 0;
require("reflect-metadata");
const MetadataProvider_1 = require("./MetadataProvider");
const enums_1 = require("../enums");
class ReflectMetadataProvider extends MetadataProvider_1.MetadataProvider {
    async loadEntityMetadata(meta, name) {
        await this.initProperties(meta, prop => this.initPropertyType(meta, prop));
    }
    initPropertyType(meta, prop) {
        let type = Reflect.getMetadata('design:type', meta.prototype, prop.name);
        if (!type || (type === Object && prop.reference !== enums_1.ReferenceType.SCALAR)) {
            throw new Error(`Please provide either 'type' or 'entity' attribute in ${meta.className}.${prop.name}. If you are using decorators, ensure you have 'emitDecoratorMetadata' enabled in your tsconfig.json.`);
        }
        // Instead of requiring the type everywhere, we default to string, which maintains the behaviour,
        // as we were mapping it to UnknownType which is a string. This is to prevent defaulting to JSON
        // column type, which can be often hard to revert and cause hard to understand issues with PKs.
        // If there are explicitly provided `columnTypes`, we use those instead for the inference, this way
        // we can have things like `columnType: 'timestamp'` be respected as `type: 'Date'`.
        if (prop.reference === enums_1.ReferenceType.SCALAR && type === Object && !prop.columnTypes) {
            type = String;
        }
        prop.type = type.name;
        if (prop.type && ['string', 'number', 'boolean', 'array', 'object'].includes(prop.type.toLowerCase())) {
            prop.type = prop.type.toLowerCase();
        }
    }
}
exports.ReflectMetadataProvider = ReflectMetadataProvider;
