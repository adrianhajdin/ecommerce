"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate";
exports.ids = ["vendor-chunks/slate"];
exports.modules = {

/***/ "(rsc)/./node_modules/slate/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/slate/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar immer = __webpack_require__(/*! immer */ \"(rsc)/./node_modules/immer/dist/index.js\");\nfunction unwrapExports(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction createCommonjsModule(fn, module) {\n    return module = {\n        exports: {}\n    }, fn(module, module.exports), module.exports;\n}\nvar arrayLikeToArray = createCommonjsModule(function(module) {\n    function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for(var i = 0, arr2 = new Array(len); i < len; i++){\n            arr2[i] = arr[i];\n        }\n        return arr2;\n    }\n    module.exports = _arrayLikeToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(arrayLikeToArray);\nvar arrayWithoutHoles = createCommonjsModule(function(module) {\n    function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) return arrayLikeToArray(arr);\n    }\n    module.exports = _arrayWithoutHoles;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(arrayWithoutHoles);\nvar iterableToArray = createCommonjsModule(function(module) {\n    function _iterableToArray(iter) {\n        if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n    }\n    module.exports = _iterableToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(iterableToArray);\nvar unsupportedIterableToArray = createCommonjsModule(function(module) {\n    function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n    }\n    module.exports = _unsupportedIterableToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(unsupportedIterableToArray);\nvar nonIterableSpread = createCommonjsModule(function(module) {\n    function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    module.exports = _nonIterableSpread;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(nonIterableSpread);\nvar toConsumableArray = createCommonjsModule(function(module) {\n    function _toConsumableArray(arr) {\n        return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n    }\n    module.exports = _toConsumableArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _toConsumableArray = unwrapExports(toConsumableArray);\nvar defineProperty = createCommonjsModule(function(module) {\n    function _defineProperty(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n            });\n        } else {\n            obj[key] = value;\n        }\n        return obj;\n    }\n    module.exports = _defineProperty;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _defineProperty = unwrapExports(defineProperty);\nvar arrayWithHoles = createCommonjsModule(function(module) {\n    function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n    }\n    module.exports = _arrayWithHoles;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(arrayWithHoles);\nvar iterableToArrayLimit = createCommonjsModule(function(module) {\n    function _iterableToArrayLimit(arr, i) {\n        var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n        if (_i == null) return;\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _s, _e;\n        try {\n            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                _arr.push(_s.value);\n                if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;\n            _e = err;\n        } finally{\n            try {\n                if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n    module.exports = _iterableToArrayLimit;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(iterableToArrayLimit);\nvar nonIterableRest = createCommonjsModule(function(module) {\n    function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    module.exports = _nonIterableRest;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(nonIterableRest);\nvar slicedToArray = createCommonjsModule(function(module) {\n    function _slicedToArray(arr, i) {\n        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n    }\n    module.exports = _slicedToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _slicedToArray = unwrapExports(slicedToArray);\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\nfunction ownKeys$9(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$9(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$9(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$9(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$7(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$7(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);\n}\nfunction _arrayLikeToArray$7(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */ var createEditor = function createEditor() {\n    var editor = {\n        children: [],\n        operations: [],\n        selection: null,\n        marks: null,\n        isInline: function isInline() {\n            return false;\n        },\n        isVoid: function isVoid() {\n            return false;\n        },\n        markableVoid: function markableVoid() {\n            return false;\n        },\n        onChange: function onChange() {},\n        apply: function apply(op) {\n            var _iterator = _createForOfIteratorHelper$7(Editor.pathRefs(editor)), _step;\n            try {\n                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                    var ref = _step.value;\n                    PathRef.transform(ref, op);\n                }\n            } catch (err) {\n                _iterator.e(err);\n            } finally{\n                _iterator.f();\n            }\n            var _iterator2 = _createForOfIteratorHelper$7(Editor.pointRefs(editor)), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var _ref = _step2.value;\n                    PointRef.transform(_ref, op);\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            var _iterator3 = _createForOfIteratorHelper$7(Editor.rangeRefs(editor)), _step3;\n            try {\n                for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                    var _ref2 = _step3.value;\n                    RangeRef.transform(_ref2, op);\n                }\n            } catch (err) {\n                _iterator3.e(err);\n            } finally{\n                _iterator3.f();\n            }\n            var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n            var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n            var dirtyPaths;\n            var dirtyPathKeys;\n            var add = function add(path) {\n                if (path) {\n                    var key = path.join(\",\");\n                    if (!dirtyPathKeys.has(key)) {\n                        dirtyPathKeys.add(key);\n                        dirtyPaths.push(path);\n                    }\n                }\n            };\n            if (Path.operationCanTransformPath(op)) {\n                dirtyPaths = [];\n                dirtyPathKeys = new Set();\n                var _iterator4 = _createForOfIteratorHelper$7(oldDirtyPaths), _step4;\n                try {\n                    for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                        var path = _step4.value;\n                        var newPath = Path.transform(path, op);\n                        add(newPath);\n                    }\n                } catch (err) {\n                    _iterator4.e(err);\n                } finally{\n                    _iterator4.f();\n                }\n            } else {\n                dirtyPaths = oldDirtyPaths;\n                dirtyPathKeys = oldDirtyPathKeys;\n            }\n            var newDirtyPaths = editor.getDirtyPaths(op);\n            var _iterator5 = _createForOfIteratorHelper$7(newDirtyPaths), _step5;\n            try {\n                for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                    var _path = _step5.value;\n                    add(_path);\n                }\n            } catch (err) {\n                _iterator5.e(err);\n            } finally{\n                _iterator5.f();\n            }\n            DIRTY_PATHS.set(editor, dirtyPaths);\n            DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n            Transforms.transform(editor, op);\n            editor.operations.push(op);\n            Editor.normalize(editor, {\n                operation: op\n            }); // Clear any formats applied to the cursor if the selection changes.\n            if (op.type === \"set_selection\") {\n                editor.marks = null;\n            }\n            if (!FLUSHING.get(editor)) {\n                FLUSHING.set(editor, true);\n                Promise.resolve().then(function() {\n                    FLUSHING.set(editor, false);\n                    editor.onChange({\n                        operation: op\n                    });\n                    editor.operations = [];\n                });\n            }\n        },\n        addMark: function addMark(key, value) {\n            var selection = editor.selection;\n            editor.markableVoid;\n            if (selection) {\n                var match = function match(node, path) {\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var _Editor$parent = Editor.parent(editor, path), _Editor$parent2 = _slicedToArray(_Editor$parent, 2), parentNode = _Editor$parent2[0];\n                    _Editor$parent2[1];\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var _Editor$node = Editor.node(editor, selection), _Editor$node2 = _slicedToArray(_Editor$node, 2), selectedNode = _Editor$node2[0], selectedPath = _Editor$node2[1];\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var _Editor$parent3 = Editor.parent(editor, selectedPath), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parentNode = _Editor$parent4[0];\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.setNodes(editor, _defineProperty({}, key, value), {\n                        match: match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, _defineProperty({}, key, value));\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        deleteBackward: function deleteBackward(unit) {\n            var selection = editor.selection;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms[\"delete\"](editor, {\n                    unit: unit,\n                    reverse: true\n                });\n            }\n        },\n        deleteForward: function deleteForward(unit) {\n            var selection = editor.selection;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms[\"delete\"](editor, {\n                    unit: unit\n                });\n            }\n        },\n        deleteFragment: function deleteFragment(direction) {\n            var selection = editor.selection;\n            if (selection && Range.isExpanded(selection)) {\n                Transforms[\"delete\"](editor, {\n                    reverse: direction === \"backward\"\n                });\n            }\n        },\n        getFragment: function getFragment() {\n            var selection = editor.selection;\n            if (selection) {\n                return Node.fragment(editor, selection);\n            }\n            return [];\n        },\n        insertBreak: function insertBreak() {\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertSoftBreak: function insertSoftBreak() {\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertFragment: function insertFragment(fragment) {\n            Transforms.insertFragment(editor, fragment);\n        },\n        insertNode: function insertNode(node) {\n            Transforms.insertNodes(editor, node);\n        },\n        insertText: function insertText(text) {\n            var selection = editor.selection, marks = editor.marks;\n            if (selection) {\n                if (marks) {\n                    var node = _objectSpread$9({\n                        text: text\n                    }, marks);\n                    Transforms.insertNodes(editor, node);\n                } else {\n                    Transforms.insertText(editor, text);\n                }\n                editor.marks = null;\n            }\n        },\n        normalizeNode: function normalizeNode(entry) {\n            var _entry = _slicedToArray(entry, 2), node = _entry[0], path = _entry[1]; // There are no core normalizations for text nodes.\n            if (Text.isText(node)) {\n                return;\n            } // Ensure that block and inline nodes have at least one text child.\n            if (Element.isElement(node) && node.children.length === 0) {\n                var child = {\n                    text: \"\"\n                };\n                Transforms.insertNodes(editor, child, {\n                    at: path.concat(0),\n                    voids: true\n                });\n                return;\n            } // Determine whether the node should have block or inline children.\n            var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n            // index that accounts for any added/removed nodes.\n            var n = 0;\n            for(var i = 0; i < node.children.length; i++, n++){\n                var currentNode = Node.get(editor, path);\n                if (Text.isText(currentNode)) continue;\n                var _child = node.children[i];\n                var prev = currentNode.children[n - 1];\n                var isLast = i === node.children.length - 1;\n                var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n                // that only contain block nodes. Similarly, only allow inline nodes in\n                // other inline nodes, or parent blocks that only contain inlines and\n                // text.\n                if (isInlineOrText !== shouldHaveInlines) {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                } else if (Element.isElement(_child)) {\n                    // Ensure that inline nodes are surrounded by text nodes.\n                    if (editor.isInline(_child)) {\n                        if (prev == null || !Text.isText(prev)) {\n                            var newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, newChild, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n++;\n                        } else if (isLast) {\n                            var _newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, _newChild, {\n                                at: path.concat(n + 1),\n                                voids: true\n                            });\n                            n++;\n                        }\n                    }\n                } else {\n                    // Merge adjacent text nodes that are empty or match.\n                    if (prev != null && Text.isText(prev)) {\n                        if (Text.equals(_child, prev, {\n                            loose: true\n                        })) {\n                            Transforms.mergeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        } else if (prev.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n - 1),\n                                voids: true\n                            });\n                            n--;\n                        } else if (_child.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        }\n                    }\n                }\n            }\n        },\n        removeMark: function removeMark(key) {\n            var selection = editor.selection;\n            if (selection) {\n                var match = function match(node, path) {\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var _Editor$parent5 = Editor.parent(editor, path), _Editor$parent6 = _slicedToArray(_Editor$parent5, 2), parentNode = _Editor$parent6[0];\n                    _Editor$parent6[1];\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var _Editor$node3 = Editor.node(editor, selection), _Editor$node4 = _slicedToArray(_Editor$node3, 2), selectedNode = _Editor$node4[0], selectedPath = _Editor$node4[1];\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var _Editor$parent7 = Editor.parent(editor, selectedPath), _Editor$parent8 = _slicedToArray(_Editor$parent7, 1), parentNode = _Editor$parent8[0];\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.unsetNodes(editor, key, {\n                        match: match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n                    delete marks[key];\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        /**\r\n     * Get the \"dirty\" paths generated from an operation.\r\n     */ getDirtyPaths: function getDirtyPaths(op) {\n            switch(op.type){\n                case \"insert_text\":\n                case \"remove_text\":\n                case \"set_node\":\n                    {\n                        var path = op.path;\n                        return Path.levels(path);\n                    }\n                case \"insert_node\":\n                    {\n                        var node = op.node, _path2 = op.path;\n                        var levels = Path.levels(_path2);\n                        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function(_ref3) {\n                            var _ref4 = _slicedToArray(_ref3, 2), p = _ref4[1];\n                            return _path2.concat(p);\n                        });\n                        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n                    }\n                case \"merge_node\":\n                    {\n                        var _path3 = op.path;\n                        var ancestors = Path.ancestors(_path3);\n                        var previousPath = Path.previous(_path3);\n                        return [].concat(_toConsumableArray(ancestors), [\n                            previousPath\n                        ]);\n                    }\n                case \"move_node\":\n                    {\n                        var _path4 = op.path, newPath = op.newPath;\n                        if (Path.equals(_path4, newPath)) {\n                            return [];\n                        }\n                        var oldAncestors = [];\n                        var newAncestors = [];\n                        var _iterator6 = _createForOfIteratorHelper$7(Path.ancestors(_path4)), _step6;\n                        try {\n                            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                                var ancestor = _step6.value;\n                                var p = Path.transform(ancestor, op);\n                                oldAncestors.push(p);\n                            }\n                        } catch (err) {\n                            _iterator6.e(err);\n                        } finally{\n                            _iterator6.f();\n                        }\n                        var _iterator7 = _createForOfIteratorHelper$7(Path.ancestors(newPath)), _step7;\n                        try {\n                            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){\n                                var _ancestor = _step7.value;\n                                var _p = Path.transform(_ancestor, op);\n                                newAncestors.push(_p);\n                            }\n                        } catch (err) {\n                            _iterator7.e(err);\n                        } finally{\n                            _iterator7.f();\n                        }\n                        var newParent = newAncestors[newAncestors.length - 1];\n                        var newIndex = newPath[newPath.length - 1];\n                        var resultPath = newParent.concat(newIndex);\n                        return [].concat(oldAncestors, newAncestors, [\n                            resultPath\n                        ]);\n                    }\n                case \"remove_node\":\n                    {\n                        var _path5 = op.path;\n                        var _ancestors = Path.ancestors(_path5);\n                        return _toConsumableArray(_ancestors);\n                    }\n                case \"split_node\":\n                    {\n                        var _path6 = op.path;\n                        var _levels = Path.levels(_path6);\n                        var nextPath = Path.next(_path6);\n                        return [].concat(_toConsumableArray(_levels), [\n                            nextPath\n                        ]);\n                    }\n                default:\n                    {\n                        return [];\n                    }\n            }\n        },\n        shouldNormalize: function shouldNormalize(_ref5) {\n            var iteration = _ref5.iteration, initialDirtyPathsLength = _ref5.initialDirtyPathsLength;\n            var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n            if (iteration > maxIterations) {\n                throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n            }\n            return true;\n        }\n    };\n    return editor;\n};\nvar objectWithoutPropertiesLoose = createCommonjsModule(function(module) {\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n        for(i = 0; i < sourceKeys.length; i++){\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n        return target;\n    }\n    module.exports = _objectWithoutPropertiesLoose;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(objectWithoutPropertiesLoose);\nvar objectWithoutProperties = createCommonjsModule(function(module) {\n    function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n        var target = objectWithoutPropertiesLoose(source, excluded);\n        var key, i;\n        if (Object.getOwnPropertySymbols) {\n            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n            for(i = 0; i < sourceSymbolKeys.length; i++){\n                key = sourceSymbolKeys[i];\n                if (excluded.indexOf(key) >= 0) continue;\n                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    module.exports = _objectWithoutProperties;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$6(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);\n}\nfunction _arrayLikeToArray$6(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */ var getCharacterDistance = function getCharacterDistance(str) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isLTR = !isRTL;\n    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n    var left = CodepointType.None;\n    var right = CodepointType.None;\n    var distance = 0; // Evaluation of these conditions are deferred.\n    var gb11 = null; // Is GB11 applicable?\n    var gb12Or13 = null; // Is GB12 or GB13 applicable?\n    var _iterator = _createForOfIteratorHelper$6(codepoints), _step;\n    try {\n        for(_iterator.s(); !(_step = _iterator.n()).done;){\n            var _char = _step.value;\n            var code = _char.codePointAt(0);\n            if (!code) break;\n            var type = getCodepointType(_char, code);\n            var _ref = isLTR ? [\n                right,\n                type\n            ] : [\n                type,\n                left\n            ];\n            var _ref2 = _slicedToArray(_ref, 2);\n            left = _ref2[0];\n            right = _ref2[1];\n            if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n                if (isLTR) {\n                    gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n                } else {\n                    gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n                }\n                if (!gb11) break;\n            }\n            if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n                if (gb12Or13 !== null) {\n                    gb12Or13 = !gb12Or13;\n                } else {\n                    if (isLTR) {\n                        gb12Or13 = true;\n                    } else {\n                        gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n                    }\n                }\n                if (!gb12Or13) break;\n            }\n            if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n                break;\n            }\n            distance += _char.length;\n        }\n    } catch (err) {\n        _iterator.e(err);\n    } finally{\n        _iterator.f();\n    }\n    return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */ var getWordDistance = function getWordDistance(text) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var dist = 0;\n    var started = false;\n    while(text.length > 0){\n        var charDist = getCharacterDistance(text, isRTL);\n        var _splitByCharacterDist = splitByCharacterDistance(text, charDist, isRTL), _splitByCharacterDist2 = _slicedToArray(_splitByCharacterDist, 2), _char2 = _splitByCharacterDist2[0], remaining = _splitByCharacterDist2[1];\n        if (isWordCharacter(_char2, remaining, isRTL)) {\n            started = true;\n            dist += charDist;\n        } else if (!started) {\n            dist += charDist;\n        } else {\n            break;\n        }\n        text = remaining;\n    }\n    return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */ var splitByCharacterDistance = function splitByCharacterDistance(str, dist, isRTL) {\n    if (isRTL) {\n        var at = str.length - dist;\n        return [\n            str.slice(at, str.length),\n            str.slice(0, at)\n        ];\n    }\n    return [\n        str.slice(0, dist),\n        str.slice(dist)\n    ];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */ var isWordCharacter = function isWordCharacter(_char3, remaining) {\n    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (SPACE.test(_char3)) {\n        return false;\n    } // Chameleons count as word characters as long as they're in a word, so\n    // recurse to see if the next one is a word character or not.\n    if (CHAMELEON.test(_char3)) {\n        var charDist = getCharacterDistance(remaining, isRTL);\n        var _splitByCharacterDist3 = splitByCharacterDistance(remaining, charDist, isRTL), _splitByCharacterDist4 = _slicedToArray(_splitByCharacterDist3, 2), nextChar = _splitByCharacterDist4[0], nextRemaining = _splitByCharacterDist4[1];\n        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n            return true;\n        }\n    }\n    if (PUNCTUATION.test(_char3)) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n    var end = str.length - 1;\n    for(var i = 0; i < str.length; i++){\n        var char1 = str.charAt(end - i);\n        if (isLowSurrogate(char1.charCodeAt(0))) {\n            var char2 = str.charAt(end - i - 1);\n            if (isHighSurrogate(char2.charCodeAt(0))) {\n                yield char2 + char1;\n                i++;\n                continue;\n            }\n        }\n        yield char1;\n    }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isHighSurrogate = function isHighSurrogate(charCode) {\n    return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isLowSurrogate = function isLowSurrogate(charCode) {\n    return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function(CodepointType) {\n    CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n    CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n    CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n    CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n    CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n    CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n    CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n    CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n    CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n    CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n    CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n    CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n    CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = function getCodepointType(_char4, code) {\n    var type = CodepointType.Any;\n    if (_char4.search(reExtend) !== -1) {\n        type |= CodepointType.Extend;\n    }\n    if (code === 0x200d) {\n        type |= CodepointType.ZWJ;\n    }\n    if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n        type |= CodepointType.RI;\n    }\n    if (_char4.search(rePrepend) !== -1) {\n        type |= CodepointType.Prepend;\n    }\n    if (_char4.search(reSpacingMark) !== -1) {\n        type |= CodepointType.SpacingMark;\n    }\n    if (_char4.search(reL) !== -1) {\n        type |= CodepointType.L;\n    }\n    if (_char4.search(reV) !== -1) {\n        type |= CodepointType.V;\n    }\n    if (_char4.search(reT) !== -1) {\n        type |= CodepointType.T;\n    }\n    if (_char4.search(reLV) !== -1) {\n        type |= CodepointType.LV;\n    }\n    if (_char4.search(reLVT) !== -1) {\n        type |= CodepointType.LVT;\n    }\n    if (_char4.search(reExtPict) !== -1) {\n        type |= CodepointType.ExtPict;\n    }\n    return type;\n};\nfunction intersects(x, y) {\n    return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n    [\n        CodepointType.L,\n        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT\n    ],\n    [\n        CodepointType.LV | CodepointType.V,\n        CodepointType.V | CodepointType.T\n    ],\n    [\n        CodepointType.LVT | CodepointType.T,\n        CodepointType.T\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.Extend | CodepointType.ZWJ\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.SpacingMark\n    ],\n    [\n        CodepointType.Prepend,\n        CodepointType.Any\n    ],\n    [\n        CodepointType.ZWJ,\n        CodepointType.ExtPict\n    ],\n    [\n        CodepointType.RI,\n        CodepointType.RI\n    ]\n];\nfunction isBoundaryPair(left, right) {\n    return NonBoundaryPairs.findIndex(function(r) {\n        return intersects(left, r[0]) && intersects(right, r[1]);\n    }) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = function endsWithEmojiZWJ(str) {\n    return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = function endsWithOddNumberOfRIs(str) {\n    var match = str.match(endingRIs);\n    if (match === null) {\n        return false;\n    } else {\n        // A RI is represented by a surrogate pair.\n        var numRIs = match[0].length / 2;\n        return numRIs % 2 === 1;\n    }\n};\n/**\r\n * Shared the function with isElementType utility\r\n */ var isElement = function isElement(value) {\n    return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\nvar Element = {\n    /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */ isAncestor: function isAncestor(value) {\n        return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children);\n    },\n    /**\r\n   * Check if a value implements the `Element` interface.\r\n   */ isElement: isElement,\n    /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */ isElementList: function isElementList(value) {\n        return Array.isArray(value) && value.every(function(val) {\n            return Element.isElement(val);\n        });\n    },\n    /**\r\n   * Check if a set of props is a partial of Element.\r\n   */ isElementProps: function isElementProps(props) {\n        return props.children !== undefined;\n    },\n    /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */ isElementType: function isElementType(value, elementVal) {\n        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"type\";\n        return isElement(value) && value[elementKey] === elementVal;\n    },\n    /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */ matches: function matches(element, props) {\n        for(var key in props){\n            if (key === \"children\") {\n                continue;\n            }\n            if (element[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nvar _excluded$4 = [\n    \"text\"\n], _excluded2$3 = [\n    \"text\"\n];\nfunction ownKeys$8(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$8(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$8(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$8(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$5(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);\n}\nfunction _arrayLikeToArray$5(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Editor = {\n    /**\r\n   * Get the ancestor above a location in the document.\r\n   */ above: function above(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids, _options$mode = options.mode, mode = _options$mode === void 0 ? \"lowest\" : _options$mode, _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, match = options.match;\n        if (!at) {\n            return;\n        }\n        var path = Editor.path(editor, at);\n        var reverse = mode === \"lowest\";\n        var _iterator = _createForOfIteratorHelper$5(Editor.levels(editor, {\n            at: path,\n            voids: voids,\n            match: match,\n            reverse: reverse\n        })), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var _step$value = _slicedToArray(_step.value, 2), n = _step$value[0], p = _step$value[1];\n                if (Text.isText(n)) continue;\n                if (Range.isRange(at)) {\n                    if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n                        return [\n                            n,\n                            p\n                        ];\n                    }\n                } else {\n                    if (!Path.equals(path, p)) {\n                        return [\n                            n,\n                            p\n                        ];\n                    }\n                }\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n    },\n    /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */ addMark: function addMark(editor, key, value) {\n        editor.addMark(key, value);\n    },\n    /**\r\n   * Get the point after a location.\r\n   */ after: function after(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.point(editor, at, {\n            edge: \"end\"\n        });\n        var focus = Editor.end(editor, []);\n        var range = {\n            anchor: anchor,\n            focus: focus\n        };\n        var _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance;\n        var d = 0;\n        var target;\n        var _iterator2 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range\n        }))), _step2;\n        try {\n            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                var p = _step2.value;\n                if (d > distance) {\n                    break;\n                }\n                if (d !== 0) {\n                    target = p;\n                }\n                d++;\n            }\n        } catch (err) {\n            _iterator2.e(err);\n        } finally{\n            _iterator2.f();\n        }\n        return target;\n    },\n    /**\r\n   * Get the point before a location.\r\n   */ before: function before(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.start(editor, []);\n        var focus = Editor.point(editor, at, {\n            edge: \"start\"\n        });\n        var range = {\n            anchor: anchor,\n            focus: focus\n        };\n        var _options$distance2 = options.distance, distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n        var d = 0;\n        var target;\n        var _iterator3 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range,\n            reverse: true\n        }))), _step3;\n        try {\n            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                var p = _step3.value;\n                if (d > distance) {\n                    break;\n                }\n                if (d !== 0) {\n                    target = p;\n                }\n                d++;\n            }\n        } catch (err) {\n            _iterator3.e(err);\n        } finally{\n            _iterator3.f();\n        }\n        return target;\n    },\n    /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */ deleteBackward: function deleteBackward(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$unit = options.unit, unit = _options$unit === void 0 ? \"character\" : _options$unit;\n        editor.deleteBackward(unit);\n    },\n    /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */ deleteForward: function deleteForward(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$unit2 = options.unit, unit = _options$unit2 === void 0 ? \"character\" : _options$unit2;\n        editor.deleteForward(unit);\n    },\n    /**\r\n   * Delete the content in the current selection.\r\n   */ deleteFragment: function deleteFragment(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$direction = options.direction, direction = _options$direction === void 0 ? \"forward\" : _options$direction;\n        editor.deleteFragment(direction);\n    },\n    /**\r\n   * Get the start and end points of a location.\r\n   */ edges: function edges(editor, at) {\n        return [\n            Editor.start(editor, at),\n            Editor.end(editor, at)\n        ];\n    },\n    /**\r\n   * Get the end point of a location.\r\n   */ end: function end(editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"end\"\n        });\n    },\n    /**\r\n   * Get the first node at a location.\r\n   */ first: function first(editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"start\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the fragment at a location.\r\n   */ fragment: function fragment(editor, at) {\n        var range = Editor.range(editor, at);\n        var fragment = Node.fragment(editor, range);\n        return fragment;\n    },\n    /**\r\n   * Check if a node has block children.\r\n   */ hasBlocks: function hasBlocks(editor, element) {\n        return element.children.some(function(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n        });\n    },\n    /**\r\n   * Check if a node has inline and text children.\r\n   */ hasInlines: function hasInlines(editor, element) {\n        return element.children.some(function(n) {\n            return Text.isText(n) || Editor.isInline(editor, n);\n        });\n    },\n    /**\r\n   * Check if a node has text children.\r\n   */ hasTexts: function hasTexts(editor, element) {\n        return element.children.every(function(n) {\n            return Text.isText(n);\n        });\n    },\n    /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertBreak: function insertBreak(editor) {\n        editor.insertBreak();\n    },\n    /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertSoftBreak: function insertSoftBreak(editor) {\n        editor.insertSoftBreak();\n    },\n    /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertFragment: function insertFragment(editor, fragment) {\n        editor.insertFragment(fragment);\n    },\n    /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertNode: function insertNode(editor, node) {\n        editor.insertNode(node);\n    },\n    /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertText: function insertText(editor, text) {\n        editor.insertText(text);\n    },\n    /**\r\n   * Check if a value is a block `Element` object.\r\n   */ isBlock: function isBlock(editor, value) {\n        return !editor.isInline(value);\n    },\n    /**\r\n   * Check if a value is an `Editor` object.\r\n   */ isEditor: function isEditor(value) {\n        var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n        if (cachedIsEditor !== undefined) {\n            return cachedIsEditor;\n        }\n        if (!isPlainObject.isPlainObject(value)) {\n            return false;\n        }\n        var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteBackward === \"function\" && typeof value.deleteForward === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isInline === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && typeof value.getDirtyPaths === \"function\" && (value.marks === null || isPlainObject.isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n        IS_EDITOR_CACHE.set(value, isEditor);\n        return isEditor;\n    },\n    /**\r\n   * Check if a point is the end point of a location.\r\n   */ isEnd: function isEnd(editor, point, at) {\n        var end = Editor.end(editor, at);\n        return Point.equals(point, end);\n    },\n    /**\r\n   * Check if a point is an edge of a location.\r\n   */ isEdge: function isEdge(editor, point, at) {\n        return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n    },\n    /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */ isEmpty: function isEmpty(editor, element) {\n        var children = element.children;\n        var _children = _slicedToArray(children, 1), first = _children[0];\n        return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element);\n    },\n    /**\r\n   * Check if a value is an inline `Element` object.\r\n   */ isInline: function isInline(editor, value) {\n        return editor.isInline(value);\n    },\n    /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */ isNormalizing: function isNormalizing(editor) {\n        var isNormalizing = NORMALIZING.get(editor);\n        return isNormalizing === undefined ? true : isNormalizing;\n    },\n    /**\r\n   * Check if a point is the start point of a location.\r\n   */ isStart: function isStart(editor, point, at) {\n        // PERF: If the offset isn't `0` we know it's not the start.\n        if (point.offset !== 0) {\n            return false;\n        }\n        var start = Editor.start(editor, at);\n        return Point.equals(point, start);\n    },\n    /**\r\n   * Check if a value is a void `Element` object.\r\n   */ isVoid: function isVoid(editor, value) {\n        return editor.isVoid(value);\n    },\n    /**\r\n   * Get the last node at a location.\r\n   */ last: function last(editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"end\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the leaf text node at a location.\r\n   */ leaf: function leaf(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.leaf(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the levels at a location.\r\n   */ levels: function* levels(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n        var match = options.match;\n        if (match == null) {\n            match = function match() {\n                return true;\n            };\n        }\n        if (!at) {\n            return;\n        }\n        var levels = [];\n        var path = Editor.path(editor, at);\n        var _iterator4 = _createForOfIteratorHelper$5(Node.levels(editor, path)), _step4;\n        try {\n            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                var _step4$value = _slicedToArray(_step4.value, 2), n = _step4$value[0], p = _step4$value[1];\n                if (!match(n, p)) {\n                    continue;\n                }\n                levels.push([\n                    n,\n                    p\n                ]);\n                if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n                    break;\n                }\n            }\n        } catch (err) {\n            _iterator4.e(err);\n        } finally{\n            _iterator4.f();\n        }\n        if (reverse) {\n            levels.reverse();\n        }\n        yield* levels;\n    },\n    /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */ marks: function marks(editor) {\n        var marks = editor.marks, selection = editor.selection;\n        if (!selection) {\n            return null;\n        }\n        if (marks) {\n            return marks;\n        }\n        if (Range.isExpanded(selection)) {\n            var _Editor$nodes = Editor.nodes(editor, {\n                match: Text.isText\n            }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), match = _Editor$nodes2[0];\n            if (match) {\n                var _match = _slicedToArray(match, 1), _node = _match[0];\n                _node.text;\n                var _rest = _objectWithoutProperties(_node, _excluded$4);\n                return _rest;\n            } else {\n                return {};\n            }\n        }\n        var anchor = selection.anchor;\n        var path = anchor.path;\n        var _Editor$leaf = Editor.leaf(editor, path), _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1), node = _Editor$leaf2[0];\n        if (anchor.offset === 0) {\n            var prev = Editor.previous(editor, {\n                at: path,\n                match: Text.isText\n            });\n            var markedVoid = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n);\n                }\n            });\n            if (!markedVoid) {\n                var block = Editor.above(editor, {\n                    match: function match(n) {\n                        return Element.isElement(n) && Editor.isBlock(editor, n);\n                    }\n                });\n                if (prev && block) {\n                    var _prev = _slicedToArray(prev, 2), prevNode = _prev[0], prevPath = _prev[1];\n                    var _block = _slicedToArray(block, 2), blockPath = _block[1];\n                    if (Path.isAncestor(blockPath, prevPath)) {\n                        node = prevNode;\n                    }\n                }\n            }\n        }\n        var _node2 = node;\n        _node2.text;\n        var rest = _objectWithoutProperties(_node2, _excluded2$3);\n        return rest;\n    },\n    /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */ next: function next(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$mode2 = options.mode, mode = _options$mode2 === void 0 ? \"lowest\" : _options$mode2, _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3;\n        var match = options.match, _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3;\n        if (!at) {\n            return;\n        }\n        var pointAfterLocation = Editor.after(editor, at, {\n            voids: voids\n        });\n        if (!pointAfterLocation) return;\n        var _Editor$last = Editor.last(editor, []), _Editor$last2 = _slicedToArray(_Editor$last, 2), to = _Editor$last2[1];\n        var span = [\n            pointAfterLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the next node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var _Editor$parent = Editor.parent(editor, at), _Editor$parent2 = _slicedToArray(_Editor$parent, 1), parent = _Editor$parent2[0];\n                match = function match(n) {\n                    return parent.children.includes(n);\n                };\n            } else {\n                match = function match() {\n                    return true;\n                };\n            }\n        }\n        var _Editor$nodes3 = Editor.nodes(editor, {\n            at: span,\n            match: match,\n            mode: mode,\n            voids: voids\n        }), _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1), next = _Editor$nodes4[0];\n        return next;\n    },\n    /**\r\n   * Get the node at a location.\r\n   */ node: function node(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.get(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */ nodes: function* nodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? \"all\" : _options$mode3, _options$universal = options.universal, universal = _options$universal === void 0 ? false : _options$universal, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;\n        var match = options.match;\n        if (!match) {\n            match = function match() {\n                return true;\n            };\n        }\n        if (!at) {\n            return;\n        }\n        var from;\n        var to;\n        if (Span.isSpan(at)) {\n            from = at[0];\n            to = at[1];\n        } else {\n            var first = Editor.path(editor, at, {\n                edge: \"start\"\n            });\n            var last = Editor.path(editor, at, {\n                edge: \"end\"\n            });\n            from = reverse ? last : first;\n            to = reverse ? first : last;\n        }\n        var nodeEntries = Node.nodes(editor, {\n            reverse: reverse,\n            from: from,\n            to: to,\n            pass: function pass(_ref) {\n                var _ref2 = _slicedToArray(_ref, 1), n = _ref2[0];\n                return voids ? false : Element.isElement(n) && Editor.isVoid(editor, n);\n            }\n        });\n        var matches = [];\n        var hit;\n        var _iterator5 = _createForOfIteratorHelper$5(nodeEntries), _step5;\n        try {\n            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                var _step5$value = _slicedToArray(_step5.value, 2), node = _step5$value[0], path = _step5$value[1];\n                var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n                if (mode === \"highest\" && isLower) {\n                    continue;\n                }\n                if (!match(node, path)) {\n                    // If we've arrived at a leaf text node that is not lower than the last\n                    // hit, then we've found a branch that doesn't include a match, which\n                    // means the match is not universal.\n                    if (universal && !isLower && Text.isText(node)) {\n                        return;\n                    } else {\n                        continue;\n                    }\n                } // If there's a match and it's lower than the last, update the hit.\n                if (mode === \"lowest\" && isLower) {\n                    hit = [\n                        node,\n                        path\n                    ];\n                    continue;\n                } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n                var emit = mode === \"lowest\" ? hit : [\n                    node,\n                    path\n                ];\n                if (emit) {\n                    if (universal) {\n                        matches.push(emit);\n                    } else {\n                        yield emit;\n                    }\n                }\n                hit = [\n                    node,\n                    path\n                ];\n            } // Since lowest is always emitting one behind, catch up at the end.\n        } catch (err) {\n            _iterator5.e(err);\n        } finally{\n            _iterator5.f();\n        }\n        if (mode === \"lowest\" && hit) {\n            if (universal) {\n                matches.push(hit);\n            } else {\n                yield hit;\n            }\n        } // Universal defers to ensure that the match occurs in every branch, so we\n        // yield all of the matches after iterating.\n        if (universal) {\n            yield* matches;\n        }\n    },\n    /**\r\n   * Normalize any dirty objects in the editor.\r\n   */ normalize: function normalize(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$force = options.force, force = _options$force === void 0 ? false : _options$force, operation = options.operation;\n        var getDirtyPaths = function getDirtyPaths(editor) {\n            return DIRTY_PATHS.get(editor) || [];\n        };\n        var getDirtyPathKeys = function getDirtyPathKeys(editor) {\n            return DIRTY_PATH_KEYS.get(editor) || new Set();\n        };\n        var popDirtyPath = function popDirtyPath(editor) {\n            var path = getDirtyPaths(editor).pop();\n            var key = path.join(\",\");\n            getDirtyPathKeys(editor)[\"delete\"](key);\n            return path;\n        };\n        if (!Editor.isNormalizing(editor)) {\n            return;\n        }\n        if (force) {\n            var allPaths = Array.from(Node.nodes(editor), function(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2), p = _ref4[1];\n                return p;\n            });\n            var allPathKeys = new Set(allPaths.map(function(p) {\n                return p.join(\",\");\n            }));\n            DIRTY_PATHS.set(editor, allPaths);\n            DIRTY_PATH_KEYS.set(editor, allPathKeys);\n        }\n        if (getDirtyPaths(editor).length === 0) {\n            return;\n        }\n        Editor.withoutNormalizing(editor, function() {\n            /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */ var _iterator6 = _createForOfIteratorHelper$5(getDirtyPaths(editor)), _step6;\n            try {\n                for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                    var _dirtyPath = _step6.value;\n                    if (Node.has(editor, _dirtyPath)) {\n                        var _entry = Editor.node(editor, _dirtyPath);\n                        var _entry2 = _slicedToArray(_entry, 2), node = _entry2[0], _ = _entry2[1];\n                        /*\r\n              The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n              So there is some risk here.\r\n                         As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n              by definition adding children to an empty node can't cause other paths to change.\r\n            */ if (Element.isElement(node) && node.children.length === 0) {\n                            editor.normalizeNode(_entry, {\n                                operation: operation\n                            });\n                        }\n                    }\n                }\n            } catch (err) {\n                _iterator6.e(err);\n            } finally{\n                _iterator6.f();\n            }\n            var dirtyPaths = getDirtyPaths(editor);\n            var initialDirtyPathsLength = dirtyPaths.length;\n            var iteration = 0;\n            while(dirtyPaths.length !== 0){\n                if (!editor.shouldNormalize({\n                    dirtyPaths: dirtyPaths,\n                    iteration: iteration,\n                    initialDirtyPathsLength: initialDirtyPathsLength,\n                    operation: operation\n                })) {\n                    return;\n                }\n                var dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n                if (Node.has(editor, dirtyPath)) {\n                    var entry = Editor.node(editor, dirtyPath);\n                    editor.normalizeNode(entry, {\n                        operation: operation\n                    });\n                }\n                iteration++;\n                dirtyPaths = getDirtyPaths(editor);\n            }\n        });\n    },\n    /**\r\n   * Get the parent node of a location.\r\n   */ parent: function parent(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var parentPath = Path.parent(path);\n        var entry = Editor.node(editor, parentPath);\n        return entry;\n    },\n    /**\r\n   * Get the path of a location.\r\n   */ path: function path(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var depth = options.depth, edge = options.edge;\n        if (Path.isPath(at)) {\n            if (edge === \"start\") {\n                var _Node$first = Node.first(editor, at), _Node$first2 = _slicedToArray(_Node$first, 2), firstPath = _Node$first2[1];\n                at = firstPath;\n            } else if (edge === \"end\") {\n                var _Node$last = Node.last(editor, at), _Node$last2 = _slicedToArray(_Node$last, 2), lastPath = _Node$last2[1];\n                at = lastPath;\n            }\n        }\n        if (Range.isRange(at)) {\n            if (edge === \"start\") {\n                at = Range.start(at);\n            } else if (edge === \"end\") {\n                at = Range.end(at);\n            } else {\n                at = Path.common(at.anchor.path, at.focus.path);\n            }\n        }\n        if (Point.isPoint(at)) {\n            at = at.path;\n        }\n        if (depth != null) {\n            at = at.slice(0, depth);\n        }\n        return at;\n    },\n    hasPath: function hasPath(editor, path) {\n        return Node.has(editor, path);\n    },\n    /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pathRef: function pathRef(editor, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"forward\" : _options$affinity;\n        var ref = {\n            current: path,\n            affinity: affinity,\n            unref: function unref() {\n                var current = ref.current;\n                var pathRefs = Editor.pathRefs(editor);\n                pathRefs[\"delete\"](ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pathRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */ pathRefs: function pathRefs(editor) {\n        var refs = PATH_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            PATH_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Get the start or end point of a location.\r\n   */ point: function point(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$edge = options.edge, edge = _options$edge === void 0 ? \"start\" : _options$edge;\n        if (Path.isPath(at)) {\n            var path;\n            if (edge === \"end\") {\n                var _Node$last3 = Node.last(editor, at), _Node$last4 = _slicedToArray(_Node$last3, 2), lastPath = _Node$last4[1];\n                path = lastPath;\n            } else {\n                var _Node$first3 = Node.first(editor, at), _Node$first4 = _slicedToArray(_Node$first3, 2), firstPath = _Node$first4[1];\n                path = firstPath;\n            }\n            var node = Node.get(editor, path);\n            if (!Text.isText(node)) {\n                throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n            }\n            return {\n                path: path,\n                offset: edge === \"end\" ? node.text.length : 0\n            };\n        }\n        if (Range.isRange(at)) {\n            var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];\n            return edge === \"start\" ? start : end;\n        }\n        return at;\n    },\n    /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pointRef: function pointRef(editor, point) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$affinity2 = options.affinity, affinity = _options$affinity2 === void 0 ? \"forward\" : _options$affinity2;\n        var ref = {\n            current: point,\n            affinity: affinity,\n            unref: function unref() {\n                var current = ref.current;\n                var pointRefs = Editor.pointRefs(editor);\n                pointRefs[\"delete\"](ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pointRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */ pointRefs: function pointRefs(editor) {\n        var refs = POINT_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            POINT_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */ positions: function* positions(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, _options$unit3 = options.unit, unit = _options$unit3 === void 0 ? \"offset\" : _options$unit3, _options$reverse3 = options.reverse, reverse = _options$reverse3 === void 0 ? false : _options$reverse3, _options$voids5 = options.voids, voids = _options$voids5 === void 0 ? false : _options$voids5;\n        if (!at) {\n            return;\n        }\n        /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */ var range = Editor.range(editor, at);\n        var _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n        var first = reverse ? end : start;\n        var isNewBlock = false;\n        var blockText = \"\";\n        var distance = 0; // Distance for leafText to catch up to blockText.\n        var leafTextRemaining = 0;\n        var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n        // of block nodes in blockText, and text nodes in leafText.\n        // Exploits the fact that nodes are sequenced in such a way that we first\n        // encounter the block node, then all of its text nodes, so when iterating\n        // through the blockText and leafText we just need to remember a window of\n        // one block node and leaf node, respectively.\n        var _iterator7 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n            at: at,\n            reverse: reverse,\n            voids: voids\n        })), _step7;\n        try {\n            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){\n                var _step7$value = _slicedToArray(_step7.value, 2), node = _step7$value[0], path = _step7$value[1];\n                /*\r\n         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n         */ if (Element.isElement(node)) {\n                    // Void nodes are a special case, so by default we will always\n                    // yield their first point. If the `voids` option is set to true,\n                    // then we will iterate over their content.\n                    if (!voids && editor.isVoid(node)) {\n                        yield Editor.start(editor, path);\n                        continue;\n                    } // Inline element nodes are ignored as they don't themselves\n                    // contribute to `blockText` or `leafText` - their parent and\n                    // children do.\n                    if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n                    if (Editor.hasInlines(editor, node)) {\n                        // We always exhaust block nodes before encountering a new one:\n                        //   console.assert(blockText === '',\n                        //     `blockText='${blockText}' - `+\n                        //     `not exhausted before new block node`, path)\n                        // Ensure range considered is capped to `range`, in the\n                        // start/end edge cases where block extends beyond range.\n                        // Equivalent to this, but presumably more performant:\n                        //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n                        //   blockRange = Range.intersection(range, blockRange) // intersect\n                        //   blockText = Editor.string(editor, blockRange, { voids })\n                        var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n                        var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n                        blockText = Editor.string(editor, {\n                            anchor: s,\n                            focus: e\n                        }, {\n                            voids: voids\n                        });\n                        isNewBlock = true;\n                    }\n                }\n                /*\r\n         * TEXT LEAF NODE - Iterate through text content, yielding\r\n         * positions every `distance` offset according to `unit`.\r\n         */ if (Text.isText(node)) {\n                    var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n                    //   console.assert(leafTextRemaining <= 0,\n                    //     `leafTextRemaining=${leafTextRemaining} - `+\n                    //     `not exhausted before new leaf text node`, path)\n                    // Reset `leafText` counters for new text node.\n                    if (isFirst) {\n                        leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n                        leafTextOffset = first.offset; // Works for reverse too.\n                    } else {\n                        leafTextRemaining = node.text.length;\n                        leafTextOffset = reverse ? leafTextRemaining : 0;\n                    } // Yield position at the start of node (potentially).\n                    if (isFirst || isNewBlock || unit === \"offset\") {\n                        yield {\n                            path: path,\n                            offset: leafTextOffset\n                        };\n                        isNewBlock = false;\n                    } // Yield positions every (dynamically calculated) `distance` offset.\n                    while(true){\n                        // If `leafText` has caught up with `blockText` (distance=0),\n                        // and if blockText is exhausted, break to get another block node,\n                        // otherwise advance blockText forward by the new `distance`.\n                        if (distance === 0) {\n                            if (blockText === \"\") break;\n                            distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n                            // remaining string for the next iteration.\n                            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n                        } // Advance `leafText` by the current `distance`.\n                        leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n                        leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n                        // and set distance to the overflow amount, so we'll (maybe)\n                        // catch up to blockText in the next leaf text node.\n                        if (leafTextRemaining < 0) {\n                            distance = -leafTextRemaining;\n                            break;\n                        } // Successfully walked `distance` offsets through `leafText`\n                        // to catch up with `blockText`, so we can reset `distance`\n                        // and yield this position in this node.\n                        distance = 0;\n                        yield {\n                            path: path,\n                            offset: leafTextOffset\n                        };\n                    }\n                }\n            } // Proof that upon completion, we've exahusted both leaf and block text:\n        //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n        //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n        // Helper:\n        // Return the distance in offsets for a step of size `unit` on given string.\n        } catch (err) {\n            _iterator7.e(err);\n        } finally{\n            _iterator7.f();\n        }\n        function calcDistance(text, unit, reverse) {\n            if (unit === \"character\") {\n                return getCharacterDistance(text, reverse);\n            } else if (unit === \"word\") {\n                return getWordDistance(text, reverse);\n            } else if (unit === \"line\" || unit === \"block\") {\n                return text.length;\n            }\n            return 1;\n        }\n    },\n    /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */ previous: function previous(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$mode4 = options.mode, mode = _options$mode4 === void 0 ? \"lowest\" : _options$mode4, _options$voids6 = options.voids, voids = _options$voids6 === void 0 ? false : _options$voids6;\n        var match = options.match, _options$at6 = options.at, at = _options$at6 === void 0 ? editor.selection : _options$at6;\n        if (!at) {\n            return;\n        }\n        var pointBeforeLocation = Editor.before(editor, at, {\n            voids: voids\n        });\n        if (!pointBeforeLocation) {\n            return;\n        }\n        var _Editor$first = Editor.first(editor, []), _Editor$first2 = _slicedToArray(_Editor$first, 2), to = _Editor$first2[1]; // The search location is from the start of the document to the path of\n        // the point before the location passed in\n        var span = [\n            pointBeforeLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the previous node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var _Editor$parent3 = Editor.parent(editor, at), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parent = _Editor$parent4[0];\n                match = function match(n) {\n                    return parent.children.includes(n);\n                };\n            } else {\n                match = function match() {\n                    return true;\n                };\n            }\n        }\n        var _Editor$nodes5 = Editor.nodes(editor, {\n            reverse: true,\n            at: span,\n            match: match,\n            mode: mode,\n            voids: voids\n        }), _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1), previous = _Editor$nodes6[0];\n        return previous;\n    },\n    /**\r\n   * Get a range of a location.\r\n   */ range: function range(editor, at, to) {\n        if (Range.isRange(at) && !to) {\n            return at;\n        }\n        var start = Editor.start(editor, at);\n        var end = Editor.end(editor, to || at);\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ rangeRef: function rangeRef(editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$affinity3 = options.affinity, affinity = _options$affinity3 === void 0 ? \"forward\" : _options$affinity3;\n        var ref = {\n            current: range,\n            affinity: affinity,\n            unref: function unref() {\n                var current = ref.current;\n                var rangeRefs = Editor.rangeRefs(editor);\n                rangeRefs[\"delete\"](ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.rangeRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */ rangeRefs: function rangeRefs(editor) {\n        var refs = RANGE_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            RANGE_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */ removeMark: function removeMark(editor, key) {\n        editor.removeMark(key);\n    },\n    /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */ setNormalizing: function setNormalizing(editor, isNormalizing) {\n        NORMALIZING.set(editor, isNormalizing);\n    },\n    /**\r\n   * Get the start point of a location.\r\n   */ start: function start(editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"start\"\n        });\n    },\n    /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */ string: function string(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$voids7 = options.voids, voids = _options$voids7 === void 0 ? false : _options$voids7;\n        var range = Editor.range(editor, at);\n        var _Range$edges5 = Range.edges(range), _Range$edges6 = _slicedToArray(_Range$edges5, 2), start = _Range$edges6[0], end = _Range$edges6[1];\n        var text = \"\";\n        var _iterator8 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n            at: range,\n            match: Text.isText,\n            voids: voids\n        })), _step8;\n        try {\n            for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){\n                var _step8$value = _slicedToArray(_step8.value, 2), node = _step8$value[0], path = _step8$value[1];\n                var t = node.text;\n                if (Path.equals(path, end.path)) {\n                    t = t.slice(0, end.offset);\n                }\n                if (Path.equals(path, start.path)) {\n                    t = t.slice(start.offset);\n                }\n                text += t;\n            }\n        } catch (err) {\n            _iterator8.e(err);\n        } finally{\n            _iterator8.f();\n        }\n        return text;\n    },\n    /**\r\n   * Convert a range into a non-hanging one.\r\n   */ unhangRange: function unhangRange(editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$voids8 = options.voids, voids = _options$voids8 === void 0 ? false : _options$voids8;\n        var _Range$edges7 = Range.edges(range), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n        if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n            return range;\n        }\n        var endBlock = Editor.above(editor, {\n            at: end,\n            match: function match(n) {\n                return Element.isElement(n) && Editor.isBlock(editor, n);\n            },\n            voids: voids\n        });\n        var blockPath = endBlock ? endBlock[1] : [];\n        var first = Editor.start(editor, start);\n        var before = {\n            anchor: first,\n            focus: end\n        };\n        var skip = true;\n        var _iterator9 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n            at: before,\n            match: Text.isText,\n            reverse: true,\n            voids: voids\n        })), _step9;\n        try {\n            for(_iterator9.s(); !(_step9 = _iterator9.n()).done;){\n                var _step9$value = _slicedToArray(_step9.value, 2), node = _step9$value[0], path = _step9$value[1];\n                if (skip) {\n                    skip = false;\n                    continue;\n                }\n                if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n                    end = {\n                        path: path,\n                        offset: node.text.length\n                    };\n                    break;\n                }\n            }\n        } catch (err) {\n            _iterator9.e(err);\n        } finally{\n            _iterator9.f();\n        }\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Match a void node in the current branch of the editor.\r\n   */ \"void\": function _void(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            match: function match(n) {\n                return Element.isElement(n) && Editor.isVoid(editor, n);\n            }\n        }));\n    },\n    /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */ withoutNormalizing: function withoutNormalizing(editor, fn) {\n        var value = Editor.isNormalizing(editor);\n        Editor.setNormalizing(editor, false);\n        try {\n            fn();\n        } finally{\n            Editor.setNormalizing(editor, value);\n        }\n        Editor.normalize(editor);\n    }\n};\nvar Location = {\n    /**\r\n   * Check if a value implements the `Location` interface.\r\n   */ isLocation: function isLocation(value) {\n        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n    }\n}; // eslint-disable-next-line no-redeclare\nvar Span = {\n    /**\r\n   * Check if a value implements the `Span` interface.\r\n   */ isSpan: function isSpan(value) {\n        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n    }\n};\nvar _excluded$3 = [\n    \"children\"\n], _excluded2$2 = [\n    \"text\"\n];\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$4(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);\n}\nfunction _arrayLikeToArray$4(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Node = {\n    /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */ ancestor: function ancestor(root, path) {\n        var node = Node.get(root, path);\n        if (Text.isText(node)) {\n            throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */ ancestors: function* ancestors(root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _iterator = _createForOfIteratorHelper$4(Path.ancestors(path, options)), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var p = _step.value;\n                var n = Node.ancestor(root, p);\n                var entry = [\n                    n,\n                    p\n                ];\n                yield entry;\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n    },\n    /**\r\n   * Get the child of a node at a specific index.\r\n   */ child: function child(root, index) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n        }\n        var c = root.children[index];\n        if (c == null) {\n            throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n        }\n        return c;\n    },\n    /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */ children: function* children(root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var ancestor = Node.ancestor(root, path);\n        var children = ancestor.children;\n        var index = reverse ? children.length - 1 : 0;\n        while(reverse ? index >= 0 : index < children.length){\n            var child = Node.child(ancestor, index);\n            var childPath = path.concat(index);\n            yield [\n                child,\n                childPath\n            ];\n            index = reverse ? index - 1 : index + 1;\n        }\n    },\n    /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */ common: function common(root, path, another) {\n        var p = Path.common(path, another);\n        var n = Node.get(root, p);\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */ descendant: function descendant(root, path) {\n        var node = Node.get(root, path);\n        if (Editor.isEditor(node)) {\n            throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */ descendants: function* descendants(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _iterator2 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step2;\n        try {\n            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                var _step2$value = _slicedToArray(_step2.value, 2), node = _step2$value[0], path = _step2$value[1];\n                if (path.length !== 0) {\n                    // NOTE: we have to coerce here because checking the path's length does\n                    // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        } catch (err) {\n            _iterator2.e(err);\n        } finally{\n            _iterator2.f();\n        }\n    },\n    /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */ elements: function* elements(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _iterator3 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step3;\n        try {\n            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                var _step3$value = _slicedToArray(_step3.value, 2), node = _step3$value[0], path = _step3$value[1];\n                if (Element.isElement(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        } catch (err) {\n            _iterator3.e(err);\n        } finally{\n            _iterator3.f();\n        }\n    },\n    /**\r\n   * Extract props from a Node.\r\n   */ extractProps: function extractProps(node) {\n        if (Element.isAncestor(node)) {\n            node.children;\n            var properties = _objectWithoutProperties(node, _excluded$3);\n            return properties;\n        } else {\n            node.text;\n            var _properties = _objectWithoutProperties(node, _excluded2$2);\n            return _properties;\n        }\n    },\n    /**\r\n   * Get the first node entry in a root node from a path.\r\n   */ first: function first(root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                n = n.children[0];\n                p.push(0);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */ fragment: function fragment(root, range) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n        }\n        var newRoot = immer.produce({\n            children: root.children\n        }, function(r) {\n            var _Range$edges = Range.edges(range), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];\n            var nodeEntries = Node.nodes(r, {\n                reverse: true,\n                pass: function pass(_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2), path = _ref2[1];\n                    return !Range.includes(range, path);\n                }\n            });\n            var _iterator4 = _createForOfIteratorHelper$4(nodeEntries), _step4;\n            try {\n                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                    var _step4$value = _slicedToArray(_step4.value, 2), path = _step4$value[1];\n                    if (!Range.includes(range, path)) {\n                        var parent = Node.parent(r, path);\n                        var index = path[path.length - 1];\n                        parent.children.splice(index, 1);\n                    }\n                    if (Path.equals(path, end.path)) {\n                        var leaf = Node.leaf(r, path);\n                        leaf.text = leaf.text.slice(0, end.offset);\n                    }\n                    if (Path.equals(path, start.path)) {\n                        var _leaf = Node.leaf(r, path);\n                        _leaf.text = _leaf.text.slice(start.offset);\n                    }\n                }\n            } catch (err) {\n                _iterator4.e(err);\n            } finally{\n                _iterator4.f();\n            }\n            if (Editor.isEditor(r)) {\n                r.selection = null;\n            }\n        });\n        return newRoot.children;\n    },\n    /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */ get: function get(root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n            }\n            node = node.children[p];\n        }\n        return node;\n    },\n    /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */ has: function has(root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return false;\n            }\n            node = node.children[p];\n        }\n        return true;\n    },\n    /**\r\n   * Check if a value implements the `Node` interface.\r\n   */ isNode: function isNode(value) {\n        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n    },\n    /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */ isNodeList: function isNodeList(value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        var cachedResult = IS_NODE_LIST_CACHE.get(value);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        var isNodeList = value.every(function(val) {\n            return Node.isNode(val);\n        });\n        IS_NODE_LIST_CACHE.set(value, isNodeList);\n        return isNodeList;\n    },\n    /**\r\n   * Get the last node entry in a root node from a path.\r\n   */ last: function last(root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                var i = n.children.length - 1;\n                n = n.children[i];\n                p.push(i);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */ leaf: function leaf(root, path) {\n        var node = Node.get(root, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */ levels: function* levels(root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _iterator5 = _createForOfIteratorHelper$4(Path.levels(path, options)), _step5;\n        try {\n            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                var p = _step5.value;\n                var n = Node.get(root, p);\n                yield [\n                    n,\n                    p\n                ];\n            }\n        } catch (err) {\n            _iterator5.e(err);\n        } finally{\n            _iterator5.f();\n        }\n    },\n    /**\r\n   * Check if a node matches a set of props.\r\n   */ matches: function matches(node, props) {\n        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n    },\n    /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */ nodes: function* nodes(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var pass = options.pass, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n        var _options$from = options.from, from = _options$from === void 0 ? [] : _options$from, to = options.to;\n        var visited = new Set();\n        var p = [];\n        var n = root;\n        while(true){\n            if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n                break;\n            }\n            if (!visited.has(n)) {\n                yield [\n                    n,\n                    p\n                ];\n            } // If we're allowed to go downward and we haven't descended yet, do.\n            if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([\n                n,\n                p\n            ]) === false)) {\n                visited.add(n);\n                var nextIndex = reverse ? n.children.length - 1 : 0;\n                if (Path.isAncestor(p, from)) {\n                    nextIndex = from[p.length];\n                }\n                p = p.concat(nextIndex);\n                n = Node.get(root, p);\n                continue;\n            } // If we're at the root and we can't go down, we're done.\n            if (p.length === 0) {\n                break;\n            } // If we're going forward...\n            if (!reverse) {\n                var newPath = Path.next(p);\n                if (Node.has(root, newPath)) {\n                    p = newPath;\n                    n = Node.get(root, p);\n                    continue;\n                }\n            } // If we're going backward...\n            if (reverse && p[p.length - 1] !== 0) {\n                var _newPath = Path.previous(p);\n                p = _newPath;\n                n = Node.get(root, p);\n                continue;\n            } // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n        }\n    },\n    /**\r\n   * Get the parent of a node at a specific path.\r\n   */ parent: function parent(root, path) {\n        var parentPath = Path.parent(path);\n        var p = Node.get(root, parentPath);\n        if (Text.isText(p)) {\n            throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n        }\n        return p;\n    },\n    /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */ string: function string(node) {\n        if (Text.isText(node)) {\n            return node.text;\n        } else {\n            return node.children.map(Node.string).join(\"\");\n        }\n    },\n    /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */ texts: function* texts(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _iterator6 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step6;\n        try {\n            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                var _step6$value = _slicedToArray(_step6.value, 2), node = _step6$value[0], path = _step6$value[1];\n                if (Text.isText(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        } catch (err) {\n            _iterator6.e(err);\n        } finally{\n            _iterator6.f();\n        }\n    }\n};\nfunction ownKeys$7(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$7(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$7(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$7(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Operation = {\n    /**\r\n   * Check if a value is a `NodeOperation` object.\r\n   */ isNodeOperation: function isNodeOperation(value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n    },\n    /**\r\n   * Check if a value is an `Operation` object.\r\n   */ isOperation: function isOperation(value) {\n        if (!isPlainObject.isPlainObject(value)) {\n            return false;\n        }\n        switch(value.type){\n            case \"insert_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"insert_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"merge_node\":\n                return typeof value.position === \"number\" && Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties);\n            case \"move_node\":\n                return Path.isPath(value.path) && Path.isPath(value.newPath);\n            case \"remove_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"remove_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"set_node\":\n                return Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n            case \"set_selection\":\n                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n            case \"split_node\":\n                return Path.isPath(value.path) && typeof value.position === \"number\" && isPlainObject.isPlainObject(value.properties);\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */ isOperationList: function isOperationList(value) {\n        return Array.isArray(value) && value.every(function(val) {\n            return Operation.isOperation(val);\n        });\n    },\n    /**\r\n   * Check if a value is a `SelectionOperation` object.\r\n   */ isSelectionOperation: function isSelectionOperation(value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n    },\n    /**\r\n   * Check if a value is a `TextOperation` object.\r\n   */ isTextOperation: function isTextOperation(value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n    },\n    /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */ inverse: function inverse(op) {\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_node\"\n                    });\n                }\n            case \"insert_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_text\"\n                    });\n                }\n            case \"merge_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"split_node\",\n                        path: Path.previous(op.path)\n                    });\n                }\n            case \"move_node\":\n                {\n                    var newPath = op.newPath, path = op.path; // PERF: in this case the move operation is a no-op anyways.\n                    if (Path.equals(newPath, path)) {\n                        return op;\n                    } // If the move happens completely within a single parent the path and\n                    // newPath are stable with respect to each other.\n                    if (Path.isSibling(path, newPath)) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            path: newPath,\n                            newPath: path\n                        });\n                    } // If the move does not happen within a single parent it is possible\n                    // for the move to impact the true path to the location where the node\n                    // was removed from and where it was inserted. We have to adjust for this\n                    // and find the original path. We can accomplish this (only in non-sibling)\n                    // moves by looking at the impact of the move operation on the node\n                    // after the original move path.\n                    var inversePath = Path.transform(path, op);\n                    var inverseNewPath = Path.transform(Path.next(path), op);\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        path: inversePath,\n                        newPath: inverseNewPath\n                    });\n                }\n            case \"remove_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_node\"\n                    });\n                }\n            case \"remove_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_text\"\n                    });\n                }\n            case \"set_node\":\n                {\n                    var properties = op.properties, newProperties = op.newProperties;\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        properties: newProperties,\n                        newProperties: properties\n                    });\n                }\n            case \"set_selection\":\n                {\n                    var _properties = op.properties, _newProperties = op.newProperties;\n                    if (_properties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: null\n                        });\n                    } else if (_newProperties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: null,\n                            newProperties: _properties\n                        });\n                    } else {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: _properties\n                        });\n                    }\n                }\n            case \"split_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"merge_node\",\n                        path: Path.next(op.path)\n                    });\n                }\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Path = {\n    /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */ ancestors: function ancestors(path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var paths = Path.levels(path, options);\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n        return paths;\n    },\n    /**\r\n   * Get the common ancestor path of two paths.\r\n   */ common: function common(path, another) {\n        var common = [];\n        for(var i = 0; i < path.length && i < another.length; i++){\n            var av = path[i];\n            var bv = another[i];\n            if (av !== bv) {\n                break;\n            }\n            common.push(av);\n        }\n        return common;\n    },\n    /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */ compare: function compare(path, another) {\n        var min = Math.min(path.length, another.length);\n        for(var i = 0; i < min; i++){\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n        return 0;\n    },\n    /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */ endsAfter: function endsAfter(path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av > bv;\n    },\n    /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */ endsAt: function endsAt(path, another) {\n        var i = path.length;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        return Path.equals(as, bs);\n    },\n    /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */ endsBefore: function endsBefore(path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    /**\r\n   * Check if a path is exactly equal to another.\r\n   */ equals: function equals(path, another) {\n        return path.length === another.length && path.every(function(n, i) {\n            return n === another[i];\n        });\n    },\n    /**\r\n   * Check if the path of previous sibling node exists\r\n   */ hasPrevious: function hasPrevious(path) {\n        return path[path.length - 1] > 0;\n    },\n    /**\r\n   * Check if a path is after another.\r\n   */ isAfter: function isAfter(path, another) {\n        return Path.compare(path, another) === 1;\n    },\n    /**\r\n   * Check if a path is an ancestor of another.\r\n   */ isAncestor: function isAncestor(path, another) {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is before another.\r\n   */ isBefore: function isBefore(path, another) {\n        return Path.compare(path, another) === -1;\n    },\n    /**\r\n   * Check if a path is a child of another.\r\n   */ isChild: function isChild(path, another) {\n        return path.length === another.length + 1 && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */ isCommon: function isCommon(path, another) {\n        return path.length <= another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is a descendant of another.\r\n   */ isDescendant: function isDescendant(path, another) {\n        return path.length > another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is the parent of another.\r\n   */ isParent: function isParent(path, another) {\n        return path.length + 1 === another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check is a value implements the `Path` interface.\r\n   */ isPath: function isPath(value) {\n        return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n    },\n    /**\r\n   * Check if a path is a sibling of another.\r\n   */ isSibling: function isSibling(path, another) {\n        if (path.length !== another.length) {\n            return false;\n        }\n        var as = path.slice(0, -1);\n        var bs = another.slice(0, -1);\n        var al = path[path.length - 1];\n        var bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */ levels: function levels(path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n        var list = [];\n        for(var i = 0; i <= path.length; i++){\n            list.push(path.slice(0, i));\n        }\n        if (reverse) {\n            list.reverse();\n        }\n        return list;\n    },\n    /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */ next: function next(path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n        }\n        var last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */ operationCanTransformPath: function operationCanTransformPath(operation) {\n        switch(operation.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"split_node\":\n            case \"move_node\":\n                return true;\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */ parent: function parent(path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n        }\n        return path.slice(0, -1);\n    },\n    /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */ previous: function previous(path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n        }\n        var last = path[path.length - 1];\n        if (last <= 0) {\n            throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n        }\n        return path.slice(0, -1).concat(last - 1);\n    },\n    /**\r\n   * Get a path relative to an ancestor.\r\n   */ relative: function relative(path, ancestor) {\n        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n            throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n        }\n        return path.slice(ancestor.length);\n    },\n    /**\r\n   * Transform a path by an operation.\r\n   */ transform: function transform(path, operation) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!path) return null; // PERF: use destructing instead of immer\n        var p = _toConsumableArray(path);\n        var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"forward\" : _options$affinity; // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n        switch(operation.type){\n            case \"insert_node\":\n                {\n                    var op = operation.path;\n                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                        p[op.length - 1] += 1;\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var _op = operation.path;\n                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n                        return null;\n                    } else if (Path.endsBefore(_op, p)) {\n                        p[_op.length - 1] -= 1;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var _op2 = operation.path, position = operation.position;\n                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                    } else if (Path.isAncestor(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                        p[_op2.length] += position;\n                    }\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var _op3 = operation.path, _position = operation.position;\n                    if (Path.equals(_op3, p)) {\n                        if (affinity === \"forward\") {\n                            p[p.length - 1] += 1;\n                        } else if (affinity === \"backward\") ;\n                        else {\n                            return null;\n                        }\n                    } else if (Path.endsBefore(_op3, p)) {\n                        p[_op3.length - 1] += 1;\n                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n                        p[_op3.length - 1] += 1;\n                        p[_op3.length] -= _position;\n                    }\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var _op4 = operation.path, onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n                    if (Path.equals(_op4, onp)) {\n                        return p;\n                    }\n                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n                        var copy = onp.slice();\n                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                            copy[_op4.length - 1] -= 1;\n                        }\n                        return copy.concat(p.slice(_op4.length));\n                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        } else {\n                            p[_op4.length - 1] += 1;\n                        }\n                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        }\n                        p[onp.length - 1] += 1;\n                    } else if (Path.endsBefore(_op4, p)) {\n                        if (Path.equals(onp, p)) {\n                            p[onp.length - 1] += 1;\n                        }\n                        p[_op4.length - 1] -= 1;\n                    }\n                    break;\n                }\n        }\n        return p;\n    }\n};\nvar PathRef = {\n    /**\r\n   * Transform the path ref's current value by an operation.\r\n   */ transform: function transform(ref, op) {\n        var current = ref.current, affinity = ref.affinity;\n        if (current == null) {\n            return;\n        }\n        var path = Path.transform(current, op, {\n            affinity: affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nfunction ownKeys$6(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$6(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$6(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$6(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Point = {\n    /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */ compare: function compare(point, another) {\n        var result = Path.compare(point.path, another.path);\n        if (result === 0) {\n            if (point.offset < another.offset) return -1;\n            if (point.offset > another.offset) return 1;\n            return 0;\n        }\n        return result;\n    },\n    /**\r\n   * Check if a point is after another.\r\n   */ isAfter: function isAfter(point, another) {\n        return Point.compare(point, another) === 1;\n    },\n    /**\r\n   * Check if a point is before another.\r\n   */ isBefore: function isBefore(point, another) {\n        return Point.compare(point, another) === -1;\n    },\n    /**\r\n   * Check if a point is exactly equal to another.\r\n   */ equals: function equals(point, another) {\n        // PERF: ensure the offsets are equal first since they are cheaper to check.\n        return point.offset === another.offset && Path.equals(point.path, another.path);\n    },\n    /**\r\n   * Check if a value implements the `Point` interface.\r\n   */ isPoint: function isPoint(value) {\n        return isPlainObject.isPlainObject(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n    },\n    /**\r\n   * Transform a point by an operation.\r\n   */ transform: function transform(point, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return immer.produce(point, function(p) {\n            if (p === null) {\n                return null;\n            }\n            var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"forward\" : _options$affinity;\n            var path = p.path, offset = p.offset;\n            switch(op.type){\n                case \"insert_node\":\n                case \"move_node\":\n                    {\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"insert_text\":\n                    {\n                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === \"forward\")) {\n                            p.offset += op.text.length;\n                        }\n                        break;\n                    }\n                case \"merge_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            p.offset += op.position;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"remove_text\":\n                    {\n                        if (Path.equals(op.path, path) && op.offset <= offset) {\n                            p.offset -= Math.min(offset - op.offset, op.text.length);\n                        }\n                        break;\n                    }\n                case \"remove_node\":\n                    {\n                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n                            return null;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"split_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            if (op.position === offset && affinity == null) {\n                                return null;\n                            } else if (op.position < offset || op.position === offset && affinity === \"forward\") {\n                                p.offset -= op.position;\n                                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                                    affinity: \"forward\"\n                                }));\n                            }\n                        } else {\n                            p.path = Path.transform(path, op, options);\n                        }\n                        break;\n                    }\n            }\n        });\n    }\n};\nvar PointRef = {\n    /**\r\n   * Transform the point ref's current value by an operation.\r\n   */ transform: function transform(ref, op) {\n        var current = ref.current, affinity = ref.affinity;\n        if (current == null) {\n            return;\n        }\n        var point = Point.transform(current, op, {\n            affinity: affinity\n        });\n        ref.current = point;\n        if (point == null) {\n            ref.unref();\n        }\n    }\n};\nvar _excluded$2 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$5(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$5(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$5(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$5(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Range = {\n    /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */ edges: function edges(range) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var anchor = range.anchor, focus = range.focus;\n        return Range.isBackward(range) === reverse ? [\n            anchor,\n            focus\n        ] : [\n            focus,\n            anchor\n        ];\n    },\n    /**\r\n   * Get the end point of a range.\r\n   */ end: function end(range) {\n        var _Range$edges = Range.edges(range), _Range$edges2 = _slicedToArray(_Range$edges, 2), end = _Range$edges2[1];\n        return end;\n    },\n    /**\r\n   * Check if a range is exactly equal to another.\r\n   */ equals: function equals(range, another) {\n        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n    },\n    /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */ includes: function includes(range, target) {\n        if (Range.isRange(target)) {\n            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n                return true;\n            }\n            var _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), rs = _Range$edges4[0], re = _Range$edges4[1];\n            var _Range$edges5 = Range.edges(target), _Range$edges6 = _slicedToArray(_Range$edges5, 2), ts = _Range$edges6[0], te = _Range$edges6[1];\n            return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n        }\n        var _Range$edges7 = Range.edges(range), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1];\n        var isAfterStart = false;\n        var isBeforeEnd = false;\n        if (Point.isPoint(target)) {\n            isAfterStart = Point.compare(target, start) >= 0;\n            isBeforeEnd = Point.compare(target, end) <= 0;\n        } else {\n            isAfterStart = Path.compare(target, start.path) >= 0;\n            isBeforeEnd = Path.compare(target, end.path) <= 0;\n        }\n        return isAfterStart && isBeforeEnd;\n    },\n    /**\r\n   * Get the intersection of a range with another.\r\n   */ intersection: function intersection(range, another) {\n        range.anchor;\n        range.focus;\n        var rest = _objectWithoutProperties(range, _excluded$2);\n        var _Range$edges9 = Range.edges(range), _Range$edges10 = _slicedToArray(_Range$edges9, 2), s1 = _Range$edges10[0], e1 = _Range$edges10[1];\n        var _Range$edges11 = Range.edges(another), _Range$edges12 = _slicedToArray(_Range$edges11, 2), s2 = _Range$edges12[0], e2 = _Range$edges12[1];\n        var start = Point.isBefore(s1, s2) ? s2 : s1;\n        var end = Point.isBefore(e1, e2) ? e1 : e2;\n        if (Point.isBefore(end, start)) {\n            return null;\n        } else {\n            return _objectSpread$5({\n                anchor: start,\n                focus: end\n            }, rest);\n        }\n    },\n    /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */ isBackward: function isBackward(range) {\n        var anchor = range.anchor, focus = range.focus;\n        return Point.isAfter(anchor, focus);\n    },\n    /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */ isCollapsed: function isCollapsed(range) {\n        var anchor = range.anchor, focus = range.focus;\n        return Point.equals(anchor, focus);\n    },\n    /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */ isExpanded: function isExpanded(range) {\n        return !Range.isCollapsed(range);\n    },\n    /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */ isForward: function isForward(range) {\n        return !Range.isBackward(range);\n    },\n    /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */ isRange: function isRange(value) {\n        return isPlainObject.isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n    },\n    /**\r\n   * Iterate through all of the point entries in a range.\r\n   */ points: function* points(range) {\n        yield [\n            range.anchor,\n            \"anchor\"\n        ];\n        yield [\n            range.focus,\n            \"focus\"\n        ];\n    },\n    /**\r\n   * Get the start point of a range.\r\n   */ start: function start(range) {\n        var _Range$edges13 = Range.edges(range), _Range$edges14 = _slicedToArray(_Range$edges13, 1), start = _Range$edges14[0];\n        return start;\n    },\n    /**\r\n   * Transform a range by an operation.\r\n   */ transform: function transform(range, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return immer.produce(range, function(r) {\n            if (r === null) {\n                return null;\n            }\n            var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"inward\" : _options$affinity;\n            var affinityAnchor;\n            var affinityFocus;\n            if (affinity === \"inward\") {\n                // If the range is collapsed, make sure to use the same affinity to\n                // avoid the two points passing each other and expanding in the opposite\n                // direction\n                var isCollapsed = Range.isCollapsed(r);\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"backward\";\n                } else {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"forward\";\n                }\n            } else if (affinity === \"outward\") {\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = \"forward\";\n                } else {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = \"backward\";\n                }\n            } else {\n                affinityAnchor = affinity;\n                affinityFocus = affinity;\n            }\n            var anchor = Point.transform(r.anchor, op, {\n                affinity: affinityAnchor\n            });\n            var focus = Point.transform(r.focus, op, {\n                affinity: affinityFocus\n            });\n            if (!anchor || !focus) {\n                return null;\n            }\n            r.anchor = anchor;\n            r.focus = focus;\n        });\n    }\n};\nvar RangeRef = {\n    /**\r\n   * Transform the range ref's current value by an operation.\r\n   */ transform: function transform(ref, op) {\n        var current = ref.current, affinity = ref.affinity;\n        if (current == null) {\n            return;\n        }\n        var path = Range.transform(current, op, {\n            affinity: affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */ // eslint-disable-next-line no-redeclare\nvar Scrubber = {\n    setScrubber: function setScrubber(scrubber) {\n        _scrubber = scrubber;\n    },\n    stringify: function stringify(value) {\n        return JSON.stringify(value, _scrubber);\n    }\n};\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */ var isDeepEqual = function isDeepEqual(node, another) {\n    for(var key in node){\n        var a = node[key];\n        var b = another[key];\n        if (isPlainObject.isPlainObject(a) && isPlainObject.isPlainObject(b)) {\n            if (!isDeepEqual(a, b)) return false;\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) return false;\n            for(var i = 0; i < a.length; i++){\n                if (a[i] !== b[i]) return false;\n            }\n        } else if (a !== b) {\n            return false;\n        }\n    }\n    /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */ for(var _key in another){\n        if (node[_key] === undefined && another[_key] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n};\nvar _excluded$1 = [\n    \"text\"\n], _excluded2$1 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$3(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);\n}\nfunction _arrayLikeToArray$3(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction ownKeys$4(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$4(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$4(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Text = {\n    /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */ equals: function equals(text, another) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$loose = options.loose, loose = _options$loose === void 0 ? false : _options$loose;\n        function omitText(obj) {\n            obj.text;\n            var rest = _objectWithoutProperties(obj, _excluded$1);\n            return rest;\n        }\n        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n    },\n    /**\r\n   * Check if a value implements the `Text` interface.\r\n   */ isText: function isText(value) {\n        return isPlainObject.isPlainObject(value) && typeof value.text === \"string\";\n    },\n    /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */ isTextList: function isTextList(value) {\n        return Array.isArray(value) && value.every(function(val) {\n            return Text.isText(val);\n        });\n    },\n    /**\r\n   * Check if some props are a partial of Text.\r\n   */ isTextProps: function isTextProps(props) {\n        return props.text !== undefined;\n    },\n    /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */ matches: function matches(text, props) {\n        for(var key in props){\n            if (key === \"text\") {\n                continue;\n            }\n            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\r\n   * Get the leaves for a text node given decorations.\r\n   */ decorations: function decorations(node, _decorations) {\n        var leaves = [\n            _objectSpread$4({}, node)\n        ];\n        var _iterator = _createForOfIteratorHelper$3(_decorations), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var dec = _step.value;\n                var anchor = dec.anchor, focus = dec.focus, rest = _objectWithoutProperties(dec, _excluded2$1);\n                var _Range$edges = Range.edges(dec), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];\n                var next = [];\n                var leafEnd = 0;\n                var decorationStart = start.offset;\n                var decorationEnd = end.offset;\n                var _iterator2 = _createForOfIteratorHelper$3(leaves), _step2;\n                try {\n                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                        var leaf = _step2.value;\n                        var length = leaf.text.length;\n                        var leafStart = leafEnd;\n                        leafEnd += length; // If the range encompasses the entire leaf, add the range.\n                        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n                            Object.assign(leaf, rest);\n                            next.push(leaf);\n                            continue;\n                        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n                        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n                            next.push(leaf);\n                            continue;\n                        } // Otherwise we need to split the leaf, at the start, end, or both,\n                        // and add the range to the middle intersecting section. Do the end\n                        // split first since we don't need to update the offset that way.\n                        var middle = leaf;\n                        var before = void 0;\n                        var after = void 0;\n                        if (decorationEnd < leafEnd) {\n                            var off = decorationEnd - leafStart;\n                            after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(off)\n                            });\n                            middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(0, off)\n                            });\n                        }\n                        if (decorationStart > leafStart) {\n                            var _off = decorationStart - leafStart;\n                            before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(0, _off)\n                            });\n                            middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(_off)\n                            });\n                        }\n                        Object.assign(middle, rest);\n                        if (before) {\n                            next.push(before);\n                        }\n                        next.push(middle);\n                        if (after) {\n                            next.push(after);\n                        }\n                    }\n                } catch (err) {\n                    _iterator2.e(err);\n                } finally{\n                    _iterator2.f();\n                }\n                leaves = next;\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n        return leaves;\n    }\n};\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$2(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);\n}\nfunction _arrayLikeToArray$2(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar applyToDraft = function applyToDraft(editor, selection, op) {\n    switch(op.type){\n        case \"insert_node\":\n            {\n                var path = op.path, node = op.node;\n                var parent = Node.parent(editor, path);\n                var index = path[path.length - 1];\n                if (index > parent.children.length) {\n                    throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n                }\n                parent.children.splice(index, 0, node);\n                if (selection) {\n                    var _iterator = _createForOfIteratorHelper$2(Range.points(selection)), _step;\n                    try {\n                        for(_iterator.s(); !(_step = _iterator.n()).done;){\n                            var _step$value = _slicedToArray(_step.value, 2), point = _step$value[0], key = _step$value[1];\n                            selection[key] = Point.transform(point, op);\n                        }\n                    } catch (err) {\n                        _iterator.e(err);\n                    } finally{\n                        _iterator.f();\n                    }\n                }\n                break;\n            }\n        case \"insert_text\":\n            {\n                var _path = op.path, offset = op.offset, text = op.text;\n                if (text.length === 0) break;\n                var _node = Node.leaf(editor, _path);\n                var before = _node.text.slice(0, offset);\n                var after = _node.text.slice(offset);\n                _node.text = before + text + after;\n                if (selection) {\n                    var _iterator2 = _createForOfIteratorHelper$2(Range.points(selection)), _step2;\n                    try {\n                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                            var _step2$value = _slicedToArray(_step2.value, 2), _point = _step2$value[0], _key = _step2$value[1];\n                            selection[_key] = Point.transform(_point, op);\n                        }\n                    } catch (err) {\n                        _iterator2.e(err);\n                    } finally{\n                        _iterator2.f();\n                    }\n                }\n                break;\n            }\n        case \"merge_node\":\n            {\n                var _path2 = op.path;\n                var _node2 = Node.get(editor, _path2);\n                var prevPath = Path.previous(_path2);\n                var prev = Node.get(editor, prevPath);\n                var _parent = Node.parent(editor, _path2);\n                var _index = _path2[_path2.length - 1];\n                if (Text.isText(_node2) && Text.isText(prev)) {\n                    prev.text += _node2.text;\n                } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n                    var _prev$children;\n                    (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n                } else {\n                    throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n                }\n                _parent.children.splice(_index, 1);\n                if (selection) {\n                    var _iterator3 = _createForOfIteratorHelper$2(Range.points(selection)), _step3;\n                    try {\n                        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                            var _step3$value = _slicedToArray(_step3.value, 2), _point2 = _step3$value[0], _key2 = _step3$value[1];\n                            selection[_key2] = Point.transform(_point2, op);\n                        }\n                    } catch (err) {\n                        _iterator3.e(err);\n                    } finally{\n                        _iterator3.f();\n                    }\n                }\n                break;\n            }\n        case \"move_node\":\n            {\n                var _path3 = op.path, newPath = op.newPath;\n                if (Path.isAncestor(_path3, newPath)) {\n                    throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n                }\n                var _node3 = Node.get(editor, _path3);\n                var _parent2 = Node.parent(editor, _path3);\n                var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n                // the same snapshot in time, there's a mismatch. After either\n                // removing the original position, the second step's path can be out\n                // of date. So instead of using the `op.newPath` directly, we\n                // transform `op.path` to ascertain what the `newPath` would be after\n                // the operation was applied.\n                _parent2.children.splice(_index2, 1);\n                var truePath = Path.transform(_path3, op);\n                var newParent = Node.get(editor, Path.parent(truePath));\n                var newIndex = truePath[truePath.length - 1];\n                newParent.children.splice(newIndex, 0, _node3);\n                if (selection) {\n                    var _iterator4 = _createForOfIteratorHelper$2(Range.points(selection)), _step4;\n                    try {\n                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                            var _step4$value = _slicedToArray(_step4.value, 2), _point3 = _step4$value[0], _key3 = _step4$value[1];\n                            selection[_key3] = Point.transform(_point3, op);\n                        }\n                    } catch (err) {\n                        _iterator4.e(err);\n                    } finally{\n                        _iterator4.f();\n                    }\n                }\n                break;\n            }\n        case \"remove_node\":\n            {\n                var _path4 = op.path;\n                var _index3 = _path4[_path4.length - 1];\n                var _parent3 = Node.parent(editor, _path4);\n                _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n                // node that was removed we need to update the range or remove it.\n                if (selection) {\n                    var _iterator5 = _createForOfIteratorHelper$2(Range.points(selection)), _step5;\n                    try {\n                        for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                            var _step5$value = _slicedToArray(_step5.value, 2), _point4 = _step5$value[0], _key4 = _step5$value[1];\n                            var result = Point.transform(_point4, op);\n                            if (selection != null && result != null) {\n                                selection[_key4] = result;\n                            } else {\n                                var _prev = void 0;\n                                var next = void 0;\n                                var _iterator6 = _createForOfIteratorHelper$2(Node.texts(editor)), _step6;\n                                try {\n                                    for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                                        var _step6$value = _slicedToArray(_step6.value, 2), n = _step6$value[0], p = _step6$value[1];\n                                        if (Path.compare(p, _path4) === -1) {\n                                            _prev = [\n                                                n,\n                                                p\n                                            ];\n                                        } else {\n                                            next = [\n                                                n,\n                                                p\n                                            ];\n                                            break;\n                                        }\n                                    }\n                                } catch (err) {\n                                    _iterator6.e(err);\n                                } finally{\n                                    _iterator6.f();\n                                }\n                                var preferNext = false;\n                                if (_prev && next) {\n                                    if (Path.equals(next[1], _path4)) {\n                                        preferNext = !Path.hasPrevious(next[1]);\n                                    } else {\n                                        preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                                    }\n                                }\n                                if (_prev && !preferNext) {\n                                    _point4.path = _prev[1];\n                                    _point4.offset = _prev[0].text.length;\n                                } else if (next) {\n                                    _point4.path = next[1];\n                                    _point4.offset = 0;\n                                } else {\n                                    selection = null;\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _iterator5.e(err);\n                    } finally{\n                        _iterator5.f();\n                    }\n                }\n                break;\n            }\n        case \"remove_text\":\n            {\n                var _path5 = op.path, _offset = op.offset, _text = op.text;\n                if (_text.length === 0) break;\n                var _node4 = Node.leaf(editor, _path5);\n                var _before = _node4.text.slice(0, _offset);\n                var _after = _node4.text.slice(_offset + _text.length);\n                _node4.text = _before + _after;\n                if (selection) {\n                    var _iterator7 = _createForOfIteratorHelper$2(Range.points(selection)), _step7;\n                    try {\n                        for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){\n                            var _step7$value = _slicedToArray(_step7.value, 2), _point5 = _step7$value[0], _key5 = _step7$value[1];\n                            selection[_key5] = Point.transform(_point5, op);\n                        }\n                    } catch (err) {\n                        _iterator7.e(err);\n                    } finally{\n                        _iterator7.f();\n                    }\n                }\n                break;\n            }\n        case \"set_node\":\n            {\n                var _path6 = op.path, properties = op.properties, newProperties = op.newProperties;\n                if (_path6.length === 0) {\n                    throw new Error(\"Cannot set properties on the root node!\");\n                }\n                var _node5 = Node.get(editor, _path6);\n                for(var _key6 in newProperties){\n                    if (_key6 === \"children\" || _key6 === \"text\") {\n                        throw new Error('Cannot set the \"'.concat(_key6, '\" property of nodes!'));\n                    }\n                    var value = newProperties[_key6];\n                    if (value == null) {\n                        delete _node5[_key6];\n                    } else {\n                        _node5[_key6] = value;\n                    }\n                } // properties that were previously defined, but are now missing, must be deleted\n                for(var _key7 in properties){\n                    if (!newProperties.hasOwnProperty(_key7)) {\n                        delete _node5[_key7];\n                    }\n                }\n                break;\n            }\n        case \"set_selection\":\n            {\n                var _newProperties = op.newProperties;\n                if (_newProperties == null) {\n                    selection = _newProperties;\n                } else {\n                    if (selection == null) {\n                        if (!Range.isRange(_newProperties)) {\n                            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n                        }\n                        selection = _objectSpread$3({}, _newProperties);\n                    }\n                    for(var _key8 in _newProperties){\n                        var _value = _newProperties[_key8];\n                        if (_value == null) {\n                            if (_key8 === \"anchor\" || _key8 === \"focus\") {\n                                throw new Error('Cannot remove the \"'.concat(_key8, '\" selection property'));\n                            }\n                            delete selection[_key8];\n                        } else {\n                            selection[_key8] = _value;\n                        }\n                    }\n                }\n                break;\n            }\n        case \"split_node\":\n            {\n                var _path7 = op.path, position = op.position, _properties = op.properties;\n                if (_path7.length === 0) {\n                    throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n                }\n                var _node6 = Node.get(editor, _path7);\n                var _parent4 = Node.parent(editor, _path7);\n                var _index4 = _path7[_path7.length - 1];\n                var newNode;\n                if (Text.isText(_node6)) {\n                    var _before2 = _node6.text.slice(0, position);\n                    var _after2 = _node6.text.slice(position);\n                    _node6.text = _before2;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        text: _after2\n                    });\n                } else {\n                    var _before3 = _node6.children.slice(0, position);\n                    var _after3 = _node6.children.slice(position);\n                    _node6.children = _before3;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        children: _after3\n                    });\n                }\n                _parent4.children.splice(_index4 + 1, 0, newNode);\n                if (selection) {\n                    var _iterator8 = _createForOfIteratorHelper$2(Range.points(selection)), _step8;\n                    try {\n                        for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){\n                            var _step8$value = _slicedToArray(_step8.value, 2), _point6 = _step8$value[0], _key9 = _step8$value[1];\n                            selection[_key9] = Point.transform(_point6, op);\n                        }\n                    } catch (err) {\n                        _iterator8.e(err);\n                    } finally{\n                        _iterator8.f();\n                    }\n                }\n                break;\n            }\n    }\n    return selection;\n}; // eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n    /**\r\n   * Transform the editor by an operation.\r\n   */ transform: function transform(editor, op) {\n        editor.children = immer.createDraft(editor.children);\n        var selection = editor.selection && immer.createDraft(editor.selection);\n        try {\n            selection = applyToDraft(editor, selection, op);\n        } finally{\n            editor.children = immer.finishDraft(editor.children);\n            if (selection) {\n                editor.selection = immer.isDraft(selection) ? immer.finishDraft(selection) : selection;\n            } else {\n                editor.selection = null;\n            }\n        }\n    }\n};\nvar _excluded = [\n    \"text\"\n], _excluded2 = [\n    \"children\"\n];\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\nfunction _arrayLikeToArray$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar NodeTransforms = {\n    /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */ insertNodes: function insertNodes(editor, nodes) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$hanging = options.hanging, hanging = _options$hanging === void 0 ? false : _options$hanging, _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids, _options$mode = options.mode, mode = _options$mode === void 0 ? \"lowest\" : _options$mode;\n            var at = options.at, match = options.match, select = options.select;\n            if (Node.isNode(nodes)) {\n                nodes = [\n                    nodes\n                ];\n            }\n            if (nodes.length === 0) {\n                return;\n            }\n            var _nodes = nodes, _nodes2 = _slicedToArray(_nodes, 1), node = _nodes2[0]; // By default, use the selection as the target location. But if there is\n            // no selection, insert at the end of the document since that is such a\n            // common use case when inserting from a non-selected state.\n            if (!at) {\n                if (editor.selection) {\n                    at = editor.selection;\n                } else if (editor.children.length > 0) {\n                    at = Editor.end(editor, []);\n                } else {\n                    at = [\n                        0\n                    ];\n                }\n                select = true;\n            }\n            if (select == null) {\n                select = false;\n            }\n            if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids: voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), end = _Range$edges2[1];\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at\n                    });\n                    at = pointRef.unref();\n                }\n            }\n            if (Point.isPoint(at)) {\n                if (match == null) {\n                    if (Text.isText(node)) {\n                        match = function match(n) {\n                            return Text.isText(n);\n                        };\n                    } else if (editor.isInline(node)) {\n                        match = function match(n) {\n                            return Text.isText(n) || Editor.isInline(editor, n);\n                        };\n                    } else {\n                        match = function match(n) {\n                            return Element.isElement(n) && Editor.isBlock(editor, n);\n                        };\n                    }\n                }\n                var _Editor$nodes = Editor.nodes(editor, {\n                    at: at.path,\n                    match: match,\n                    mode: mode,\n                    voids: voids\n                }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), entry = _Editor$nodes2[0];\n                if (entry) {\n                    var _entry = _slicedToArray(entry, 2), _matchPath = _entry[1];\n                    var pathRef = Editor.pathRef(editor, _matchPath);\n                    var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n                    Transforms.splitNodes(editor, {\n                        at: at,\n                        match: match,\n                        mode: mode,\n                        voids: voids\n                    });\n                    var path = pathRef.unref();\n                    at = isAtEnd ? Path.next(path) : path;\n                } else {\n                    return;\n                }\n            }\n            var parentPath = Path.parent(at);\n            var index = at[at.length - 1];\n            if (!voids && Editor[\"void\"](editor, {\n                at: parentPath\n            })) {\n                return;\n            }\n            var _iterator = _createForOfIteratorHelper$1(nodes), _step;\n            try {\n                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                    var _node = _step.value;\n                    var _path = parentPath.concat(index);\n                    index++;\n                    editor.apply({\n                        type: \"insert_node\",\n                        path: _path,\n                        node: _node\n                    });\n                    at = Path.next(at);\n                }\n            } catch (err) {\n                _iterator.e(err);\n            } finally{\n                _iterator.f();\n            }\n            at = Path.previous(at);\n            if (select) {\n                var point = Editor.end(editor, at);\n                if (point) {\n                    Transforms.select(editor, point);\n                }\n            }\n        });\n    },\n    /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */ liftNodes: function liftNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, _options$mode2 = options.mode, mode = _options$mode2 === void 0 ? \"lowest\" : _options$mode2, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n            var match = options.match;\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (!at) {\n                return;\n            }\n            var matches = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(matches, function(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2), p = _ref2[1];\n                return Editor.pathRef(editor, p);\n            });\n            for(var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++){\n                var pathRef = _pathRefs[_i];\n                var path = pathRef.unref();\n                if (path.length < 2) {\n                    throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n                }\n                var parentNodeEntry = Editor.node(editor, Path.parent(path));\n                var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2), parent = _parentNodeEntry[0], parentPath = _parentNodeEntry[1];\n                var index = path[path.length - 1];\n                var length = parent.children.length;\n                if (length === 1) {\n                    var toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: toPath,\n                        voids: voids\n                    });\n                    Transforms.removeNodes(editor, {\n                        at: parentPath,\n                        voids: voids\n                    });\n                } else if (index === 0) {\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: parentPath,\n                        voids: voids\n                    });\n                } else if (index === length - 1) {\n                    var _toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath,\n                        voids: voids\n                    });\n                } else {\n                    var splitPath = Path.next(path);\n                    var _toPath2 = Path.next(parentPath);\n                    Transforms.splitNodes(editor, {\n                        at: splitPath,\n                        voids: voids\n                    });\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath2,\n                        voids: voids\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */ mergeNodes: function mergeNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var match = options.match, _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2;\n            var _options$hanging2 = options.hanging, hanging = _options$hanging2 === void 0 ? false : _options$hanging2, _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? \"lowest\" : _options$mode3;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    var _Editor$parent = Editor.parent(editor, at), _Editor$parent2 = _slicedToArray(_Editor$parent, 1), parent = _Editor$parent2[0];\n                    match = function match(n) {\n                        return parent.children.includes(n);\n                    };\n                } else {\n                    match = function match(n) {\n                        return Element.isElement(n) && Editor.isBlock(editor, n);\n                    };\n                }\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids: voids\n                });\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var _Range$edges3 = Range.edges(at), _Range$edges4 = _slicedToArray(_Range$edges3, 2), end = _Range$edges4[1];\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at\n                    });\n                    at = pointRef.unref();\n                    if (options.at == null) {\n                        Transforms.select(editor, at);\n                    }\n                }\n            }\n            var _Editor$nodes3 = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                voids: voids,\n                mode: mode\n            }), _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1), current = _Editor$nodes4[0];\n            var prev = Editor.previous(editor, {\n                at: at,\n                match: match,\n                voids: voids,\n                mode: mode\n            });\n            if (!current || !prev) {\n                return;\n            }\n            var _current = _slicedToArray(current, 2), node = _current[0], path = _current[1];\n            var _prev = _slicedToArray(prev, 2), prevNode = _prev[0], prevPath = _prev[1];\n            if (path.length === 0 || prevPath.length === 0) {\n                return;\n            }\n            var newPath = Path.next(prevPath);\n            var commonPath = Path.common(path, prevPath);\n            var isPreviousSibling = Path.isSibling(path, prevPath);\n            var levels = Array.from(Editor.levels(editor, {\n                at: path\n            }), function(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 1), n = _ref4[0];\n                return n;\n            }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n            // result, in which case we'll want to remove it after merging.\n            var emptyAncestor = Editor.above(editor, {\n                at: path,\n                mode: \"highest\",\n                match: function match(n) {\n                    return levels.includes(n) && hasSingleChildNest(editor, n);\n                }\n            });\n            var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n            var properties;\n            var position; // Ensure that the nodes are equivalent, and figure out what the position\n            // and extra properties of the merge will be.\n            if (Text.isText(node) && Text.isText(prevNode)) {\n                node.text;\n                var rest = _objectWithoutProperties(node, _excluded);\n                position = prevNode.text.length;\n                properties = rest;\n            } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n                node.children;\n                var _rest = _objectWithoutProperties(node, _excluded2);\n                position = prevNode.children.length;\n                properties = _rest;\n            } else {\n                throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n            } // If the node isn't already the next sibling of the previous node, move\n            // it so that it is before merging.\n            if (!isPreviousSibling) {\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: newPath,\n                    voids: voids\n                });\n            } // If there was going to be an empty ancestor of the node that was merged,\n            // we remove it from the tree.\n            if (emptyRef) {\n                Transforms.removeNodes(editor, {\n                    at: emptyRef.current,\n                    voids: voids\n                });\n            } // If the target node that we're merging with is empty, remove it instead\n            // of merging the two. This is a common rich text editor behavior to\n            // prevent losing formatting when deleting entire nodes when you have a\n            // hanging selection.\n            // if prevNode is first child in parent,don't remove it.\n            if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0) {\n                Transforms.removeNodes(editor, {\n                    at: prevPath,\n                    voids: voids\n                });\n            } else {\n                editor.apply({\n                    type: \"merge_node\",\n                    path: newPath,\n                    position: position,\n                    properties: properties\n                });\n            }\n            if (emptyRef) {\n                emptyRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Move the nodes at a location to a new location.\r\n   */ moveNodes: function moveNodes(editor, options) {\n        Editor.withoutNormalizing(editor, function() {\n            var to = options.to, _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3, _options$mode4 = options.mode, mode = _options$mode4 === void 0 ? \"lowest\" : _options$mode4, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;\n            var match = options.match;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            var toRef = Editor.pathRef(editor, to);\n            var targets = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(targets, function(_ref5) {\n                var _ref6 = _slicedToArray(_ref5, 2), p = _ref6[1];\n                return Editor.pathRef(editor, p);\n            });\n            for(var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++){\n                var pathRef = _pathRefs2[_i2];\n                var path = pathRef.unref();\n                var newPath = toRef.current;\n                if (path.length !== 0) {\n                    editor.apply({\n                        type: \"move_node\",\n                        path: path,\n                        newPath: newPath\n                    });\n                }\n                if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n                    // When performing a sibling move to a later index, the path at the destination is shifted\n                    // to before the insertion point instead of after. To ensure our group of nodes are inserted\n                    // in the correct order we increment toRef to account for that\n                    toRef.current = Path.next(toRef.current);\n                }\n            }\n            toRef.unref();\n        });\n    },\n    /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */ removeNodes: function removeNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$hanging3 = options.hanging, hanging = _options$hanging3 === void 0 ? false : _options$hanging3, _options$voids5 = options.voids, voids = _options$voids5 === void 0 ? false : _options$voids5, _options$mode5 = options.mode, mode = _options$mode5 === void 0 ? \"lowest\" : _options$mode5;\n            var _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, match = options.match;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids: voids\n                });\n            }\n            var depths = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(depths, function(_ref7) {\n                var _ref8 = _slicedToArray(_ref7, 2), p = _ref8[1];\n                return Editor.pathRef(editor, p);\n            });\n            for(var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++){\n                var pathRef = _pathRefs3[_i3];\n                var path = pathRef.unref();\n                if (path) {\n                    var _Editor$node = Editor.node(editor, path), _Editor$node2 = _slicedToArray(_Editor$node, 1), node = _Editor$node2[0];\n                    editor.apply({\n                        type: \"remove_node\",\n                        path: path,\n                        node: node\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Set new properties on the nodes at a location.\r\n   */ setNodes: function setNodes(editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var match = options.match, _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, compare = options.compare, merge = options.merge;\n            var _options$hanging4 = options.hanging, hanging = _options$hanging4 === void 0 ? false : _options$hanging4, _options$mode6 = options.mode, mode = _options$mode6 === void 0 ? \"lowest\" : _options$mode6, _options$split = options.split, split = _options$split === void 0 ? false : _options$split, _options$voids6 = options.voids, voids = _options$voids6 === void 0 ? false : _options$voids6;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids: voids\n                });\n            }\n            if (split && Range.isRange(at)) {\n                if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n                    // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n                    // set that won't get normalized away\n                    return;\n                }\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                var _Range$edges5 = Range.edges(at), _Range$edges6 = _slicedToArray(_Range$edges5, 2), start = _Range$edges6[0], end = _Range$edges6[1];\n                var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n                var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match: match,\n                    mode: splitMode,\n                    voids: voids,\n                    always: !endAtEndOfNode\n                });\n                var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match: match,\n                    mode: splitMode,\n                    voids: voids,\n                    always: !startAtStartOfNode\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            if (!compare) {\n                compare = function compare(prop, nodeProp) {\n                    return prop !== nodeProp;\n                };\n            }\n            var _iterator2 = _createForOfIteratorHelper$1(Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            })), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var _step2$value = _slicedToArray(_step2.value, 2), node = _step2$value[0], path = _step2$value[1];\n                    var properties = {};\n                    var newProperties = {}; // You can't set properties on the editor node.\n                    if (path.length === 0) {\n                        continue;\n                    }\n                    var hasChanges = false;\n                    for(var k in props){\n                        if (k === \"children\" || k === \"text\") {\n                            continue;\n                        }\n                        if (compare(props[k], node[k])) {\n                            hasChanges = true; // Omit new properties from the old properties list\n                            if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n                            if (merge) {\n                                if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n                            } else {\n                                if (props[k] != null) newProperties[k] = props[k];\n                            }\n                        }\n                    }\n                    if (hasChanges) {\n                        editor.apply({\n                            type: \"set_node\",\n                            path: path,\n                            properties: properties,\n                            newProperties: newProperties\n                        });\n                    }\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n        });\n    },\n    /**\r\n   * Split the nodes at a specific location.\r\n   */ splitNodes: function splitNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$mode7 = options.mode, mode = _options$mode7 === void 0 ? \"lowest\" : _options$mode7, _options$voids7 = options.voids, voids = _options$voids7 === void 0 ? false : _options$voids7;\n            var match = options.match, _options$at6 = options.at, at = _options$at6 === void 0 ? editor.selection : _options$at6, _options$height = options.height, height = _options$height === void 0 ? 0 : _options$height, _options$always = options.always, always = _options$always === void 0 ? false : _options$always;\n            if (match == null) {\n                match = function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (Range.isRange(at)) {\n                at = deleteRange(editor, at);\n            } // If the target is a path, the default height-skipping and position\n            // counters need to account for us potentially splitting at a non-leaf.\n            if (Path.isPath(at)) {\n                var path = at;\n                var point = Editor.point(editor, path);\n                var _Editor$parent3 = Editor.parent(editor, path), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parent = _Editor$parent4[0];\n                match = function match(n) {\n                    return n === parent;\n                };\n                height = point.path.length - path.length + 1;\n                at = point;\n                always = true;\n            }\n            if (!at) {\n                return;\n            }\n            var beforeRef = Editor.pointRef(editor, at, {\n                affinity: \"backward\"\n            });\n            var afterRef;\n            try {\n                var _Editor$nodes5 = Editor.nodes(editor, {\n                    at: at,\n                    match: match,\n                    mode: mode,\n                    voids: voids\n                }), _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1), highest = _Editor$nodes6[0];\n                if (!highest) {\n                    return;\n                }\n                var voidMatch = Editor[\"void\"](editor, {\n                    at: at,\n                    mode: \"highest\"\n                });\n                var nudge = 0;\n                if (!voids && voidMatch) {\n                    var _voidMatch = _slicedToArray(voidMatch, 2), voidNode = _voidMatch[0], voidPath = _voidMatch[1];\n                    if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n                        var after = Editor.after(editor, voidPath);\n                        if (!after) {\n                            var text = {\n                                text: \"\"\n                            };\n                            var afterPath = Path.next(voidPath);\n                            Transforms.insertNodes(editor, text, {\n                                at: afterPath,\n                                voids: voids\n                            });\n                            after = Editor.point(editor, afterPath);\n                        }\n                        at = after;\n                        always = true;\n                    }\n                    var siblingHeight = at.path.length - voidPath.length;\n                    height = siblingHeight + 1;\n                    always = true;\n                }\n                afterRef = Editor.pointRef(editor, at);\n                var depth = at.path.length - height;\n                var _highest = _slicedToArray(highest, 2), highestPath = _highest[1];\n                var lowestPath = at.path.slice(0, depth);\n                var position = height === 0 ? at.offset : at.path[depth] + nudge;\n                var _iterator3 = _createForOfIteratorHelper$1(Editor.levels(editor, {\n                    at: lowestPath,\n                    reverse: true,\n                    voids: voids\n                })), _step3;\n                try {\n                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                        var _step3$value = _slicedToArray(_step3.value, 2), node = _step3$value[0], _path2 = _step3$value[1];\n                        var split = false;\n                        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n                            break;\n                        }\n                        var _point2 = beforeRef.current;\n                        var isEnd = Editor.isEnd(editor, _point2, _path2);\n                        if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path2)) {\n                            split = true;\n                            var properties = Node.extractProps(node);\n                            editor.apply({\n                                type: \"split_node\",\n                                path: _path2,\n                                position: position,\n                                properties: properties\n                            });\n                        }\n                        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n                    }\n                } catch (err) {\n                    _iterator3.e(err);\n                } finally{\n                    _iterator3.f();\n                }\n                if (options.at == null) {\n                    var _point = afterRef.current || Editor.end(editor, []);\n                    Transforms.select(editor, _point);\n                }\n            } finally{\n                var _afterRef;\n                beforeRef.unref();\n                (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Unset properties on the nodes at a location.\r\n   */ unsetNodes: function unsetNodes(editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!Array.isArray(props)) {\n            props = [\n                props\n            ];\n        }\n        var obj = {};\n        var _iterator4 = _createForOfIteratorHelper$1(props), _step4;\n        try {\n            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                var key = _step4.value;\n                obj[key] = null;\n            }\n        } catch (err) {\n            _iterator4.e(err);\n        } finally{\n            _iterator4.f();\n        }\n        Transforms.setNodes(editor, obj, options);\n    },\n    /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */ unwrapNodes: function unwrapNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$mode8 = options.mode, mode = _options$mode8 === void 0 ? \"lowest\" : _options$mode8, _options$split2 = options.split, split = _options$split2 === void 0 ? false : _options$split2, _options$voids8 = options.voids, voids = _options$voids8 === void 0 ? false : _options$voids8;\n            var _options$at7 = options.at, at = _options$at7 === void 0 ? editor.selection : _options$at7, match = options.match;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n            var matches = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(matches, function(_ref9) {\n                var _ref10 = _slicedToArray(_ref9, 2), p = _ref10[1];\n                return Editor.pathRef(editor, p);\n            } // unwrapNode will call liftNode which does not support splitting the node when nested.\n            ).reverse();\n            var _iterator5 = _createForOfIteratorHelper$1(pathRefs), _step5;\n            try {\n                var _loop = function _loop() {\n                    var pathRef = _step5.value;\n                    var path = pathRef.unref();\n                    var _Editor$node3 = Editor.node(editor, path), _Editor$node4 = _slicedToArray(_Editor$node3, 1), node = _Editor$node4[0];\n                    var range = Editor.range(editor, path);\n                    if (split && rangeRef) {\n                        range = Range.intersection(rangeRef.current, range);\n                    }\n                    Transforms.liftNodes(editor, {\n                        at: range,\n                        match: function match(n) {\n                            return Element.isAncestor(node) && node.children.includes(n);\n                        },\n                        voids: voids\n                    });\n                };\n                for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                    _loop();\n                }\n            } catch (err) {\n                _iterator5.e(err);\n            } finally{\n                _iterator5.f();\n            }\n            if (rangeRef) {\n                rangeRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */ wrapNodes: function wrapNodes(editor, element) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$mode9 = options.mode, mode = _options$mode9 === void 0 ? \"lowest\" : _options$mode9, _options$split3 = options.split, split = _options$split3 === void 0 ? false : _options$split3, _options$voids9 = options.voids, voids = _options$voids9 === void 0 ? false : _options$voids9;\n            var match = options.match, _options$at8 = options.at, at = _options$at8 === void 0 ? editor.selection : _options$at8;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    match = matchPath(editor, at);\n                } else if (editor.isInline(element)) {\n                    match = function match(n) {\n                        return Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n                    };\n                } else {\n                    match = function match(n) {\n                        return Element.isElement(n) && Editor.isBlock(editor, n);\n                    };\n                }\n            }\n            if (split && Range.isRange(at)) {\n                var _Range$edges7 = Range.edges(at), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1];\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match: match,\n                    voids: voids\n                });\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match: match,\n                    voids: voids\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            var roots = Array.from(Editor.nodes(editor, {\n                at: at,\n                match: editor.isInline(element) ? function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                } : function(n) {\n                    return Editor.isEditor(n);\n                },\n                mode: \"lowest\",\n                voids: voids\n            }));\n            for(var _i4 = 0, _roots = roots; _i4 < _roots.length; _i4++){\n                var _roots$_i = _slicedToArray(_roots[_i4], 2), rootPath = _roots$_i[1];\n                var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n                if (!a) {\n                    continue;\n                }\n                var matches = Array.from(Editor.nodes(editor, {\n                    at: a,\n                    match: match,\n                    mode: mode,\n                    voids: voids\n                }));\n                if (matches.length > 0) {\n                    var _ret = function() {\n                        var _matches = _slicedToArray(matches, 1), first = _matches[0];\n                        var last = matches[matches.length - 1];\n                        var _first = _slicedToArray(first, 2), firstPath = _first[1];\n                        var _last = _slicedToArray(last, 2), lastPath = _last[1];\n                        if (firstPath.length === 0 && lastPath.length === 0) {\n                            // if there's no matching parent - usually means the node is an editor - don't do anything\n                            return \"continue\";\n                        }\n                        var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n                        var range = Editor.range(editor, firstPath, lastPath);\n                        var commonNodeEntry = Editor.node(editor, commonPath);\n                        var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1), commonNode = _commonNodeEntry[0];\n                        var depth = commonPath.length + 1;\n                        var wrapperPath = Path.next(lastPath.slice(0, depth));\n                        var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n                            children: []\n                        });\n                        Transforms.insertNodes(editor, wrapper, {\n                            at: wrapperPath,\n                            voids: voids\n                        });\n                        Transforms.moveNodes(editor, {\n                            at: range,\n                            match: function match(n) {\n                                return Element.isAncestor(commonNode) && commonNode.children.includes(n);\n                            },\n                            to: wrapperPath.concat(0),\n                            voids: voids\n                        });\n                    }();\n                    if (_ret === \"continue\") continue;\n                }\n            }\n        });\n    }\n};\nvar hasSingleChildNest = function hasSingleChildNest(editor, node) {\n    if (Element.isElement(node)) {\n        var element = node;\n        if (Editor.isVoid(editor, node)) {\n            return true;\n        } else if (element.children.length === 1) {\n            return hasSingleChildNest(editor, element.children[0]);\n        } else {\n            return false;\n        }\n    } else if (Editor.isEditor(node)) {\n        return false;\n    } else {\n        return true;\n    }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */ var deleteRange = function deleteRange(editor, range) {\n    if (Range.isCollapsed(range)) {\n        return range.anchor;\n    } else {\n        var _Range$edges9 = Range.edges(range), _Range$edges10 = _slicedToArray(_Range$edges9, 2), end = _Range$edges10[1];\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n            at: range\n        });\n        return pointRef.unref();\n    }\n};\nvar matchPath = function matchPath(editor, path) {\n    var _Editor$node5 = Editor.node(editor, path), _Editor$node6 = _slicedToArray(_Editor$node5, 1), node = _Editor$node6[0];\n    return function(n) {\n        return n === node;\n    };\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar SelectionTransforms = {\n    /**\r\n   * Collapse the selection.\r\n   */ collapse: function collapse(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$edge = options.edge, edge = _options$edge === void 0 ? \"anchor\" : _options$edge;\n        var selection = editor.selection;\n        if (!selection) {\n            return;\n        } else if (edge === \"anchor\") {\n            Transforms.select(editor, selection.anchor);\n        } else if (edge === \"focus\") {\n            Transforms.select(editor, selection.focus);\n        } else if (edge === \"start\") {\n            var _Range$edges = Range.edges(selection), _Range$edges2 = _slicedToArray(_Range$edges, 1), start = _Range$edges2[0];\n            Transforms.select(editor, start);\n        } else if (edge === \"end\") {\n            var _Range$edges3 = Range.edges(selection), _Range$edges4 = _slicedToArray(_Range$edges3, 2), end = _Range$edges4[1];\n            Transforms.select(editor, end);\n        }\n    },\n    /**\r\n   * Unset the selection.\r\n   */ deselect: function deselect(editor) {\n        var selection = editor.selection;\n        if (selection) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: selection,\n                newProperties: null\n            });\n        }\n    },\n    /**\r\n   * Move the selection's point forward or backward.\r\n   */ move: function move(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var selection = editor.selection;\n        var _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance, _options$unit = options.unit, unit = _options$unit === void 0 ? \"character\" : _options$unit, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var _options$edge2 = options.edge, edge = _options$edge2 === void 0 ? null : _options$edge2;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var anchor = selection.anchor, focus = selection.focus;\n        var opts = {\n            distance: distance,\n            unit: unit\n        };\n        var props = {};\n        if (edge == null || edge === \"anchor\") {\n            var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n            if (point) {\n                props.anchor = point;\n            }\n        }\n        if (edge == null || edge === \"focus\") {\n            var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n            if (_point) {\n                props.focus = _point;\n            }\n        }\n        Transforms.setSelection(editor, props);\n    },\n    /**\r\n   * Set the selection to a new value.\r\n   */ select: function select(editor, target) {\n        var selection = editor.selection;\n        target = Editor.range(editor, target);\n        if (selection) {\n            Transforms.setSelection(editor, target);\n            return;\n        }\n        if (!Range.isRange(target)) {\n            throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n        }\n        editor.apply({\n            type: \"set_selection\",\n            properties: selection,\n            newProperties: target\n        });\n    },\n    /**\r\n   * Set new properties on one of the selection's points.\r\n   */ setPoint: function setPoint(editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var selection = editor.selection;\n        var _options$edge3 = options.edge, edge = _options$edge3 === void 0 ? \"both\" : _options$edge3;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var anchor = selection.anchor, focus = selection.focus;\n        var point = edge === \"anchor\" ? anchor : focus;\n        Transforms.setSelection(editor, _defineProperty({}, edge === \"anchor\" ? \"anchor\" : \"focus\", _objectSpread$1(_objectSpread$1({}, point), props)));\n    },\n    /**\r\n   * Set new properties on the selection.\r\n   */ setSelection: function setSelection(editor, props) {\n        var selection = editor.selection;\n        var oldProps = {};\n        var newProps = {};\n        if (!selection) {\n            return;\n        }\n        for(var k in props){\n            if (k === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== \"anchor\" && k !== \"focus\" && props[k] !== selection[k]) {\n                oldProps[k] = selection[k];\n                newProps[k] = props[k];\n            }\n        }\n        if (Object.keys(oldProps).length > 0) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: oldProps,\n                newProperties: newProps\n            });\n        }\n    }\n};\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar TextTransforms = {\n    /**\r\n   * Delete content in the editor.\r\n   */ \"delete\": function _delete(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$unit = options.unit, unit = _options$unit === void 0 ? \"character\" : _options$unit, _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance, _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids;\n            var _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, _options$hanging = options.hanging, hanging = _options$hanging === void 0 ? false : _options$hanging;\n            if (!at) {\n                return;\n            }\n            var isCollapsed = false;\n            if (Range.isRange(at) && Range.isCollapsed(at)) {\n                isCollapsed = true;\n                at = at.anchor;\n            }\n            if (Point.isPoint(at)) {\n                var furthestVoid = Editor[\"void\"](editor, {\n                    at: at,\n                    mode: \"highest\"\n                });\n                if (!voids && furthestVoid) {\n                    var _furthestVoid = _slicedToArray(furthestVoid, 2), voidPath = _furthestVoid[1];\n                    at = voidPath;\n                } else {\n                    var opts = {\n                        unit: unit,\n                        distance: distance\n                    };\n                    var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n                    at = {\n                        anchor: at,\n                        focus: target\n                    };\n                    hanging = true;\n                }\n            }\n            if (Path.isPath(at)) {\n                Transforms.removeNodes(editor, {\n                    at: at,\n                    voids: voids\n                });\n                return;\n            }\n            if (Range.isCollapsed(at)) {\n                return;\n            }\n            if (!hanging) {\n                var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), _end = _Range$edges2[1];\n                var endOfDoc = Editor.end(editor, []);\n                if (!Point.equals(_end, endOfDoc)) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids: voids\n                    });\n                }\n            }\n            var _Range$edges3 = Range.edges(at), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n            var startBlock = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                at: start,\n                voids: voids\n            });\n            var endBlock = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                at: end,\n                voids: voids\n            });\n            var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n            var isSingleText = Path.equals(start.path, end.path);\n            var startVoid = voids ? null : Editor[\"void\"](editor, {\n                at: start,\n                mode: \"highest\"\n            });\n            var endVoid = voids ? null : Editor[\"void\"](editor, {\n                at: end,\n                mode: \"highest\"\n            }); // If the start or end points are inside an inline void, nudge them out.\n            if (startVoid) {\n                var before = Editor.before(editor, start);\n                if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n                    start = before;\n                }\n            }\n            if (endVoid) {\n                var after = Editor.after(editor, end);\n                if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                    end = after;\n                }\n            } // Get the highest nodes that are completely inside the range, as well as\n            // the start and end nodes.\n            var matches = [];\n            var lastPath;\n            var _iterator = _createForOfIteratorHelper(Editor.nodes(editor, {\n                at: at,\n                voids: voids\n            })), _step;\n            try {\n                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                    var entry = _step.value;\n                    var _entry = _slicedToArray(entry, 2), _node2 = _entry[0], _path2 = _entry[1];\n                    if (lastPath && Path.compare(_path2, lastPath) === 0) {\n                        continue;\n                    }\n                    if (!voids && Element.isElement(_node2) && Editor.isVoid(editor, _node2) || !Path.isCommon(_path2, start.path) && !Path.isCommon(_path2, end.path)) {\n                        matches.push(entry);\n                        lastPath = _path2;\n                    }\n                }\n            } catch (err) {\n                _iterator.e(err);\n            } finally{\n                _iterator.f();\n            }\n            var pathRefs = Array.from(matches, function(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2), p = _ref2[1];\n                return Editor.pathRef(editor, p);\n            });\n            var startRef = Editor.pointRef(editor, start);\n            var endRef = Editor.pointRef(editor, end);\n            var removedText = \"\";\n            if (!isSingleText && !startVoid) {\n                var _point = startRef.current;\n                var _Editor$leaf = Editor.leaf(editor, _point), _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1), node = _Editor$leaf2[0];\n                var path = _point.path;\n                var _start = start, offset = _start.offset;\n                var text = node.text.slice(offset);\n                if (text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: path,\n                        offset: offset,\n                        text: text\n                    });\n                    removedText = text;\n                }\n            }\n            pathRefs.reverse().map(function(r) {\n                return r.unref();\n            }).filter(function(r) {\n                return r !== null;\n            }).forEach(function(p) {\n                return Transforms.removeNodes(editor, {\n                    at: p,\n                    voids: voids\n                });\n            });\n            if (!endVoid) {\n                var _point2 = endRef.current;\n                var _Editor$leaf3 = Editor.leaf(editor, _point2), _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1), _node = _Editor$leaf4[0];\n                var _path = _point2.path;\n                var _offset = isSingleText ? start.offset : 0;\n                var _text = _node.text.slice(_offset, end.offset);\n                if (_text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: _path,\n                        offset: _offset,\n                        text: _text\n                    });\n                    removedText = _text;\n                }\n            }\n            if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n                Transforms.mergeNodes(editor, {\n                    at: endRef.current,\n                    hanging: true,\n                    voids: voids\n                });\n            } // For Thai script, deleting N character(s) backward should delete\n            // N code point(s) instead of an entire grapheme cluster.\n            // Therefore, the remaining code points should be inserted back.\n            if (isCollapsed && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n                Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n            }\n            var startUnref = startRef.unref();\n            var endUnref = endRef.unref();\n            var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n            if (options.at == null && point) {\n                Transforms.select(editor, point);\n            }\n        });\n    },\n    /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */ insertFragment: function insertFragment(editor, fragment) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$hanging2 = options.hanging, hanging = _options$hanging2 === void 0 ? false : _options$hanging2, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n            var _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2;\n            if (!fragment.length) {\n                return;\n            }\n            if (!at) {\n                return;\n            } else if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids: voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var _Range$edges5 = Range.edges(at), _Range$edges6 = _slicedToArray(_Range$edges5, 2), end = _Range$edges6[1];\n                    if (!voids && Editor[\"void\"](editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at\n                    });\n                    at = pointRef.unref();\n                }\n            } else if (Path.isPath(at)) {\n                at = Editor.start(editor, at);\n            }\n            if (!voids && Editor[\"void\"](editor, {\n                at: at\n            })) {\n                return;\n            } // If the insert point is at the edge of an inline node, move it outside\n            // instead since it will need to be split otherwise.\n            var inlineElementMatch = Editor.above(editor, {\n                at: at,\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            });\n            if (inlineElementMatch) {\n                var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2), _inlinePath = _inlineElementMatch[1];\n                if (Editor.isEnd(editor, at, _inlinePath)) {\n                    var after = Editor.after(editor, _inlinePath);\n                    at = after;\n                } else if (Editor.isStart(editor, at, _inlinePath)) {\n                    var before = Editor.before(editor, _inlinePath);\n                    at = before;\n                }\n            }\n            var blockMatch = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                at: at,\n                voids: voids\n            });\n            var _blockMatch = _slicedToArray(blockMatch, 2), blockPath = _blockMatch[1];\n            var isBlockStart = Editor.isStart(editor, at, blockPath);\n            var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n            var isBlockEmpty = isBlockStart && isBlockEnd;\n            var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n            var mergeEnd = !isBlockEnd;\n            var _Node$first = Node.first({\n                children: fragment\n            }, []), _Node$first2 = _slicedToArray(_Node$first, 2), firstPath = _Node$first2[1];\n            var _Node$last = Node.last({\n                children: fragment\n            }, []), _Node$last2 = _slicedToArray(_Node$last, 2), lastPath = _Node$last2[1];\n            var matches = [];\n            var matcher = function matcher(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2), n = _ref4[0], p = _ref4[1];\n                var isRoot = p.length === 0;\n                if (isRoot) {\n                    return false;\n                }\n                if (isBlockEmpty) {\n                    return true;\n                }\n                if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                return true;\n            };\n            var _iterator2 = _createForOfIteratorHelper(Node.nodes({\n                children: fragment\n            }, {\n                pass: matcher\n            })), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var entry = _step2.value;\n                    if (matcher(entry)) {\n                        matches.push(entry);\n                    }\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            var starts = [];\n            var middles = [];\n            var ends = [];\n            var starting = true;\n            var hasBlocks = false;\n            for(var _i = 0, _matches = matches; _i < _matches.length; _i++){\n                var _matches$_i = _slicedToArray(_matches[_i], 1), node = _matches$_i[0];\n                if (Element.isElement(node) && !editor.isInline(node)) {\n                    starting = false;\n                    hasBlocks = true;\n                    middles.push(node);\n                } else if (starting) {\n                    starts.push(node);\n                } else {\n                    ends.push(node);\n                }\n            }\n            var _Editor$nodes = Editor.nodes(editor, {\n                at: at,\n                match: function match(n) {\n                    return Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), inlineMatch = _Editor$nodes2[0];\n            var _inlineMatch = _slicedToArray(inlineMatch, 2), inlinePath = _inlineMatch[1];\n            var isInlineStart = Editor.isStart(editor, at, inlinePath);\n            var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n            var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n            var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.splitNodes(editor, {\n                at: at,\n                match: function match(n) {\n                    return hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: hasBlocks ? \"lowest\" : \"highest\",\n                always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n                voids: voids\n            });\n            var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.insertNodes(editor, starts, {\n                at: startRef.current,\n                match: function match(n) {\n                    return Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            });\n            if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n                Transforms[\"delete\"](editor, {\n                    at: blockPath,\n                    voids: voids\n                });\n            }\n            Transforms.insertNodes(editor, middles, {\n                at: middleRef.current,\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                mode: \"lowest\",\n                voids: voids\n            });\n            Transforms.insertNodes(editor, ends, {\n                at: endRef.current,\n                match: function match(n) {\n                    return Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            });\n            if (!options.at) {\n                var path;\n                if (ends.length > 0 && endRef.current) {\n                    path = Path.previous(endRef.current);\n                } else if (middles.length > 0 && middleRef.current) {\n                    path = Path.previous(middleRef.current);\n                } else if (startRef.current) {\n                    path = Path.previous(startRef.current);\n                }\n                if (path) {\n                    var _end2 = Editor.end(editor, path);\n                    Transforms.select(editor, _end2);\n                }\n            }\n            startRef.unref();\n            middleRef.unref();\n            endRef.unref();\n        });\n    },\n    /**\r\n   * Insert a string of text in the Editor.\r\n   */ insertText: function insertText(editor, text) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3;\n            var _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3;\n            if (!at) {\n                return;\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var end = Range.end(at);\n                    if (!voids && Editor[\"void\"](editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var start = Range.start(at);\n                    var startRef = Editor.pointRef(editor, start);\n                    var endRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at,\n                        voids: voids\n                    });\n                    var startPoint = startRef.unref();\n                    var endPoint = endRef.unref();\n                    at = startPoint || endPoint;\n                    Transforms.setSelection(editor, {\n                        anchor: at,\n                        focus: at\n                    });\n                }\n            }\n            if (!voids && Editor[\"void\"](editor, {\n                at: at\n            })) {\n                return;\n            }\n            var _at = at, path = _at.path, offset = _at.offset;\n            if (text.length > 0) editor.apply({\n                type: \"insert_text\",\n                path: path,\n                offset: offset,\n                text: text\n            });\n        });\n    }\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\nexports.Editor = Editor;\nexports.Element = Element;\nexports.Location = Location;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Path = Path;\nexports.PathRef = PathRef;\nexports.Point = Point;\nexports.PointRef = PointRef;\nexports.Range = Range;\nexports.RangeRef = RangeRef;\nexports.Scrubber = Scrubber;\nexports.Span = Span;\nexports.Text = Text;\nexports.Transforms = Transforms;\nexports.createEditor = createEditor; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBRXBCLFNBQVNFLGNBQWVDLENBQUM7SUFDeEIsT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxJQUFJVCxPQUFPVSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixHQUFHLGFBQWFBLENBQUMsQ0FBQyxVQUFVLEdBQUdBO0FBQ2pHO0FBRUEsU0FBU0sscUJBQXFCQyxFQUFFLEVBQUVDLE1BQU07SUFDdkMsT0FBT0EsU0FBUztRQUFFYixTQUFTLENBQUM7SUFBRSxHQUFHWSxHQUFHQyxRQUFRQSxPQUFPYixPQUFPLEdBQUdhLE9BQU9iLE9BQU87QUFDNUU7QUFFQSxJQUFJYyxtQkFBbUJILHFCQUFxQixTQUFVRSxNQUFNO0lBQzVELFNBQVNFLGtCQUFrQkMsR0FBRyxFQUFFQyxHQUFHO1FBQ2pDLElBQUlBLE9BQU8sUUFBUUEsTUFBTUQsSUFBSUUsTUFBTSxFQUFFRCxNQUFNRCxJQUFJRSxNQUFNO1FBRXJELElBQUssSUFBSUMsSUFBSSxHQUFHQyxPQUFPLElBQUlDLE1BQU1KLE1BQU1FLElBQUlGLEtBQUtFLElBQUs7WUFDbkRDLElBQUksQ0FBQ0QsRUFBRSxHQUFHSCxHQUFHLENBQUNHLEVBQUU7UUFDbEI7UUFFQSxPQUFPQztJQUNUO0lBRUFQLE9BQU9iLE9BQU8sR0FBR2U7SUFDakJGLE9BQU9iLE9BQU8sQ0FBQyxVQUFVLEdBQUdhLE9BQU9iLE9BQU8sRUFBRWEsT0FBT2IsT0FBTyxDQUFDTyxVQUFVLEdBQUc7QUFDeEU7QUFFQUYsY0FBY1M7QUFFZCxJQUFJUSxvQkFBb0JYLHFCQUFxQixTQUFVRSxNQUFNO0lBQzdELFNBQVNVLG1CQUFtQlAsR0FBRztRQUM3QixJ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TUMsT0FBTyxDQUFDLFNBQVU1QyxHQUFHO2dCQUFJRixnQkFBZ0IyQyxRQUFRekMsS0FBSzJDLE1BQU0sQ0FBQzNDLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSWxELE9BQU8rRix5QkFBeUIsRUFBRTtZQUFFL0YsT0FBT2dHLGdCQUFnQixDQUFDTCxRQUFRM0YsT0FBTytGLHlCQUF5QixDQUFDRjtRQUFVLE9BQU87WUFBRXV5QixRQUFRcDRCLE9BQU82RixTQUFTQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlsRCxPQUFPQyxjQUFjLENBQUMwRixRQUFRekMsS0FBS2xELE9BQU93Rix3QkFBd0IsQ0FBQ0ssUUFBUTNDO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT3lDO0FBQVE7QUFDcmhCLElBQUlvRSxhQUFhc3VCLGNBQWNBLGNBQWNBLGNBQWNBLGNBQWMsQ0FBQyxHQUFHdkssb0JBQW9CVyxpQkFBaUJpRyxzQkFBc0JZO0FBRXhJcDFCLGNBQWMsR0FBR3dIO0FBQ2pCeEgsZUFBZSxHQUFHZ047QUFDbEJoTixnQkFBZ0IsR0FBR3lpQjtBQUNuQnppQixZQUFZLEdBQUdrTTtBQUNmbE0saUJBQWlCLEdBQUcyWjtBQUNwQjNaLFlBQVksR0FBR2tKO0FBQ2ZsSixlQUFlLEdBQUc0SDtBQUNsQjVILGFBQWEsR0FBRzhaO0FBQ2hCOVosZ0JBQWdCLEdBQUdrSTtBQUNuQmxJLGFBQWEsR0FBRzhLO0FBQ2hCOUssZ0JBQWdCLEdBQUd1STtBQUNuQnZJLGdCQUFnQixHQUFHa2pCO0FBQ25CbGpCLFlBQVksR0FBRzZjO0FBQ2Y3YyxZQUFZLEdBQUd1SztBQUNmdkssa0JBQWtCLEdBQUc2SjtBQUNyQjdKLG9CQUFvQixHQUFHNEcsY0FDdkIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBheWxvYWRjbXMvdGVtcGxhdGUtZWNvbW1lcmNlLy4vbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguanM/YTY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG52YXIgaW1tZXIgPSByZXF1aXJlKCdpbW1lcicpO1xuXG5mdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgYXJyYXlMaWtlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5TGlrZVRvQXJyYXkpO1xuXG52YXIgYXJyYXlXaXRob3V0SG9sZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlXaXRob3V0SG9sZXMpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhpdGVyYWJsZVRvQXJyYXkpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhub25JdGVyYWJsZVNwcmVhZCk7XG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5ID0gdW53cmFwRXhwb3J0cyh0b0NvbnN1bWFibGVBcnJheSk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gdW53cmFwRXhwb3J0cyhkZWZpbmVQcm9wZXJ0eSk7XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhpdGVyYWJsZVRvQXJyYXlMaW1pdCk7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhub25JdGVyYWJsZVJlc3QpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gdW53cmFwRXhwb3J0cyhzbGljZWRUb0FycmF5KTtcblxudmFyIERJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBESVJUWV9QQVRIX0tFWVMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEZMVVNISU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT1JNQUxJWklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUEFUSF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0lOVF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSQU5HRV9SRUZTID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gb3duS2V5cyQ5KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ5KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDkoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDcoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cclxuICovXG5cbnZhciBjcmVhdGVFZGl0b3IgPSBmdW5jdGlvbiBjcmVhdGVFZGl0b3IoKSB7XG4gIHZhciBlZGl0b3IgPSB7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgIHNlbGVjdGlvbjogbnVsbCxcbiAgICBtYXJrczogbnVsbCxcbiAgICBpc0lubGluZTogZnVuY3Rpb24gaXNJbmxpbmUoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc1ZvaWQ6IGZ1bmN0aW9uIGlzVm9pZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG1hcmthYmxlVm9pZDogZnVuY3Rpb24gbWFya2FibGVWb2lkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge30sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KG9wKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhFZGl0b3IucGF0aFJlZnMoZWRpdG9yKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHJlZiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIFBhdGhSZWYudHJhbnNmb3JtKHJlZiwgb3ApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhFZGl0b3IucG9pbnRSZWZzKGVkaXRvcikpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBQb2ludFJlZi50cmFuc2Zvcm0oX3JlZiwgb3ApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKSksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGREaXJ0eVBhdGhzID0gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gICAgICB2YXIgb2xkRGlydHlQYXRoS2V5cyA9IERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gICAgICB2YXIgZGlydHlQYXRocztcbiAgICAgIHZhciBkaXJ0eVBhdGhLZXlzO1xuXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG5cbiAgICAgICAgICBpZiAoIWRpcnR5UGF0aEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGRpcnR5UGF0aEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSkge1xuICAgICAgICBkaXJ0eVBhdGhzID0gW107XG4gICAgICAgIGRpcnR5UGF0aEtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KG9sZERpcnR5UGF0aHMpLFxuICAgICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgICBhZGQobmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlydHlQYXRocyA9IG9sZERpcnR5UGF0aHM7XG4gICAgICAgIGRpcnR5UGF0aEtleXMgPSBvbGREaXJ0eVBhdGhLZXlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RGlydHlQYXRocyA9IGVkaXRvci5nZXREaXJ0eVBhdGhzKG9wKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KG5ld0RpcnR5UGF0aHMpLFxuICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3BhdGggPSBfc3RlcDUudmFsdWU7XG4gICAgICAgICAgYWRkKF9wYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG5cbiAgICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGRpcnR5UGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGRpcnR5UGF0aEtleXMpO1xuICAgICAgVHJhbnNmb3Jtcy50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yLCB7XG4gICAgICAgIG9wZXJhdGlvbjogb3BcbiAgICAgIH0pOyAvLyBDbGVhciBhbnkgZm9ybWF0cyBhcHBsaWVkIHRvIHRoZSBjdXJzb3IgaWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuXG4gICAgICBpZiAob3AudHlwZSA9PT0gJ3NldF9zZWxlY3Rpb24nKSB7XG4gICAgICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBlZGl0b3Iub25DaGFuZ2Uoe1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFyazogZnVuY3Rpb24gYWRkTWFyayhrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgICBlZGl0b3IubWFya2FibGVWb2lkO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG5vZGUsIHBhdGgpIHtcbiAgICAgICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfRWRpdG9yJHBhcmVudCA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDIpLFxuICAgICAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQyWzBdO1xuICAgICAgICAgICAgICBfRWRpdG9yJHBhcmVudDJbMV07XG5cbiAgICAgICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgICAgIHZhciBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfRWRpdG9yJG5vZGUgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiksXG4gICAgICAgICAgICAgIF9FZGl0b3Ikbm9kZTIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUsIDIpLFxuICAgICAgICAgICAgICBzZWxlY3RlZE5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdLFxuICAgICAgICAgICAgICBzZWxlY3RlZFBhdGggPSBfRWRpdG9yJG5vZGUyWzFdO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBfRWRpdG9yJHBhcmVudDMgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKSxcbiAgICAgICAgICAgICAgICBfRWRpdG9yJHBhcmVudDQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudDMsIDEpLFxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBfRWRpdG9yJHBhcmVudDRbMF07XG5cbiAgICAgICAgICAgIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBwYXJlbnROb2RlICYmIGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKSwge1xuICAgICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSkpO1xuXG4gICAgICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG5cbiAgICAgICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZUJhY2t3YXJkOiBmdW5jdGlvbiBkZWxldGVCYWNrd2FyZCh1bml0KSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRm9yd2FyZDogZnVuY3Rpb24gZGVsZXRlRm9yd2FyZCh1bml0KSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgdW5pdDogdW5pdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZUZyYWdtZW50OiBmdW5jdGlvbiBkZWxldGVGcmFnbWVudChkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgIHJldmVyc2U6IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbiBnZXRGcmFnbWVudCgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgaW5zZXJ0QnJlYWs6IGZ1bmN0aW9uIGluc2VydEJyZWFrKCkge1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5zZXJ0U29mdEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRTb2Z0QnJlYWsoKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnNlcnRGcmFnbWVudDogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlKTtcbiAgICB9LFxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQodGV4dCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgbWFya3MgPSBlZGl0b3IubWFya3M7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBfb2JqZWN0U3ByZWFkJDkoe1xuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0sIG1hcmtzKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3JtYWxpemVOb2RlOiBmdW5jdGlvbiBub3JtYWxpemVOb2RlKGVudHJ5KSB7XG4gICAgICB2YXIgX2VudHJ5ID0gX3NsaWNlZFRvQXJyYXkoZW50cnksIDIpLFxuICAgICAgICAgIG5vZGUgPSBfZW50cnlbMF0sXG4gICAgICAgICAgcGF0aCA9IF9lbnRyeVsxXTsgLy8gVGhlcmUgYXJlIG5vIGNvcmUgbm9ybWFsaXphdGlvbnMgZm9yIHRleHQgbm9kZXMuXG5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRW5zdXJlIHRoYXQgYmxvY2sgYW5kIGlubGluZSBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSB0ZXh0IGNoaWxkLlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICAgICAgYXQ6IHBhdGguY29uY2F0KDApLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBoYXZlIGJsb2NrIG9yIGlubGluZSBjaGlsZHJlbi5cblxuXG4gICAgICB2YXIgc2hvdWxkSGF2ZUlubGluZXMgPSBFZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBmYWxzZSA6IEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkgfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgfHwgZWRpdG9yLmlzSW5saW5lKG5vZGUuY2hpbGRyZW5bMF0pKTsgLy8gU2luY2Ugd2UnbGwgYmUgYXBwbHlpbmcgb3BlcmF0aW9ucyB3aGlsZSBpdGVyYXRpbmcsIGtlZXAgdHJhY2sgb2YgYW5cbiAgICAgIC8vIGluZGV4IHRoYXQgYWNjb3VudHMgZm9yIGFueSBhZGRlZC9yZW1vdmVkIG5vZGVzLlxuXG4gICAgICB2YXIgbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKywgbisrKSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChjdXJyZW50Tm9kZSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgX2NoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgdmFyIHByZXYgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbltuIC0gMV07XG4gICAgICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpc0lubGluZU9yVGV4dCA9IFRleHQuaXNUZXh0KF9jaGlsZCkgfHwgRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSAmJiBlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKTsgLy8gT25seSBhbGxvdyBibG9jayBub2RlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGFuZCBwYXJlbnQgYmxvY2tzXG4gICAgICAgIC8vIHRoYXQgb25seSBjb250YWluIGJsb2NrIG5vZGVzLiBTaW1pbGFybHksIG9ubHkgYWxsb3cgaW5saW5lIG5vZGVzIGluXG4gICAgICAgIC8vIG90aGVyIGlubGluZSBub2Rlcywgb3IgcGFyZW50IGJsb2NrcyB0aGF0IG9ubHkgY29udGFpbiBpbmxpbmVzIGFuZFxuICAgICAgICAvLyB0ZXh0LlxuXG4gICAgICAgIGlmIChpc0lubGluZU9yVGV4dCAhPT0gc2hvdWxkSGF2ZUlubGluZXMpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSkge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gKyAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIHRoYXQgYXJlIGVtcHR5IG9yIG1hdGNoLlxuICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgIGlmIChUZXh0LmVxdWFscyhfY2hpbGQsIHByZXYsIHtcbiAgICAgICAgICAgICAgbG9vc2U6IHRydWVcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuIC0gMSksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBmdW5jdGlvbiByZW1vdmVNYXJrKGtleSkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobm9kZSwgcGF0aCkge1xuICAgICAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50NSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ2ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQ1LCAyKSxcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IF9FZGl0b3IkcGFyZW50NlswXTtcbiAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ2WzFdO1xuXG4gICAgICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgICAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX0VkaXRvciRub2RlMyA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKSxcbiAgICAgICAgICAgICAgX0VkaXRvciRub2RlNCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZTMsIDIpLFxuICAgICAgICAgICAgICBzZWxlY3RlZE5vZGUgPSBfRWRpdG9yJG5vZGU0WzBdLFxuICAgICAgICAgICAgICBzZWxlY3RlZFBhdGggPSBfRWRpdG9yJG5vZGU0WzFdO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBfRWRpdG9yJHBhcmVudDcgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKSxcbiAgICAgICAgICAgICAgICBfRWRpdG9yJHBhcmVudDggPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudDcsIDEpLFxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBfRWRpdG9yJHBhcmVudDhbMF07XG5cbiAgICAgICAgICAgIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBwYXJlbnROb2RlICYmIGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBrZXksIHtcbiAgICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9KTtcblxuICAgICAgICAgIGRlbGV0ZSBtYXJrc1trZXldO1xuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxyXG4gICAgICovXG4gICAgZ2V0RGlydHlQYXRoczogZnVuY3Rpb24gZ2V0RGlydHlQYXRocyhvcCkge1xuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBvcC5wYXRoO1xuICAgICAgICAgICAgcmV0dXJuIFBhdGgubGV2ZWxzKHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBvcC5ub2RlLFxuICAgICAgICAgICAgICAgIF9wYXRoMiA9IG9wLnBhdGg7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgyKTtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICAgICAgICBwID0gX3JlZjRbMV07XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9wYXRoMi5jb25jYXQocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxldmVscyksIF90b0NvbnN1bWFibGVBcnJheShkZXNjZW5kYW50cykpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3BhdGgzID0gb3AucGF0aDtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgzKTtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFuY2VzdG9ycyksIFtwcmV2aW91c1BhdGhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3BhdGg0ID0gb3AucGF0aCxcbiAgICAgICAgICAgICAgICBuZXdQYXRoID0gb3AubmV3UGF0aDtcblxuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9wYXRoNCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2xkQW5jZXN0b3JzID0gW107XG4gICAgICAgICAgICB2YXIgbmV3QW5jZXN0b3JzID0gW107XG5cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhQYXRoLmFuY2VzdG9ycyhfcGF0aDQpKSxcbiAgICAgICAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICAgICAgICBvbGRBbmNlc3RvcnMucHVzaChwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhQYXRoLmFuY2VzdG9ycyhuZXdQYXRoKSksXG4gICAgICAgICAgICAgICAgX3N0ZXA3O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgIHZhciBfYW5jZXN0b3IgPSBfc3RlcDcudmFsdWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3AgPSBQYXRoLnRyYW5zZm9ybShfYW5jZXN0b3IsIG9wKTtcblxuICAgICAgICAgICAgICAgIG5ld0FuY2VzdG9ycy5wdXNoKF9wKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBuZXdBbmNlc3RvcnNbbmV3QW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gbmV3UGF0aFtuZXdQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdFBhdGggPSBuZXdQYXJlbnQuY29uY2F0KG5ld0luZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQob2xkQW5jZXN0b3JzLCBuZXdBbmNlc3RvcnMsIFtyZXN1bHRQYXRoXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3BhdGg1ID0gb3AucGF0aDtcblxuICAgICAgICAgICAgdmFyIF9hbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDUpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KF9hbmNlc3RvcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3BhdGg2ID0gb3AucGF0aDtcblxuICAgICAgICAgICAgdmFyIF9sZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aDYpO1xuXG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQoX3BhdGg2KTtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF9sZXZlbHMpLCBbbmV4dFBhdGhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdWxkTm9ybWFsaXplOiBmdW5jdGlvbiBzaG91bGROb3JtYWxpemUoX3JlZjUpIHtcbiAgICAgIHZhciBpdGVyYXRpb24gPSBfcmVmNS5pdGVyYXRpb24sXG4gICAgICAgICAgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggPSBfcmVmNS5pbml0aWFsRGlydHlQYXRoc0xlbmd0aDtcbiAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggKiA0MjsgLy8gSEFDSzogYmV0dGVyIHdheT9cblxuICAgICAgaWYgKGl0ZXJhdGlvbiA+IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBsZXRlbHkgbm9ybWFsaXplIHRoZSBlZGl0b3IgYWZ0ZXIgXCIuY29uY2F0KG1heEl0ZXJhdGlvbnMsIFwiIGl0ZXJhdGlvbnMhIFRoaXMgaXMgdXN1YWxseSBkdWUgdG8gaW5jb3JyZWN0IG5vcm1hbGl6YXRpb24gbG9naWMgdGhhdCBsZWF2ZXMgYSBub2RlIGluIGFuIGludmFsaWQgc3RhdGUuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UpO1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSB1bndyYXBFeHBvcnRzKG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNihhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gQ2hhcmFjdGVyIChncmFwaGVtZSBjbHVzdGVyKSBib3VuZGFyaWVzIGFyZSBkZXRlcm1pbmVkIGFjY29yZGluZyB0b1xuLy8gdGhlIGRlZmF1bHQgZ3JhcGhlbWUgY2x1c3RlciBib3VuZGFyeSBzcGVjaWZpY2F0aW9uLCBleHRlbmRlZCBncmFwaGVtZSBjbHVzdGVycyB2YXJpYW50WzFdLlxuLy9cbi8vIFJlZmVyZW5jZXM6XG4vL1xuLy8gWzFdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jRGVmYXVsdF9HcmFwaGVtZV9DbHVzdGVyX1RhYmxlXG4vLyBbMl0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0XG4vLyBbM10gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC5odG1sXG4vLyBbNF0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrVGVzdC50eHRcblxuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIGEgc3RyaW5nIG9mIHRleHQuXHJcbiAqL1xudmFyIGdldENoYXJhY3RlckRpc3RhbmNlID0gZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyRGlzdGFuY2Uoc3RyKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBpc0xUUiA9ICFpc1JUTDtcbiAgdmFyIGNvZGVwb2ludHMgPSBpc1JUTCA/IGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIDogc3RyO1xuICB2YXIgbGVmdCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIHJpZ2h0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgZGlzdGFuY2UgPSAwOyAvLyBFdmFsdWF0aW9uIG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIGRlZmVycmVkLlxuXG4gIHZhciBnYjExID0gbnVsbDsgLy8gSXMgR0IxMSBhcHBsaWNhYmxlP1xuXG4gIHZhciBnYjEyT3IxMyA9IG51bGw7IC8vIElzIEdCMTIgb3IgR0IxMyBhcHBsaWNhYmxlP1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KGNvZGVwb2ludHMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9jaGFyID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHZhciBjb2RlID0gX2NoYXIuY29kZVBvaW50QXQoMCk7XG5cbiAgICAgIGlmICghY29kZSkgYnJlYWs7XG4gICAgICB2YXIgdHlwZSA9IGdldENvZGVwb2ludFR5cGUoX2NoYXIsIGNvZGUpO1xuXG4gICAgICB2YXIgX3JlZiA9IGlzTFRSID8gW3JpZ2h0LCB0eXBlXSA6IFt0eXBlLCBsZWZ0XTtcblxuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMik7XG5cbiAgICAgIGxlZnQgPSBfcmVmMlswXTtcbiAgICAgIHJpZ2h0ID0gX3JlZjJbMV07XG5cbiAgICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuWldKKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLkV4dFBpY3QpKSB7XG4gICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgZGlzdGFuY2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFnYjExKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5SSSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5SSSkpIHtcbiAgICAgICAgaWYgKGdiMTJPcjEzICE9PSBudWxsKSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSAhZ2IxMk9yMTM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgICAgICBnYjEyT3IxMyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdiMTJPcjEzID0gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZ2IxMk9yMTMpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVmdCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIHJpZ2h0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZSArPSBfY2hhci5sZW5ndGg7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2UgfHwgMTtcbn07XG52YXIgU1BBQ0UgPSAvXFxzLztcbnZhciBQVU5DVFVBVElPTiA9IC9bXFx1MDAyMS1cXHUwMDIzXFx1MDAyNS1cXHUwMDJBXFx1MDAyQy1cXHUwMDJGXFx1MDAzQVxcdTAwM0JcXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RFxcdTAwNUZcXHUwMDdCXFx1MDA3RFxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkUzQlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vO1xudmFyIENIQU1FTEVPTiA9IC9bJ1xcdTIwMThcXHUyMDE5XS87XG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCB3b3JkIGluIGEgc3RyaW5nIG9mIHRleHQuXHJcbiAqL1xuXG52YXIgZ2V0V29yZERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0V29yZERpc3RhbmNlKHRleHQpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGRpc3QgPSAwO1xuICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuXG4gIHdoaWxlICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBpc1JUTCk7XG5cbiAgICB2YXIgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHRleHQsIGNoYXJEaXN0LCBpc1JUTCksXG4gICAgICAgIF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDIgPSBfc2xpY2VkVG9BcnJheShfc3BsaXRCeUNoYXJhY3RlckRpc3QsIDIpLFxuICAgICAgICBfY2hhcjIgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3QyWzBdLFxuICAgICAgICByZW1haW5pbmcgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3QyWzFdO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihfY2hhcjIsIHJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGV4dCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIHJldHVybiBkaXN0O1xufTtcbi8qKlxyXG4gKiBTcGxpdCBhIHN0cmluZyBpbiB0d28gcGFydHMgYXQgYSBnaXZlbiBkaXN0YW5jZSBzdGFydGluZyBmcm9tIHRoZSBlbmQgd2hlblxyXG4gKiBgaXNSVExgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAqL1xuXG52YXIgc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlID0gZnVuY3Rpb24gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHN0ciwgZGlzdCwgaXNSVEwpIHtcbiAgaWYgKGlzUlRMKSB7XG4gICAgdmFyIGF0ID0gc3RyLmxlbmd0aCAtIGRpc3Q7XG4gICAgcmV0dXJuIFtzdHIuc2xpY2UoYXQsIHN0ci5sZW5ndGgpLCBzdHIuc2xpY2UoMCwgYXQpXTtcbiAgfVxuXG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGRpc3QpLCBzdHIuc2xpY2UoZGlzdCldO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGNoYXJhY3RlciBpcyBhIHdvcmQgY2hhcmFjdGVyLiBUaGUgYHJlbWFpbmluZ2AgYXJndW1lbnQgaXMgdXNlZFxyXG4gKiBiZWNhdXNlIHNvbWV0aW1lcyB5b3UgbXVzdCByZWFkIHN1YnNlcXVlbnQgY2hhcmFjdGVycyB0byB0cnVseSBkZXRlcm1pbmUgaXQuXHJcbiAqL1xuXG52YXIgaXNXb3JkQ2hhcmFjdGVyID0gZnVuY3Rpb24gaXNXb3JkQ2hhcmFjdGVyKF9jaGFyMywgcmVtYWluaW5nKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgaWYgKFNQQUNFLnRlc3QoX2NoYXIzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBDaGFtZWxlb25zIGNvdW50IGFzIHdvcmQgY2hhcmFjdGVycyBhcyBsb25nIGFzIHRoZXkncmUgaW4gYSB3b3JkLCBzb1xuICAvLyByZWN1cnNlIHRvIHNlZSBpZiB0aGUgbmV4dCBvbmUgaXMgYSB3b3JkIGNoYXJhY3RlciBvciBub3QuXG5cblxuICBpZiAoQ0hBTUVMRU9OLnRlc3QoX2NoYXIzKSkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgaXNSVEwpO1xuXG4gICAgdmFyIF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDMgPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBjaGFyRGlzdCwgaXNSVEwpLFxuICAgICAgICBfc3BsaXRCeUNoYXJhY3RlckRpc3Q0ID0gX3NsaWNlZFRvQXJyYXkoX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MywgMiksXG4gICAgICAgIG5leHRDaGFyID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0NFswXSxcbiAgICAgICAgbmV4dFJlbWFpbmluZyA9IF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDRbMV07XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKG5leHRDaGFyLCBuZXh0UmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChQVU5DVFVBVElPTi50ZXN0KF9jaGFyMykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcclxuICogSXRlcmF0ZSBvbiBjb2RlcG9pbnRzIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICovXG5cblxudmFyIGNvZGVwb2ludHNJdGVyYXRvclJUTCA9IGZ1bmN0aW9uKiBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSB7XG4gIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyMSA9IHN0ci5jaGFyQXQoZW5kIC0gaSk7XG5cbiAgICBpZiAoaXNMb3dTdXJyb2dhdGUoY2hhcjEuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHZhciBjaGFyMiA9IHN0ci5jaGFyQXQoZW5kIC0gaSAtIDEpO1xuXG4gICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXIyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHlpZWxkIGNoYXIyICsgY2hhcjE7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeWllbGQgY2hhcjE7XG4gIH1cbn07XG4vKipcclxuICogSXMgYGNoYXJDb2RlYCBhIGhpZ2ggc3Vycm9nYXRlLlxyXG4gKlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcclxuICovXG5cbnZhciBpc0hpZ2hTdXJyb2dhdGUgPSBmdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZDgwMCAmJiBjaGFyQ29kZSA8PSAweGRiZmY7XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBsb3cgc3Vycm9nYXRlLlxyXG4gKlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcclxuICovXG5cblxudmFyIGlzTG93U3Vycm9nYXRlID0gZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZGMwMCAmJiBjaGFyQ29kZSA8PSAweGRmZmY7XG59O1xuXG52YXIgQ29kZXBvaW50VHlwZTtcblxuKGZ1bmN0aW9uIChDb2RlcG9pbnRUeXBlKSB7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRlbmRcIl0gPSAxXSA9IFwiRXh0ZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlpXSlwiXSA9IDJdID0gXCJaV0pcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUklcIl0gPSA0XSA9IFwiUklcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiUHJlcGVuZFwiXSA9IDhdID0gXCJQcmVwZW5kXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlNwYWNpbmdNYXJrXCJdID0gMTZdID0gXCJTcGFjaW5nTWFya1wiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMXCJdID0gMzJdID0gXCJMXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlZcIl0gPSA2NF0gPSBcIlZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVFwiXSA9IDEyOF0gPSBcIlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZcIl0gPSAyNTZdID0gXCJMVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlRcIl0gPSA1MTJdID0gXCJMVlRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0UGljdFwiXSA9IDEwMjRdID0gXCJFeHRQaWN0XCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkFueVwiXSA9IDIwNDhdID0gXCJBbnlcIjtcbn0pKENvZGVwb2ludFR5cGUgfHwgKENvZGVwb2ludFR5cGUgPSB7fSkpO1xuXG52YXIgcmVFeHRlbmQgPSAvXig/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDMFxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REY0Ni1cXHVERjUwXXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMzAtXFx1REQzNlxcdURFRUMtXFx1REVFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pJC87XG52YXIgcmVQcmVwZW5kID0gL14oPzpbXFx1MDYwMC1cXHUwNjA1XFx1MDZERFxcdTA3MEZcXHUwODkwXFx1MDg5MVxcdTA4RTJcXHUwRDRFXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXFx1RERDMlxcdUREQzNdfFxcdUQ4MDZbXFx1REQzRlxcdURENDFcXHVERTNBXFx1REU4NC1cXHVERTg5XXxcXHVEODA3XFx1REQ0NikkLztcbnZhciByZVNwYWNpbmdNYXJrID0gL14oPzpbXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRlxcdTA5QzBcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MEEwM1xcdTBBM0UtXFx1MEE0MFxcdTBBODNcXHUwQUJFLVxcdTBBQzBcXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQjAyXFx1MEIwM1xcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEJCRlxcdTBCQzFcXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMFxcdTBDQzFcXHUwQ0MzXFx1MENDNFxcdTBDQzdcXHUwQ0M4XFx1MENDQVxcdTBDQ0JcXHUwRDAyXFx1MEQwM1xcdTBEM0ZcXHUwRDQwXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ4MlxcdTBEODNcXHUwREQwXFx1MEREMVxcdTBERDgtXFx1MERERVxcdTBERjJcXHUwREYzXFx1MEUzM1xcdTBFQjNcXHUwRjNFXFx1MEYzRlxcdTBGN0ZcXHUxMDMxXFx1MTAzQlxcdTEwM0NcXHUxMDU2XFx1MTA1N1xcdTEwODRcXHUxNzE1XFx1MTczNFxcdTE3QjZcXHUxN0JFLVxcdTE3QzVcXHUxN0M3XFx1MTdDOFxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzBcXHUxOTMxXFx1MTkzMy1cXHUxOTM4XFx1MUExOVxcdTFBMUFcXHUxQTU1XFx1MUE1N1xcdTFBNkQtXFx1MUE3MlxcdTFCMDRcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0Y3XFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRS1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQUVCXFx1QUFFRVxcdUFBRUZcXHVBQUY1XFx1QUJFM1xcdUFCRTRcXHVBQkU2XFx1QUJFN1xcdUFCRTlcXHVBQkVBXFx1QUJFQ118XFx1RDgwNFtcXHVEQzAwXFx1REMwMlxcdURDODJcXHVEQ0IwLVxcdURDQjJcXHVEQ0I3XFx1RENCOFxcdUREMkNcXHVERDQ1XFx1REQ0NlxcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdUREQ0VcXHVERTJDLVxcdURFMkVcXHVERTMyXFx1REUzM1xcdURFMzVcXHVERUUwLVxcdURFRTJcXHVERjAyXFx1REYwM1xcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNjJcXHVERjYzXXxcXHVEODA1W1xcdURDMzUtXFx1REMzN1xcdURDNDBcXHVEQzQxXFx1REM0NVxcdURDQjFcXHVEQ0IyXFx1RENCOVxcdURDQkJcXHVEQ0JDXFx1RENCRVxcdURDQzFcXHVEREIwXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyNl18XFx1RDgwNltcXHVEQzJDLVxcdURDMkVcXHVEQzM4XFx1REQzMS1cXHVERDM1XFx1REQzN1xcdUREMzhcXHVERDNEXFx1REQ0MFxcdURENDJcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREZcXHVEREU0XFx1REUzOVxcdURFNTdcXHVERTU4XFx1REU5N118XFx1RDgwN1tcXHVEQzJGXFx1REMzRVxcdURDQTlcXHVEQ0IxXFx1RENCNFxcdUREOEEtXFx1REQ4RVxcdUREOTNcXHVERDk0XFx1REQ5NlxcdURFRjVcXHVERUY2XXxcXHVEODFCW1xcdURGNTEtXFx1REY4N1xcdURGRjBcXHVERkYxXXxcXHVEODM0W1xcdURENjZcXHVERDZEXSkkLztcbnZhciByZUwgPSAvXltcXHUxMTAwLVxcdTExNUZcXHVBOTYwLVxcdUE5N0NdJC87XG52YXIgcmVWID0gL15bXFx1MTE2MC1cXHUxMUE3XFx1RDdCMC1cXHVEN0M2XSQvO1xudmFyIHJlVCA9IC9eW1xcdTExQTgtXFx1MTFGRlxcdUQ3Q0ItXFx1RDdGQl0kLztcbnZhciByZUxWID0gL15bXFx1QUMwMFxcdUFDMUNcXHVBQzM4XFx1QUM1NFxcdUFDNzBcXHVBQzhDXFx1QUNBOFxcdUFDQzRcXHVBQ0UwXFx1QUNGQ1xcdUFEMThcXHVBRDM0XFx1QUQ1MFxcdUFENkNcXHVBRDg4XFx1QURBNFxcdUFEQzBcXHVBRERDXFx1QURGOFxcdUFFMTRcXHVBRTMwXFx1QUU0Q1xcdUFFNjhcXHVBRTg0XFx1QUVBMFxcdUFFQkNcXHVBRUQ4XFx1QUVGNFxcdUFGMTBcXHVBRjJDXFx1QUY0OFxcdUFGNjRcXHVBRjgwXFx1QUY5Q1xcdUFGQjhcXHVBRkQ0XFx1QUZGMFxcdUIwMENcXHVCMDI4XFx1QjA0NFxcdUIwNjBcXHVCMDdDXFx1QjA5OFxcdUIwQjRcXHVCMEQwXFx1QjBFQ1xcdUIxMDhcXHVCMTI0XFx1QjE0MFxcdUIxNUNcXHVCMTc4XFx1QjE5NFxcdUIxQjBcXHVCMUNDXFx1QjFFOFxcdUIyMDRcXHVCMjIwXFx1QjIzQ1xcdUIyNThcXHVCMjc0XFx1QjI5MFxcdUIyQUNcXHVCMkM4XFx1QjJFNFxcdUIzMDBcXHVCMzFDXFx1QjMzOFxcdUIzNTRcXHVCMzcwXFx1QjM4Q1xcdUIzQThcXHVCM0M0XFx1QjNFMFxcdUIzRkNcXHVCNDE4XFx1QjQzNFxcdUI0NTBcXHVCNDZDXFx1QjQ4OFxcdUI0QTRcXHVCNEMwXFx1QjREQ1xcdUI0RjhcXHVCNTE0XFx1QjUzMFxcdUI1NENcXHVCNTY4XFx1QjU4NFxcdUI1QTBcXHVCNUJDXFx1QjVEOFxcdUI1RjRcXHVCNjEwXFx1QjYyQ1xcdUI2NDhcXHVCNjY0XFx1QjY4MFxcdUI2OUNcXHVCNkI4XFx1QjZENFxcdUI2RjBcXHVCNzBDXFx1QjcyOFxcdUI3NDRcXHVCNzYwXFx1Qjc3Q1xcdUI3OThcXHVCN0I0XFx1QjdEMFxcdUI3RUNcXHVCODA4XFx1QjgyNFxcdUI4NDBcXHVCODVDXFx1Qjg3OFxcdUI4OTRcXHVCOEIwXFx1QjhDQ1xcdUI4RThcXHVCOTA0XFx1QjkyMFxcdUI5M0NcXHVCOTU4XFx1Qjk3NFxcdUI5OTBcXHVCOUFDXFx1QjlDOFxcdUI5RTRcXHVCQTAwXFx1QkExQ1xcdUJBMzhcXHVCQTU0XFx1QkE3MFxcdUJBOENcXHVCQUE4XFx1QkFDNFxcdUJBRTBcXHVCQUZDXFx1QkIxOFxcdUJCMzRcXHVCQjUwXFx1QkI2Q1xcdUJCODhcXHVCQkE0XFx1QkJDMFxcdUJCRENcXHVCQkY4XFx1QkMxNFxcdUJDMzBcXHVCQzRDXFx1QkM2OFxcdUJDODRcXHVCQ0EwXFx1QkNCQ1xcdUJDRDhcXHVCQ0Y0XFx1QkQxMFxcdUJEMkNcXHVCRDQ4XFx1QkQ2NFxcdUJEODBcXHVCRDlDXFx1QkRCOFxcdUJERDRcXHVCREYwXFx1QkUwQ1xcdUJFMjhcXHVCRTQ0XFx1QkU2MFxcdUJFN0NcXHVCRTk4XFx1QkVCNFxcdUJFRDBcXHVCRUVDXFx1QkYwOFxcdUJGMjRcXHVCRjQwXFx1QkY1Q1xcdUJGNzhcXHVCRjk0XFx1QkZCMFxcdUJGQ0NcXHVCRkU4XFx1QzAwNFxcdUMwMjBcXHVDMDNDXFx1QzA1OFxcdUMwNzRcXHVDMDkwXFx1QzBBQ1xcdUMwQzhcXHVDMEU0XFx1QzEwMFxcdUMxMUNcXHVDMTM4XFx1QzE1NFxcdUMxNzBcXHVDMThDXFx1QzFBOFxcdUMxQzRcXHVDMUUwXFx1QzFGQ1xcdUMyMThcXHVDMjM0XFx1QzI1MFxcdUMyNkNcXHVDMjg4XFx1QzJBNFxcdUMyQzBcXHVDMkRDXFx1QzJGOFxcdUMzMTRcXHVDMzMwXFx1QzM0Q1xcdUMzNjhcXHVDMzg0XFx1QzNBMFxcdUMzQkNcXHVDM0Q4XFx1QzNGNFxcdUM0MTBcXHVDNDJDXFx1QzQ0OFxcdUM0NjRcXHVDNDgwXFx1QzQ5Q1xcdUM0QjhcXHVDNEQ0XFx1QzRGMFxcdUM1MENcXHVDNTI4XFx1QzU0NFxcdUM1NjBcXHVDNTdDXFx1QzU5OFxcdUM1QjRcXHVDNUQwXFx1QzVFQ1xcdUM2MDhcXHVDNjI0XFx1QzY0MFxcdUM2NUNcXHVDNjc4XFx1QzY5NFxcdUM2QjBcXHVDNkNDXFx1QzZFOFxcdUM3MDRcXHVDNzIwXFx1QzczQ1xcdUM3NThcXHVDNzc0XFx1Qzc5MFxcdUM3QUNcXHVDN0M4XFx1QzdFNFxcdUM4MDBcXHVDODFDXFx1QzgzOFxcdUM4NTRcXHVDODcwXFx1Qzg4Q1xcdUM4QThcXHVDOEM0XFx1QzhFMFxcdUM4RkNcXHVDOTE4XFx1QzkzNFxcdUM5NTBcXHVDOTZDXFx1Qzk4OFxcdUM5QTRcXHVDOUMwXFx1QzlEQ1xcdUM5RjhcXHVDQTE0XFx1Q0EzMFxcdUNBNENcXHVDQTY4XFx1Q0E4NFxcdUNBQTBcXHVDQUJDXFx1Q0FEOFxcdUNBRjRcXHVDQjEwXFx1Q0IyQ1xcdUNCNDhcXHVDQjY0XFx1Q0I4MFxcdUNCOUNcXHVDQkI4XFx1Q0JENFxcdUNCRjBcXHVDQzBDXFx1Q0MyOFxcdUNDNDRcXHVDQzYwXFx1Q0M3Q1xcdUNDOThcXHVDQ0I0XFx1Q0NEMFxcdUNDRUNcXHVDRDA4XFx1Q0QyNFxcdUNENDBcXHVDRDVDXFx1Q0Q3OFxcdUNEOTRcXHVDREIwXFx1Q0RDQ1xcdUNERThcXHVDRTA0XFx1Q0UyMFxcdUNFM0NcXHVDRTU4XFx1Q0U3NFxcdUNFOTBcXHVDRUFDXFx1Q0VDOFxcdUNFRTRcXHVDRjAwXFx1Q0YxQ1xcdUNGMzhcXHVDRjU0XFx1Q0Y3MFxcdUNGOENcXHVDRkE4XFx1Q0ZDNFxcdUNGRTBcXHVDRkZDXFx1RDAxOFxcdUQwMzRcXHVEMDUwXFx1RDA2Q1xcdUQwODhcXHVEMEE0XFx1RDBDMFxcdUQwRENcXHVEMEY4XFx1RDExNFxcdUQxMzBcXHVEMTRDXFx1RDE2OFxcdUQxODRcXHVEMUEwXFx1RDFCQ1xcdUQxRDhcXHVEMUY0XFx1RDIxMFxcdUQyMkNcXHVEMjQ4XFx1RDI2NFxcdUQyODBcXHVEMjlDXFx1RDJCOFxcdUQyRDRcXHVEMkYwXFx1RDMwQ1xcdUQzMjhcXHVEMzQ0XFx1RDM2MFxcdUQzN0NcXHVEMzk4XFx1RDNCNFxcdUQzRDBcXHVEM0VDXFx1RDQwOFxcdUQ0MjRcXHVENDQwXFx1RDQ1Q1xcdUQ0NzhcXHVENDk0XFx1RDRCMFxcdUQ0Q0NcXHVENEU4XFx1RDUwNFxcdUQ1MjBcXHVENTNDXFx1RDU1OFxcdUQ1NzRcXHVENTkwXFx1RDVBQ1xcdUQ1QzhcXHVENUU0XFx1RDYwMFxcdUQ2MUNcXHVENjM4XFx1RDY1NFxcdUQ2NzBcXHVENjhDXFx1RDZBOFxcdUQ2QzRcXHVENkUwXFx1RDZGQ1xcdUQ3MThcXHVENzM0XFx1RDc1MFxcdUQ3NkNcXHVENzg4XSQvO1xudmFyIHJlTFZUID0gL15bXFx1QUMwMS1cXHVBQzFCXFx1QUMxRC1cXHVBQzM3XFx1QUMzOS1cXHVBQzUzXFx1QUM1NS1cXHVBQzZGXFx1QUM3MS1cXHVBQzhCXFx1QUM4RC1cXHVBQ0E3XFx1QUNBOS1cXHVBQ0MzXFx1QUNDNS1cXHVBQ0RGXFx1QUNFMS1cXHVBQ0ZCXFx1QUNGRC1cXHVBRDE3XFx1QUQxOS1cXHVBRDMzXFx1QUQzNS1cXHVBRDRGXFx1QUQ1MS1cXHVBRDZCXFx1QUQ2RC1cXHVBRDg3XFx1QUQ4OS1cXHVBREEzXFx1QURBNS1cXHVBREJGXFx1QURDMS1cXHVBRERCXFx1QURERC1cXHVBREY3XFx1QURGOS1cXHVBRTEzXFx1QUUxNS1cXHVBRTJGXFx1QUUzMS1cXHVBRTRCXFx1QUU0RC1cXHVBRTY3XFx1QUU2OS1cXHVBRTgzXFx1QUU4NS1cXHVBRTlGXFx1QUVBMS1cXHVBRUJCXFx1QUVCRC1cXHVBRUQ3XFx1QUVEOS1cXHVBRUYzXFx1QUVGNS1cXHVBRjBGXFx1QUYxMS1cXHVBRjJCXFx1QUYyRC1cXHVBRjQ3XFx1QUY0OS1cXHVBRjYzXFx1QUY2NS1cXHVBRjdGXFx1QUY4MS1cXHVBRjlCXFx1QUY5RC1cXHVBRkI3XFx1QUZCOS1cXHVBRkQzXFx1QUZENS1cXHVBRkVGXFx1QUZGMS1cXHVCMDBCXFx1QjAwRC1cXHVCMDI3XFx1QjAyOS1cXHVCMDQzXFx1QjA0NS1cXHVCMDVGXFx1QjA2MS1cXHVCMDdCXFx1QjA3RC1cXHVCMDk3XFx1QjA5OS1cXHVCMEIzXFx1QjBCNS1cXHVCMENGXFx1QjBEMS1cXHVCMEVCXFx1QjBFRC1cXHVCMTA3XFx1QjEwOS1cXHVCMTIzXFx1QjEyNS1cXHVCMTNGXFx1QjE0MS1cXHVCMTVCXFx1QjE1RC1cXHVCMTc3XFx1QjE3OS1cXHVCMTkzXFx1QjE5NS1cXHVCMUFGXFx1QjFCMS1cXHVCMUNCXFx1QjFDRC1cXHVCMUU3XFx1QjFFOS1cXHVCMjAzXFx1QjIwNS1cXHVCMjFGXFx1QjIyMS1cXHVCMjNCXFx1QjIzRC1cXHVCMjU3XFx1QjI1OS1cXHVCMjczXFx1QjI3NS1cXHVCMjhGXFx1QjI5MS1cXHVCMkFCXFx1QjJBRC1cXHVCMkM3XFx1QjJDOS1cXHVCMkUzXFx1QjJFNS1cXHVCMkZGXFx1QjMwMS1cXHVCMzFCXFx1QjMxRC1cXHVCMzM3XFx1QjMzOS1cXHVCMzUzXFx1QjM1NS1cXHVCMzZGXFx1QjM3MS1cXHVCMzhCXFx1QjM4RC1cXHVCM0E3XFx1QjNBOS1cXHVCM0MzXFx1QjNDNS1cXHVCM0RGXFx1QjNFMS1cXHVCM0ZCXFx1QjNGRC1cXHVCNDE3XFx1QjQxOS1cXHVCNDMzXFx1QjQzNS1cXHVCNDRGXFx1QjQ1MS1cXHVCNDZCXFx1QjQ2RC1cXHVCNDg3XFx1QjQ4OS1cXHVCNEEzXFx1QjRBNS1cXHVCNEJGXFx1QjRDMS1cXHVCNERCXFx1QjRERC1cXHVCNEY3XFx1QjRGOS1cXHVCNTEzXFx1QjUxNS1cXHVCNTJGXFx1QjUzMS1cXHVCNTRCXFx1QjU0RC1cXHVCNTY3XFx1QjU2OS1cXHVCNTgzXFx1QjU4NS1cXHVCNTlGXFx1QjVBMS1cXHVCNUJCXFx1QjVCRC1cXHVCNUQ3XFx1QjVEOS1cXHVCNUYzXFx1QjVGNS1cXHVCNjBGXFx1QjYxMS1cXHVCNjJCXFx1QjYyRC1cXHVCNjQ3XFx1QjY0OS1cXHVCNjYzXFx1QjY2NS1cXHVCNjdGXFx1QjY4MS1cXHVCNjlCXFx1QjY5RC1cXHVCNkI3XFx1QjZCOS1cXHVCNkQzXFx1QjZENS1cXHVCNkVGXFx1QjZGMS1cXHVCNzBCXFx1QjcwRC1cXHVCNzI3XFx1QjcyOS1cXHVCNzQzXFx1Qjc0NS1cXHVCNzVGXFx1Qjc2MS1cXHVCNzdCXFx1Qjc3RC1cXHVCNzk3XFx1Qjc5OS1cXHVCN0IzXFx1QjdCNS1cXHVCN0NGXFx1QjdEMS1cXHVCN0VCXFx1QjdFRC1cXHVCODA3XFx1QjgwOS1cXHVCODIzXFx1QjgyNS1cXHVCODNGXFx1Qjg0MS1cXHVCODVCXFx1Qjg1RC1cXHVCODc3XFx1Qjg3OS1cXHVCODkzXFx1Qjg5NS1cXHVCOEFGXFx1QjhCMS1cXHVCOENCXFx1QjhDRC1cXHVCOEU3XFx1QjhFOS1cXHVCOTAzXFx1QjkwNS1cXHVCOTFGXFx1QjkyMS1cXHVCOTNCXFx1QjkzRC1cXHVCOTU3XFx1Qjk1OS1cXHVCOTczXFx1Qjk3NS1cXHVCOThGXFx1Qjk5MS1cXHVCOUFCXFx1QjlBRC1cXHVCOUM3XFx1QjlDOS1cXHVCOUUzXFx1QjlFNS1cXHVCOUZGXFx1QkEwMS1cXHVCQTFCXFx1QkExRC1cXHVCQTM3XFx1QkEzOS1cXHVCQTUzXFx1QkE1NS1cXHVCQTZGXFx1QkE3MS1cXHVCQThCXFx1QkE4RC1cXHVCQUE3XFx1QkFBOS1cXHVCQUMzXFx1QkFDNS1cXHVCQURGXFx1QkFFMS1cXHVCQUZCXFx1QkFGRC1cXHVCQjE3XFx1QkIxOS1cXHVCQjMzXFx1QkIzNS1cXHVCQjRGXFx1QkI1MS1cXHVCQjZCXFx1QkI2RC1cXHVCQjg3XFx1QkI4OS1cXHVCQkEzXFx1QkJBNS1cXHVCQkJGXFx1QkJDMS1cXHVCQkRCXFx1QkJERC1cXHVCQkY3XFx1QkJGOS1cXHVCQzEzXFx1QkMxNS1cXHVCQzJGXFx1QkMzMS1cXHVCQzRCXFx1QkM0RC1cXHVCQzY3XFx1QkM2OS1cXHVCQzgzXFx1QkM4NS1cXHVCQzlGXFx1QkNBMS1cXHVCQ0JCXFx1QkNCRC1cXHVCQ0Q3XFx1QkNEOS1cXHVCQ0YzXFx1QkNGNS1cXHVCRDBGXFx1QkQxMS1cXHVCRDJCXFx1QkQyRC1cXHVCRDQ3XFx1QkQ0OS1cXHVCRDYzXFx1QkQ2NS1cXHVCRDdGXFx1QkQ4MS1cXHVCRDlCXFx1QkQ5RC1cXHVCREI3XFx1QkRCOS1cXHVCREQzXFx1QkRENS1cXHVCREVGXFx1QkRGMS1cXHVCRTBCXFx1QkUwRC1cXHVCRTI3XFx1QkUyOS1cXHVCRTQzXFx1QkU0NS1cXHVCRTVGXFx1QkU2MS1cXHVCRTdCXFx1QkU3RC1cXHVCRTk3XFx1QkU5OS1cXHVCRUIzXFx1QkVCNS1cXHVCRUNGXFx1QkVEMS1cXHVCRUVCXFx1QkVFRC1cXHVCRjA3XFx1QkYwOS1cXHVCRjIzXFx1QkYyNS1cXHVCRjNGXFx1QkY0MS1cXHVCRjVCXFx1QkY1RC1cXHVCRjc3XFx1QkY3OS1cXHVCRjkzXFx1QkY5NS1cXHVCRkFGXFx1QkZCMS1cXHVCRkNCXFx1QkZDRC1cXHVCRkU3XFx1QkZFOS1cXHVDMDAzXFx1QzAwNS1cXHVDMDFGXFx1QzAyMS1cXHVDMDNCXFx1QzAzRC1cXHVDMDU3XFx1QzA1OS1cXHVDMDczXFx1QzA3NS1cXHVDMDhGXFx1QzA5MS1cXHVDMEFCXFx1QzBBRC1cXHVDMEM3XFx1QzBDOS1cXHVDMEUzXFx1QzBFNS1cXHVDMEZGXFx1QzEwMS1cXHVDMTFCXFx1QzExRC1cXHVDMTM3XFx1QzEzOS1cXHVDMTUzXFx1QzE1NS1cXHVDMTZGXFx1QzE3MS1cXHVDMThCXFx1QzE4RC1cXHVDMUE3XFx1QzFBOS1cXHVDMUMzXFx1QzFDNS1cXHVDMURGXFx1QzFFMS1cXHVDMUZCXFx1QzFGRC1cXHVDMjE3XFx1QzIxOS1cXHVDMjMzXFx1QzIzNS1cXHVDMjRGXFx1QzI1MS1cXHVDMjZCXFx1QzI2RC1cXHVDMjg3XFx1QzI4OS1cXHVDMkEzXFx1QzJBNS1cXHVDMkJGXFx1QzJDMS1cXHVDMkRCXFx1QzJERC1cXHVDMkY3XFx1QzJGOS1cXHVDMzEzXFx1QzMxNS1cXHVDMzJGXFx1QzMzMS1cXHVDMzRCXFx1QzM0RC1cXHVDMzY3XFx1QzM2OS1cXHVDMzgzXFx1QzM4NS1cXHVDMzlGXFx1QzNBMS1cXHVDM0JCXFx1QzNCRC1cXHVDM0Q3XFx1QzNEOS1cXHVDM0YzXFx1QzNGNS1cXHVDNDBGXFx1QzQxMS1cXHVDNDJCXFx1QzQyRC1cXHVDNDQ3XFx1QzQ0OS1cXHVDNDYzXFx1QzQ2NS1cXHVDNDdGXFx1QzQ4MS1cXHVDNDlCXFx1QzQ5RC1cXHVDNEI3XFx1QzRCOS1cXHVDNEQzXFx1QzRENS1cXHVDNEVGXFx1QzRGMS1cXHVDNTBCXFx1QzUwRC1cXHVDNTI3XFx1QzUyOS1cXHVDNTQzXFx1QzU0NS1cXHVDNTVGXFx1QzU2MS1cXHVDNTdCXFx1QzU3RC1cXHVDNTk3XFx1QzU5OS1cXHVDNUIzXFx1QzVCNS1cXHVDNUNGXFx1QzVEMS1cXHVDNUVCXFx1QzVFRC1cXHVDNjA3XFx1QzYwOS1cXHVDNjIzXFx1QzYyNS1cXHVDNjNGXFx1QzY0MS1cXHVDNjVCXFx1QzY1RC1cXHVDNjc3XFx1QzY3OS1cXHVDNjkzXFx1QzY5NS1cXHVDNkFGXFx1QzZCMS1cXHVDNkNCXFx1QzZDRC1cXHVDNkU3XFx1QzZFOS1cXHVDNzAzXFx1QzcwNS1cXHVDNzFGXFx1QzcyMS1cXHVDNzNCXFx1QzczRC1cXHVDNzU3XFx1Qzc1OS1cXHVDNzczXFx1Qzc3NS1cXHVDNzhGXFx1Qzc5MS1cXHVDN0FCXFx1QzdBRC1cXHVDN0M3XFx1QzdDOS1cXHVDN0UzXFx1QzdFNS1cXHVDN0ZGXFx1QzgwMS1cXHVDODFCXFx1QzgxRC1cXHVDODM3XFx1QzgzOS1cXHVDODUzXFx1Qzg1NS1cXHVDODZGXFx1Qzg3MS1cXHVDODhCXFx1Qzg4RC1cXHVDOEE3XFx1QzhBOS1cXHVDOEMzXFx1QzhDNS1cXHVDOERGXFx1QzhFMS1cXHVDOEZCXFx1QzhGRC1cXHVDOTE3XFx1QzkxOS1cXHVDOTMzXFx1QzkzNS1cXHVDOTRGXFx1Qzk1MS1cXHVDOTZCXFx1Qzk2RC1cXHVDOTg3XFx1Qzk4OS1cXHVDOUEzXFx1QzlBNS1cXHVDOUJGXFx1QzlDMS1cXHVDOURCXFx1QzlERC1cXHVDOUY3XFx1QzlGOS1cXHVDQTEzXFx1Q0ExNS1cXHVDQTJGXFx1Q0EzMS1cXHVDQTRCXFx1Q0E0RC1cXHVDQTY3XFx1Q0E2OS1cXHVDQTgzXFx1Q0E4NS1cXHVDQTlGXFx1Q0FBMS1cXHVDQUJCXFx1Q0FCRC1cXHVDQUQ3XFx1Q0FEOS1cXHVDQUYzXFx1Q0FGNS1cXHVDQjBGXFx1Q0IxMS1cXHVDQjJCXFx1Q0IyRC1cXHVDQjQ3XFx1Q0I0OS1cXHVDQjYzXFx1Q0I2NS1cXHVDQjdGXFx1Q0I4MS1cXHVDQjlCXFx1Q0I5RC1cXHVDQkI3XFx1Q0JCOS1cXHVDQkQzXFx1Q0JENS1cXHVDQkVGXFx1Q0JGMS1cXHVDQzBCXFx1Q0MwRC1cXHVDQzI3XFx1Q0MyOS1cXHVDQzQzXFx1Q0M0NS1cXHVDQzVGXFx1Q0M2MS1cXHVDQzdCXFx1Q0M3RC1cXHVDQzk3XFx1Q0M5OS1cXHVDQ0IzXFx1Q0NCNS1cXHVDQ0NGXFx1Q0NEMS1cXHVDQ0VCXFx1Q0NFRC1cXHVDRDA3XFx1Q0QwOS1cXHVDRDIzXFx1Q0QyNS1cXHVDRDNGXFx1Q0Q0MS1cXHVDRDVCXFx1Q0Q1RC1cXHVDRDc3XFx1Q0Q3OS1cXHVDRDkzXFx1Q0Q5NS1cXHVDREFGXFx1Q0RCMS1cXHVDRENCXFx1Q0RDRC1cXHVDREU3XFx1Q0RFOS1cXHVDRTAzXFx1Q0UwNS1cXHVDRTFGXFx1Q0UyMS1cXHVDRTNCXFx1Q0UzRC1cXHVDRTU3XFx1Q0U1OS1cXHVDRTczXFx1Q0U3NS1cXHVDRThGXFx1Q0U5MS1cXHVDRUFCXFx1Q0VBRC1cXHVDRUM3XFx1Q0VDOS1cXHVDRUUzXFx1Q0VFNS1cXHVDRUZGXFx1Q0YwMS1cXHVDRjFCXFx1Q0YxRC1cXHVDRjM3XFx1Q0YzOS1cXHVDRjUzXFx1Q0Y1NS1cXHVDRjZGXFx1Q0Y3MS1cXHVDRjhCXFx1Q0Y4RC1cXHVDRkE3XFx1Q0ZBOS1cXHVDRkMzXFx1Q0ZDNS1cXHVDRkRGXFx1Q0ZFMS1cXHVDRkZCXFx1Q0ZGRC1cXHVEMDE3XFx1RDAxOS1cXHVEMDMzXFx1RDAzNS1cXHVEMDRGXFx1RDA1MS1cXHVEMDZCXFx1RDA2RC1cXHVEMDg3XFx1RDA4OS1cXHVEMEEzXFx1RDBBNS1cXHVEMEJGXFx1RDBDMS1cXHVEMERCXFx1RDBERC1cXHVEMEY3XFx1RDBGOS1cXHVEMTEzXFx1RDExNS1cXHVEMTJGXFx1RDEzMS1cXHVEMTRCXFx1RDE0RC1cXHVEMTY3XFx1RDE2OS1cXHVEMTgzXFx1RDE4NS1cXHVEMTlGXFx1RDFBMS1cXHVEMUJCXFx1RDFCRC1cXHVEMUQ3XFx1RDFEOS1cXHVEMUYzXFx1RDFGNS1cXHVEMjBGXFx1RDIxMS1cXHVEMjJCXFx1RDIyRC1cXHVEMjQ3XFx1RDI0OS1cXHVEMjYzXFx1RDI2NS1cXHVEMjdGXFx1RDI4MS1cXHVEMjlCXFx1RDI5RC1cXHVEMkI3XFx1RDJCOS1cXHVEMkQzXFx1RDJENS1cXHVEMkVGXFx1RDJGMS1cXHVEMzBCXFx1RDMwRC1cXHVEMzI3XFx1RDMyOS1cXHVEMzQzXFx1RDM0NS1cXHVEMzVGXFx1RDM2MS1cXHVEMzdCXFx1RDM3RC1cXHVEMzk3XFx1RDM5OS1cXHVEM0IzXFx1RDNCNS1cXHVEM0NGXFx1RDNEMS1cXHVEM0VCXFx1RDNFRC1cXHVENDA3XFx1RDQwOS1cXHVENDIzXFx1RDQyNS1cXHVENDNGXFx1RDQ0MS1cXHVENDVCXFx1RDQ1RC1cXHVENDc3XFx1RDQ3OS1cXHVENDkzXFx1RDQ5NS1cXHVENEFGXFx1RDRCMS1cXHVENENCXFx1RDRDRC1cXHVENEU3XFx1RDRFOS1cXHVENTAzXFx1RDUwNS1cXHVENTFGXFx1RDUyMS1cXHVENTNCXFx1RDUzRC1cXHVENTU3XFx1RDU1OS1cXHVENTczXFx1RDU3NS1cXHVENThGXFx1RDU5MS1cXHVENUFCXFx1RDVBRC1cXHVENUM3XFx1RDVDOS1cXHVENUUzXFx1RDVFNS1cXHVENUZGXFx1RDYwMS1cXHVENjFCXFx1RDYxRC1cXHVENjM3XFx1RDYzOS1cXHVENjUzXFx1RDY1NS1cXHVENjZGXFx1RDY3MS1cXHVENjhCXFx1RDY4RC1cXHVENkE3XFx1RDZBOS1cXHVENkMzXFx1RDZDNS1cXHVENkRGXFx1RDZFMS1cXHVENkZCXFx1RDZGRC1cXHVENzE3XFx1RDcxOS1cXHVENzMzXFx1RDczNS1cXHVENzRGXFx1RDc1MS1cXHVENzZCXFx1RDc2RC1cXHVENzg3XFx1RDc4OS1cXHVEN0EzXSQvO1xudmFyIHJlRXh0UGljdCA9IC9eKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSQvO1xuXG52YXIgZ2V0Q29kZXBvaW50VHlwZSA9IGZ1bmN0aW9uIGdldENvZGVwb2ludFR5cGUoX2NoYXI0LCBjb2RlKSB7XG4gIHZhciB0eXBlID0gQ29kZXBvaW50VHlwZS5Bbnk7XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVFeHRlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRlbmQ7XG4gIH1cblxuICBpZiAoY29kZSA9PT0gMHgyMDBkKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlpXSjtcbiAgfVxuXG4gIGlmIChjb2RlID49IDB4MWYxZTYgJiYgY29kZSA8PSAweDFmMWZmKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlJJO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVQcmVwZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUHJlcGVuZDtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlU3BhY2luZ01hcmspICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFyaztcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlTCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkw7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5WO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVDtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlTFYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVjtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlTFZUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFZUO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVFeHRQaWN0KSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0UGljdDtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuZnVuY3Rpb24gaW50ZXJzZWN0cyh4LCB5KSB7XG4gIHJldHVybiAoeCAmIHkpICE9PSAwO1xufVxuXG52YXIgTm9uQm91bmRhcnlQYWlycyA9IFsvLyBHQjZcbltDb2RlcG9pbnRUeXBlLkwsIENvZGVwb2ludFR5cGUuTCB8IENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLkxWVF0sIC8vIEdCN1xuW0NvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLlYsIENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuVF0sIC8vIEdCOFxuW0NvZGVwb2ludFR5cGUuTFZUIHwgQ29kZXBvaW50VHlwZS5ULCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjlcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5FeHRlbmQgfCBDb2RlcG9pbnRUeXBlLlpXSl0sIC8vIEdCOWFcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFya10sIC8vIEdCOWJcbltDb2RlcG9pbnRUeXBlLlByZXBlbmQsIENvZGVwb2ludFR5cGUuQW55XSwgLy8gR0IxMVxuW0NvZGVwb2ludFR5cGUuWldKLCBDb2RlcG9pbnRUeXBlLkV4dFBpY3RdLCAvLyBHQjEyIGFuZCBHQjEzXG5bQ29kZXBvaW50VHlwZS5SSSwgQ29kZXBvaW50VHlwZS5SSV1dO1xuXG5mdW5jdGlvbiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gTm9uQm91bmRhcnlQYWlycy5maW5kSW5kZXgoZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0cyhsZWZ0LCByWzBdKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCByWzFdKTtcbiAgfSkgPT09IC0xO1xufVxuXG52YXIgZW5kaW5nRW1vamlaV0ogPSAvKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSg/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDMFxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REY0Ni1cXHVERjUwXXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMzAtXFx1REQzNlxcdURFRUMtXFx1REVFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pKlxcdTIwMEQkLztcblxudmFyIGVuZHNXaXRoRW1vamlaV0ogPSBmdW5jdGlvbiBlbmRzV2l0aEVtb2ppWldKKHN0cikge1xuICByZXR1cm4gc3RyLnNlYXJjaChlbmRpbmdFbW9qaVpXSikgIT09IC0xO1xufTtcblxudmFyIGVuZGluZ1JJcyA9IC8oPzpcXHVEODNDW1xcdURERTYtXFx1RERGRl0pKyQvZztcblxudmFyIGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMgPSBmdW5jdGlvbiBlbmRzV2l0aE9kZE51bWJlck9mUklzKHN0cikge1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goZW5kaW5nUklzKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gQSBSSSBpcyByZXByZXNlbnRlZCBieSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgIHZhciBudW1SSXMgPSBtYXRjaFswXS5sZW5ndGggLyAyO1xuICAgIHJldHVybiBudW1SSXMgJSAyID09PSAxO1xuICB9XG59O1xuXG4vKipcclxuICogU2hhcmVkIHRoZSBmdW5jdGlvbiB3aXRoIGlzRWxlbWVudFR5cGUgdXRpbGl0eVxyXG4gKi9cblxudmFyIGlzRWxlbWVudCA9IGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pICYmICFFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBFbGVtZW50ID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlICdBbmNlc3RvcicgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiBpc0FuY2VzdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBFbGVtZW50YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzRWxlbWVudDogaXNFbGVtZW50LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkgb2YgYEVsZW1lbnRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzRWxlbWVudExpc3Q6IGZ1bmN0aW9uIGlzRWxlbWVudExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBzZXQgb2YgcHJvcHMgaXMgYSBwYXJ0aWFsIG9mIEVsZW1lbnQuXHJcbiAgICovXG4gIGlzRWxlbWVudFByb3BzOiBmdW5jdGlvbiBpc0VsZW1lbnRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYEVsZW1lbnRgIGludGVyZmFjZSBhbmQgaGFzIGVsZW1lbnRLZXkgd2l0aCBzZWxlY3RlZCB2YWx1ZS5cclxuICAgKiBEZWZhdWx0IGl0IGNoZWNrIHRvIGB0eXBlYCBrZXkgdmFsdWVcclxuICAgKi9cbiAgaXNFbGVtZW50VHlwZTogZnVuY3Rpb24gaXNFbGVtZW50VHlwZSh2YWx1ZSwgZWxlbWVudFZhbCkge1xuICAgIHZhciBlbGVtZW50S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndHlwZSc7XG4gICAgcmV0dXJuIGlzRWxlbWVudCh2YWx1ZSkgJiYgdmFsdWVbZWxlbWVudEtleV0gPT09IGVsZW1lbnRWYWw7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBjaGVja3MgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdCBhbnlcclxuICAgKiBjaGlsZHJlbiBhcmUgZXF1aXZhbGVudC5cclxuICAgKi9cbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkNCA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiQzID0gW1widGV4dFwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ4KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDUoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG52YXIgSVNfRURJVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgRWRpdG9yID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIGFuY2VzdG9yIGFib3ZlIGEgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBhYm92ZTogZnVuY3Rpb24gYWJvdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMsXG4gICAgICAgIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUsXG4gICAgICAgIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgICB2YXIgcmV2ZXJzZSA9IG1vZGUgPT09ICdsb3dlc3QnO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgcmV2ZXJzZTogcmV2ZXJzZVxuICAgIH0pKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgbiA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgcCA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChuKSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBhdC5hbmNob3IucGF0aCkgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmZvY3VzLnBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIVBhdGguZXF1YWxzKHBhdGgsIHApKSB7XG4gICAgICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWRkIGEgY3VzdG9tIHByb3BlcnR5IHRvIHRoZSBsZWFmIHRleHQgbm9kZXMgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgY29sbGFwc2VkLCB0aGUgbWFya3Mgd2lsbCBiZSBhZGRlZCB0byB0aGVcclxuICAgKiBgZWRpdG9yLm1hcmtzYCBwcm9wZXJ0eSBpbnN0ZWFkLCBhbmQgYXBwbGllZCB3aGVuIHRleHQgaXMgaW5zZXJ0ZWQgbmV4dC5cclxuICAgKi9cbiAgYWRkTWFyazogZnVuY3Rpb24gYWRkTWFyayhlZGl0b3IsIGtleSwgdmFsdWUpIHtcbiAgICBlZGl0b3IuYWRkTWFyayhrZXksIHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBvaW50IGFmdGVyIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgICB2YXIgZm9jdXMgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgIHZhciByYW5nZSA9IHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGZvY3VzXG4gICAgfTtcbiAgICB2YXIgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgICAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2U7XG4gICAgdmFyIGQgPSAwO1xuICAgIHZhciB0YXJnZXQ7XG5cbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgYXQ6IHJhbmdlXG4gICAgfSkpKSxcbiAgICAgICAgX3N0ZXAyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGQrKztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGFuY2hvciA9IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKTtcbiAgICB2YXIgZm9jdXMgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHZhciByYW5nZSA9IHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGZvY3VzXG4gICAgfTtcbiAgICB2YXIgX29wdGlvbnMkZGlzdGFuY2UyID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2UgPSBfb3B0aW9ucyRkaXN0YW5jZTIgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZTI7XG4gICAgdmFyIGQgPSAwO1xuICAgIHZhciB0YXJnZXQ7XG5cbiAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgYXQ6IHJhbmdlLFxuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pKSksXG4gICAgICAgIF9zdGVwMztcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgIHRhcmdldCA9IHA7XG4gICAgICAgIH1cblxuICAgICAgICBkKys7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGJhY2t3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVCYWNrd2FyZDogZnVuY3Rpb24gZGVsZXRlQmFja3dhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgICAgICB1bml0ID0gX29wdGlvbnMkdW5pdCA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0O1xuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZvcndhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR1bml0MiA9IG9wdGlvbnMudW5pdCxcbiAgICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQyID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQyO1xuICAgIGVkaXRvci5kZWxldGVGb3J3YXJkKHVuaXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlbGV0ZSB0aGUgY29udGVudCBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZyYWdtZW50OiBmdW5jdGlvbiBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uLFxuICAgICAgICBkaXJlY3Rpb24gPSBfb3B0aW9ucyRkaXJlY3Rpb24gPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGRpcmVjdGlvbjtcbiAgICBlZGl0b3IuZGVsZXRlRnJhZ21lbnQoZGlyZWN0aW9uKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIFtFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCksIEVkaXRvci5lbmQoZWRpdG9yLCBhdCldO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZW5kIHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGVuZDogZnVuY3Rpb24gZW5kKGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnc3RhcnQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmcmFnbWVudCBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGJsb2NrIGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNCbG9ja3M6IGZ1bmN0aW9uIGhhc0Jsb2NrcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGlubGluZSBhbmQgdGV4dCBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzSW5saW5lczogZnVuY3Rpb24gaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNUZXh0czogZnVuY3Rpb24gaGFzVGV4dHMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBibG9jayBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0QnJlYWsoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmluc2VydEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgc29mdCBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRTb2Z0QnJlYWs6IGZ1bmN0aW9uIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIG5vZGUgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZShlZGl0b3IsIG5vZGUpIHtcbiAgICBlZGl0b3IuaW5zZXJ0Tm9kZShub2RlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgdGV4dCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICAgIGVkaXRvci5pbnNlcnRUZXh0KHRleHQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBibG9jayBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc0Jsb2NrOiBmdW5jdGlvbiBpc0Jsb2NrKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBgRWRpdG9yYCBvYmplY3QuXHJcbiAgICovXG4gIGlzRWRpdG9yOiBmdW5jdGlvbiBpc0VkaXRvcih2YWx1ZSkge1xuICAgIHZhciBjYWNoZWRJc0VkaXRvciA9IElTX0VESVRPUl9DQUNIRS5nZXQodmFsdWUpO1xuXG4gICAgaWYgKGNhY2hlZElzRWRpdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRJc0VkaXRvcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0b3IgPSB0eXBlb2YgdmFsdWUuYWRkTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuYXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUJhY2t3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGb3J3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFNvZnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5nZXREaXJ0eVBhdGhzID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICAgIElTX0VESVRPUl9DQUNIRS5zZXQodmFsdWUsIGlzRWRpdG9yKTtcbiAgICByZXR1cm4gaXNFZGl0b3I7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgZW5kIHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRW5kOiBmdW5jdGlvbiBpc0VuZChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhbiBlZGdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB8fCBFZGl0b3IuaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgZW1wdHksIGFjY291bnRpbmcgZm9yIHZvaWQgbm9kZXMuXHJcbiAgICovXG4gIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjtcblxuICAgIHZhciBfY2hpbGRyZW4gPSBfc2xpY2VkVG9BcnJheShjaGlsZHJlbiwgMSksXG4gICAgICAgIGZpcnN0ID0gX2NoaWxkcmVuWzBdO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW5saW5lIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzSW5saW5lOiBmdW5jdGlvbiBpc0lubGluZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgbm9ybWFsaXppbmcgYWZ0ZXIgZWFjaCBvcGVyYXRpb24uXHJcbiAgICovXG4gIGlzTm9ybWFsaXppbmc6IGZ1bmN0aW9uIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgdmFyIGlzTm9ybWFsaXppbmcgPSBOT1JNQUxJWklORy5nZXQoZWRpdG9yKTtcbiAgICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNTdGFydDogZnVuY3Rpb24gaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIC8vIFBFUkY6IElmIHRoZSBvZmZzZXQgaXNuJ3QgYDBgIHdlIGtub3cgaXQncyBub3QgdGhlIHN0YXJ0LlxuICAgIGlmIChwb2ludC5vZmZzZXQgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2b2lkIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzVm9pZDogZnVuY3Rpb24gaXNWb2lkKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVm9pZCh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbGFzdDogZnVuY3Rpb24gbGFzdChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnZW5kJ1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGVhZiB0ZXh0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbGVhZjogZnVuY3Rpb24gbGVhZihlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgICByZXR1cm4gW25vZGUsIHBhdGhdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGxldmVscyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZXZlbHM6IGZ1bmN0aW9uKiBsZXZlbHMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRhdDIgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0MiA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MixcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZSxcbiAgICAgICAgX29wdGlvbnMkdm9pZHMyID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMyO1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSxcbiAgICAgICAgX3N0ZXA0O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDIpLFxuICAgICAgICAgICAgbiA9IF9zdGVwNCR2YWx1ZVswXSxcbiAgICAgICAgICAgIHAgPSBfc3RlcDQkdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKCFtYXRjaChuLCBwKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV2ZWxzLnB1c2goW24sIHBdKTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxldmVscy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgeWllbGQqIGxldmVscztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hcmtzIHRoYXQgd291bGQgYmUgYWRkZWQgdG8gdGV4dCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIG1hcmtzOiBmdW5jdGlvbiBtYXJrcyhlZGl0b3IpIHtcbiAgICB2YXIgbWFya3MgPSBlZGl0b3IubWFya3MsXG4gICAgICAgIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtzKSB7XG4gICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgdmFyIF9FZGl0b3Ikbm9kZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSksXG4gICAgICAgICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICAgICAgICBtYXRjaCA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIF9tYXRjaCA9IF9zbGljZWRUb0FycmF5KG1hdGNoLCAxKSxcbiAgICAgICAgICAgIF9ub2RlID0gX21hdGNoWzBdO1xuXG4gICAgICAgIF9ub2RlLnRleHQ7XG4gICAgICAgICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX25vZGUsIF9leGNsdWRlZCQ0KTtcblxuICAgICAgICByZXR1cm4gX3Jlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgdmFyIHBhdGggPSBhbmNob3IucGF0aDtcblxuICAgIHZhciBfRWRpdG9yJGxlYWYgPSBFZGl0b3IubGVhZihlZGl0b3IsIHBhdGgpLFxuICAgICAgICBfRWRpdG9yJGxlYWYyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsZWFmLCAxKSxcbiAgICAgICAgbm9kZSA9IF9FZGl0b3IkbGVhZjJbMF07XG5cbiAgICBpZiAoYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoLFxuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICAgIH0pO1xuICAgICAgdmFyIG1hcmtlZFZvaWQgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSAmJiBlZGl0b3IubWFya2FibGVWb2lkKG4pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFtYXJrZWRWb2lkKSB7XG4gICAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocHJldiAmJiBibG9jaykge1xuICAgICAgICAgIHZhciBfcHJldiA9IF9zbGljZWRUb0FycmF5KHByZXYsIDIpLFxuICAgICAgICAgICAgICBwcmV2Tm9kZSA9IF9wcmV2WzBdLFxuICAgICAgICAgICAgICBwcmV2UGF0aCA9IF9wcmV2WzFdO1xuXG4gICAgICAgICAgdmFyIF9ibG9jayA9IF9zbGljZWRUb0FycmF5KGJsb2NrLCAyKSxcbiAgICAgICAgICAgICAgYmxvY2tQYXRoID0gX2Jsb2NrWzFdO1xuXG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihibG9ja1BhdGgsIHByZXZQYXRoKSkge1xuICAgICAgICAgICAgbm9kZSA9IHByZXZOb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfbm9kZTIgPSBub2RlO1xuICAgICAgICBfbm9kZTIudGV4dDtcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX25vZGUyLCBfZXhjbHVkZWQyJDMpO1xuXG4gICAgcmV0dXJuIHJlc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXRjaGluZyBub2RlIGluIHRoZSBicmFuY2ggb2YgdGhlIGRvY3VtZW50IGFmdGVyIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRtb2RlMiA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUyID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUyLFxuICAgICAgICBfb3B0aW9ucyR2b2lkczMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczM7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgX29wdGlvbnMkYXQzID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDMgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50QWZ0ZXJMb2NhdGlvbiA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCB7XG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoIXBvaW50QWZ0ZXJMb2NhdGlvbikgcmV0dXJuO1xuXG4gICAgdmFyIF9FZGl0b3IkbGFzdCA9IEVkaXRvci5sYXN0KGVkaXRvciwgW10pLFxuICAgICAgICBfRWRpdG9yJGxhc3QyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsYXN0LCAyKSxcbiAgICAgICAgdG8gPSBfRWRpdG9yJGxhc3QyWzFdO1xuXG4gICAgdmFyIHNwYW4gPSBbcG9pbnRBZnRlckxvY2F0aW9uLnBhdGgsIHRvXTtcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDEpLFxuICAgICAgICAgICAgcGFyZW50ID0gX0VkaXRvciRwYXJlbnQyWzBdO1xuXG4gICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfRWRpdG9yJG5vZGVzMyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBzcGFuLFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pLFxuICAgICAgICBfRWRpdG9yJG5vZGVzNCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMzLCAxKSxcbiAgICAgICAgbmV4dCA9IF9FZGl0b3Ikbm9kZXM0WzBdO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIG5vZGU6IGZ1bmN0aW9uIG5vZGUoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICByZXR1cm4gW25vZGUsIHBhdGhdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIG5vZGVzIGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIG5vZGVzOiBmdW5jdGlvbiogbm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRhdDQgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0NCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NCxcbiAgICAgICAgX29wdGlvbnMkbW9kZTMgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlMyA9PT0gdm9pZCAwID8gJ2FsbCcgOiBfb3B0aW9ucyRtb2RlMyxcbiAgICAgICAgX29wdGlvbnMkdW5pdmVyc2FsID0gb3B0aW9ucy51bml2ZXJzYWwsXG4gICAgICAgIHVuaXZlcnNhbCA9IF9vcHRpb25zJHVuaXZlcnNhbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR1bml2ZXJzYWwsXG4gICAgICAgIF9vcHRpb25zJHJldmVyc2UyID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZTIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTIsXG4gICAgICAgIF9vcHRpb25zJHZvaWRzNCA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNDtcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG5cbiAgICBpZiAoU3Bhbi5pc1NwYW4oYXQpKSB7XG4gICAgICBmcm9tID0gYXRbMF07XG4gICAgICB0byA9IGF0WzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIGZyb20gPSByZXZlcnNlID8gbGFzdCA6IGZpcnN0O1xuICAgICAgdG8gPSByZXZlcnNlID8gZmlyc3QgOiBsYXN0O1xuICAgIH1cblxuICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiByZXZlcnNlLFxuICAgICAgZnJvbTogZnJvbSxcbiAgICAgIHRvOiB0byxcbiAgICAgIHBhc3M6IGZ1bmN0aW9uIHBhc3MoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAxKSxcbiAgICAgICAgICAgIG4gPSBfcmVmMlswXTtcblxuICAgICAgICByZXR1cm4gdm9pZHMgPyBmYWxzZSA6IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBoaXQ7XG5cbiAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUobm9kZUVudHJpZXMpLFxuICAgICAgICBfc3RlcDU7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwNSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNS52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXA1JHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwNSR2YWx1ZVsxXTtcblxuICAgICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDsgLy8gSW4gaGlnaGVzdCBtb2RlIGFueSBub2RlIGxvd2VyIHRoYW4gdGhlIGxhc3QgaGl0IGlzIG5vdCBhIG1hdGNoLlxuXG4gICAgICAgIGlmIChtb2RlID09PSAnaGlnaGVzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaChub2RlLCBwYXRoKSkge1xuICAgICAgICAgIC8vIElmIHdlJ3ZlIGFycml2ZWQgYXQgYSBsZWFmIHRleHQgbm9kZSB0aGF0IGlzIG5vdCBsb3dlciB0aGFuIHRoZSBsYXN0XG4gICAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgICAgLy8gbWVhbnMgdGhlIG1hdGNoIGlzIG5vdCB1bml2ZXJzYWwuXG4gICAgICAgICAgaWYgKHVuaXZlcnNhbCAmJiAhaXNMb3dlciAmJiBUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSWYgdGhlcmUncyBhIG1hdGNoIGFuZCBpdCdzIGxvd2VyIHRoYW4gdGhlIGxhc3QsIHVwZGF0ZSB0aGUgaGl0LlxuXG5cbiAgICAgICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSW4gbG93ZXN0IG1vZGUgd2UgZW1pdCB0aGUgbGFzdCBoaXQsIG9uY2UgaXQncyBndWFyYW50ZWVkIGxvd2VzdC5cblxuXG4gICAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG5cbiAgICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goZW1pdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIGVtaXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgICAgfSAvLyBTaW5jZSBsb3dlc3QgaXMgYWx3YXlzIGVtaXR0aW5nIG9uZSBiZWhpbmQsIGNhdGNoIHVwIGF0IHRoZSBlbmQuXG5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaGl0KSB7XG4gICAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChoaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgaGl0O1xuICAgICAgfVxuICAgIH0gLy8gVW5pdmVyc2FsIGRlZmVycyB0byBlbnN1cmUgdGhhdCB0aGUgbWF0Y2ggb2NjdXJzIGluIGV2ZXJ5IGJyYW5jaCwgc28gd2VcbiAgICAvLyB5aWVsZCBhbGwgb2YgdGhlIG1hdGNoZXMgYWZ0ZXIgaXRlcmF0aW5nLlxuXG5cbiAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICB5aWVsZCogbWF0Y2hlcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTm9ybWFsaXplIGFueSBkaXJ0eSBvYmplY3RzIGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkZm9yY2UgPSBvcHRpb25zLmZvcmNlLFxuICAgICAgICBmb3JjZSA9IF9vcHRpb25zJGZvcmNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGZvcmNlLFxuICAgICAgICBvcGVyYXRpb24gPSBvcHRpb25zLm9wZXJhdGlvbjtcblxuICAgIHZhciBnZXREaXJ0eVBhdGhzID0gZnVuY3Rpb24gZ2V0RGlydHlQYXRocyhlZGl0b3IpIHtcbiAgICAgIHJldHVybiBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgICB9O1xuXG4gICAgdmFyIGdldERpcnR5UGF0aEtleXMgPSBmdW5jdGlvbiBnZXREaXJ0eVBhdGhLZXlzKGVkaXRvcikge1xuICAgICAgcmV0dXJuIERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gICAgfTtcblxuICAgIHZhciBwb3BEaXJ0eVBhdGggPSBmdW5jdGlvbiBwb3BEaXJ0eVBhdGgoZWRpdG9yKSB7XG4gICAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICAgIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmb3JjZSkge1xuICAgICAgdmFyIGFsbFBhdGhzID0gQXJyYXkuZnJvbShOb2RlLm5vZGVzKGVkaXRvciksIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICBwID0gX3JlZjRbMV07XG5cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KTtcbiAgICAgIHZhciBhbGxQYXRoS2V5cyA9IG5ldyBTZXQoYWxsUGF0aHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLmpvaW4oJywnKTtcbiAgICAgIH0pKTtcbiAgICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGFsbFBhdGhzKTtcbiAgICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBhbGxQYXRoS2V5cyk7XG4gICAgfVxuXG4gICAgaWYgKGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgLypcclxuICAgICAgICBGaXggZGlydHkgZWxlbWVudHMgd2l0aCBubyBjaGlsZHJlbi5cclxuICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZSgpIGRvZXMgZml4IHRoaXMsIGJ1dCBzb21lIG5vcm1hbGl6YXRpb24gZml4ZXMgYWxzbyByZXF1aXJlIGl0IHRvIHdvcmsuXHJcbiAgICAgICAgUnVubmluZyBhbiBpbml0aWFsIHBhc3MgYXZvaWRzIHRoZSBjYXRjaC0yMiByYWNlIGNvbmRpdGlvbi5cclxuICAgICAgKi9cbiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShnZXREaXJ0eVBhdGhzKGVkaXRvcikpLFxuICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2RpcnR5UGF0aCA9IF9zdGVwNi52YWx1ZTtcblxuICAgICAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIF9kaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgX2VudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBfZGlydHlQYXRoKTtcblxuICAgICAgICAgICAgdmFyIF9lbnRyeTIgPSBfc2xpY2VkVG9BcnJheShfZW50cnksIDIpLFxuICAgICAgICAgICAgICAgIG5vZGUgPSBfZW50cnkyWzBdLFxuICAgICAgICAgICAgICAgIF8gPSBfZW50cnkyWzFdO1xuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICBUaGUgZGVmYXVsdCBub3JtYWxpemVyIGluc2VydHMgYW4gZW1wdHkgdGV4dCBub2RlIGluIHRoaXMgc2NlbmFyaW8sIGJ1dCBpdCBjYW4gYmUgY3VzdG9taXNlZC5cclxuICAgICAgICAgICAgICBTbyB0aGVyZSBpcyBzb21lIHJpc2sgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgIEFzIGxvbmcgYXMgdGhlIG5vcm1hbGl6ZXIgb25seSBpbnNlcnRzIGNoaWxkIG5vZGVzIGZvciB0aGlzIGNhc2UgaXQgaXMgc2FmZSB0byBkbyBpbiBhbnkgb3JkZXI7XHJcbiAgICAgICAgICAgICAgYnkgZGVmaW5pdGlvbiBhZGRpbmcgY2hpbGRyZW4gdG8gYW4gZW1wdHkgbm9kZSBjYW4ndCBjYXVzZSBvdGhlciBwYXRocyB0byBjaGFuZ2UuXHJcbiAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKF9lbnRyeSwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgICAgdmFyIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoID0gZGlydHlQYXRocy5sZW5ndGg7XG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcblxuICAgICAgd2hpbGUgKGRpcnR5UGF0aHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGlmICghZWRpdG9yLnNob3VsZE5vcm1hbGl6ZSh7XG4gICAgICAgICAgZGlydHlQYXRoczogZGlydHlQYXRocyxcbiAgICAgICAgICBpdGVyYXRpb246IGl0ZXJhdGlvbixcbiAgICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aDogaW5pdGlhbERpcnR5UGF0aHNMZW5ndGgsXG4gICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25cbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlydHlQYXRoID0gcG9wRGlydHlQYXRoKGVkaXRvcik7IC8vIElmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUsIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgbm9ybWFsaXplZC5cblxuICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBkaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBkaXJ0eVBhdGgpO1xuICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKGVudHJ5LCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKGVkaXRvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXJlbnQgbm9kZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhcmVudFBhdGgpO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGggb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcGF0aDogZnVuY3Rpb24gcGF0aChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBkZXB0aCA9IG9wdGlvbnMuZGVwdGgsXG4gICAgICAgIGVkZ2UgPSBvcHRpb25zLmVkZ2U7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB2YXIgX05vZGUkZmlyc3QgPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgX05vZGUkZmlyc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkZmlyc3QsIDIpLFxuICAgICAgICAgICAgZmlyc3RQYXRoID0gX05vZGUkZmlyc3QyWzFdO1xuXG4gICAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgX05vZGUkbGFzdCA9IE5vZGUubGFzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9Ob2RlJGxhc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkbGFzdCwgMiksXG4gICAgICAgICAgICBsYXN0UGF0aCA9IF9Ob2RlJGxhc3QyWzFdO1xuXG4gICAgICAgIGF0ID0gbGFzdFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBhdCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5lbmQoYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXQgPSBQYXRoLmNvbW1vbihhdC5hbmNob3IucGF0aCwgYXQuZm9jdXMucGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBhdCA9IGF0LnBhdGg7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoICE9IG51bGwpIHtcbiAgICAgIGF0ID0gYXQuc2xpY2UoMCwgZGVwdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBhdDtcbiAgfSxcbiAgaGFzUGF0aDogZnVuY3Rpb24gaGFzUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgICByZXR1cm4gTm9kZS5oYXMoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUGF0aGAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBhdGhSZWY6IGZ1bmN0aW9uIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwYXRoLFxuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5LFxuICAgICAgdW5yZWY6IGZ1bmN0aW9uIHVucmVmKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgcGF0aFJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgICAgICAgcGF0aFJlZnNbXCJkZWxldGVcIl0ocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHBhdGggcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwYXRoUmVmczogZnVuY3Rpb24gcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBvciBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcG9pbnQ6IGZ1bmN0aW9uIHBvaW50KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGVkZ2UgPSBvcHRpb25zLmVkZ2UsXG4gICAgICAgIGVkZ2UgPSBfb3B0aW9ucyRlZGdlID09PSB2b2lkIDAgPyAnc3RhcnQnIDogX29wdGlvbnMkZWRnZTtcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoO1xuXG4gICAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFyIF9Ob2RlJGxhc3QzID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgX05vZGUkbGFzdDQgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRsYXN0MywgMiksXG4gICAgICAgICAgICBsYXN0UGF0aCA9IF9Ob2RlJGxhc3Q0WzFdO1xuXG4gICAgICAgIHBhdGggPSBsYXN0UGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfTm9kZSRmaXJzdDMgPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgX05vZGUkZmlyc3Q0ID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkZmlyc3QzLCAyKSxcbiAgICAgICAgICAgIGZpcnN0UGF0aCA9IF9Ob2RlJGZpcnN0NFsxXTtcblxuICAgICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBvZmZzZXQ6IGVkZ2UgPT09ICdlbmQnID8gbm9kZS50ZXh0Lmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgICByZXR1cm4gZWRnZSA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBhdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUG9pbnRgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwb2ludFJlZjogZnVuY3Rpb24gcG9pbnRSZWYoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkyID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eTIgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5MjtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcG9pbnQsXG4gICAgICBhZmZpbml0eTogYWZmaW5pdHksXG4gICAgICB1bnJlZjogZnVuY3Rpb24gdW5yZWYoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwb2ludFJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgICAgIHBvaW50UmVmc1tcImRlbGV0ZVwiXShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHBvaW50IHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWZzOiBmdW5jdGlvbiBwb2ludFJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBQT0lOVF9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUE9JTlRfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYWxsIHRoZSBwb3NpdGlvbnMgaW4gYGF0YCByYW5nZSB3aGVyZSBhIGBQb2ludGAgY2FuIGJlIHBsYWNlZC5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIG1vdmVzIGZvcndhcmQgYnkgaW5kaXZpZHVhbCBvZmZzZXRzIGF0IGEgdGltZSwgYnV0XHJcbiAgICogdGhlIGB1bml0YCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gdG8gbW92ZSBieSBjaGFyYWN0ZXIsIHdvcmQsIGxpbmUsIG9yIGJsb2NrLlxyXG4gICAqXHJcbiAgICogVGhlIGByZXZlcnNlYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gY2hhbmdlIGl0ZXJhdGlvbiBkaXJlY3Rpb24uXHJcbiAgICpcclxuICAgKiBOb3RlOiBCeSBkZWZhdWx0IHZvaWQgbm9kZXMgYXJlIHRyZWF0ZWQgYXMgYSBzaW5nbGUgcG9pbnQgYW5kIGl0ZXJhdGlvblxyXG4gICAqIHdpbGwgbm90IGhhcHBlbiBpbnNpZGUgdGhlaXIgY29udGVudCB1bmxlc3MgeW91IHBhc3MgaW4gdHJ1ZSBmb3IgdGhlXHJcbiAgICogYHZvaWRzYCBvcHRpb24sIHRoZW4gaXRlcmF0aW9uIHdpbGwgb2NjdXIuXHJcbiAgICovXG4gIHBvc2l0aW9uczogZnVuY3Rpb24qIHBvc2l0aW9ucyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGF0NSA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQ1ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ1LFxuICAgICAgICBfb3B0aW9ucyR1bml0MyA9IG9wdGlvbnMudW5pdCxcbiAgICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQzID09PSB2b2lkIDAgPyAnb2Zmc2V0JyA6IF9vcHRpb25zJHVuaXQzLFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlMyA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UzLFxuICAgICAgICBfb3B0aW9ucyR2b2lkczUgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczU7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQWxnb3JpdGhtIG5vdGVzOlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggc3RlcCBgZGlzdGFuY2VgIGlzIGR5bmFtaWMgZGVwZW5kaW5nIG9uIHRoZSB1bmRlcmx5aW5nIHRleHRcclxuICAgICAqIGFuZCB0aGUgYHVuaXRgIHNwZWNpZmllZC4gIEVhY2ggc3RlcCwgZS5nLiwgYSBsaW5lIG9yIHdvcmQsIG1heVxyXG4gICAgICogc3BhbiBtdWx0aXBsZSB0ZXh0IG5vZGVzLCBzbyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIHRleHQgYm90aCBvblxyXG4gICAgICogdHdvIGxldmVscyBpbiBzdGVwLXN5bmM6XHJcbiAgICAgKlxyXG4gICAgICogYGxlYWZUZXh0YCBzdG9yZXMgdGhlIHRleHQgb24gYSB0ZXh0IGxlYWYgbGV2ZWwsIGFuZCBpcyBhZHZhbmNlZFxyXG4gICAgICogdGhyb3VnaCB1c2luZyB0aGUgY291bnRlcnMgYGxlYWZUZXh0T2Zmc2V0YCBhbmQgYGxlYWZUZXh0UmVtYWluaW5nYC5cclxuICAgICAqXHJcbiAgICAgKiBgYmxvY2tUZXh0YCBzdG9yZXMgdGhlIHRleHQgb24gYSBibG9jayBsZXZlbCwgYW5kIGlzIHNob3J0ZW5lZFxyXG4gICAgICogYnkgYGRpc3RhbmNlYCBldmVyeSB0aW1lIGl0IGlzIGFkdmFuY2VkLlxyXG4gICAgICpcclxuICAgICAqIFdlIG9ubHkgbWFpbnRhaW4gYSB3aW5kb3cgb2Ygb25lIGJsb2NrVGV4dCBhbmQgb25lIGxlYWZUZXh0IGJlY2F1c2VcclxuICAgICAqIGEgYmxvY2sgbm9kZSBhbHdheXMgYXBwZWFycyBiZWZvcmUgYWxsIG9mIGl0cyBsZWFmIG5vZGVzLlxyXG4gICAgICovXG5cblxuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcblxuICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzNFswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNFsxXTtcblxuICAgIHZhciBmaXJzdCA9IHJldmVyc2UgPyBlbmQgOiBzdGFydDtcbiAgICB2YXIgaXNOZXdCbG9jayA9IGZhbHNlO1xuICAgIHZhciBibG9ja1RleHQgPSAnJztcbiAgICB2YXIgZGlzdGFuY2UgPSAwOyAvLyBEaXN0YW5jZSBmb3IgbGVhZlRleHQgdG8gY2F0Y2ggdXAgdG8gYmxvY2tUZXh0LlxuXG4gICAgdmFyIGxlYWZUZXh0UmVtYWluaW5nID0gMDtcbiAgICB2YXIgbGVhZlRleHRPZmZzZXQgPSAwOyAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vZGVzIGluIHJhbmdlLCBncmFiYmluZyBlbnRpcmUgdGV4dHVhbCBjb250ZW50XG4gICAgLy8gb2YgYmxvY2sgbm9kZXMgaW4gYmxvY2tUZXh0LCBhbmQgdGV4dCBub2RlcyBpbiBsZWFmVGV4dC5cbiAgICAvLyBFeHBsb2l0cyB0aGUgZmFjdCB0aGF0IG5vZGVzIGFyZSBzZXF1ZW5jZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIGZpcnN0XG4gICAgLy8gZW5jb3VudGVyIHRoZSBibG9jayBub2RlLCB0aGVuIGFsbCBvZiBpdHMgdGV4dCBub2Rlcywgc28gd2hlbiBpdGVyYXRpbmdcbiAgICAvLyB0aHJvdWdoIHRoZSBibG9ja1RleHQgYW5kIGxlYWZUZXh0IHdlIGp1c3QgbmVlZCB0byByZW1lbWJlciBhIHdpbmRvdyBvZlxuICAgIC8vIG9uZSBibG9jayBub2RlIGFuZCBsZWFmIG5vZGUsIHJlc3BlY3RpdmVseS5cblxuICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYXQsXG4gICAgICByZXZlcnNlOiByZXZlcnNlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSkpLFxuICAgICAgICBfc3RlcDc7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwNyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNy52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXA3JHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwNyR2YWx1ZVsxXTtcblxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xyXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc28gYnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5c1xuICAgICAgICAgIC8vIHlpZWxkIHRoZWlyIGZpcnN0IHBvaW50LiBJZiB0aGUgYHZvaWRzYCBvcHRpb24gaXMgc2V0IHRvIHRydWUsXG4gICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciB0aGVpciBjb250ZW50LlxuICAgICAgICAgIGlmICghdm9pZHMgJiYgZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgICAgeWllbGQgRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIElubGluZSBlbGVtZW50IG5vZGVzIGFyZSBpZ25vcmVkIGFzIHRoZXkgZG9uJ3QgdGhlbXNlbHZlc1xuICAgICAgICAgIC8vIGNvbnRyaWJ1dGUgdG8gYGJsb2NrVGV4dGAgb3IgYGxlYWZUZXh0YCAtIHRoZWlyIHBhcmVudCBhbmRcbiAgICAgICAgICAvLyBjaGlsZHJlbiBkby5cblxuXG4gICAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkgY29udGludWU7IC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuXG4gICAgICAgICAgaWYgKEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBleGhhdXN0IGJsb2NrIG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLFxuICAgICAgICAgICAgLy8gICAgIGBibG9ja1RleHQ9JyR7YmxvY2tUZXh0fScgLSBgK1xuICAgICAgICAgICAgLy8gICAgIGBub3QgZXhoYXVzdGVkIGJlZm9yZSBuZXcgYmxvY2sgbm9kZWAsIHBhdGgpXG4gICAgICAgICAgICAvLyBFbnN1cmUgcmFuZ2UgY29uc2lkZXJlZCBpcyBjYXBwZWQgdG8gYHJhbmdlYCwgaW4gdGhlXG4gICAgICAgICAgICAvLyBzdGFydC9lbmQgZWRnZSBjYXNlcyB3aGVyZSBibG9jayBleHRlbmRzIGJleW9uZCByYW5nZS5cbiAgICAgICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gdGhpcywgYnV0IHByZXN1bWFibHkgbW9yZSBwZXJmb3JtYW50OlxuICAgICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgLi4uRWRpdG9yLmVkZ2VzKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIGJsb2NrUmFuZ2UpIC8vIGludGVyc2VjdFxuICAgICAgICAgICAgLy8gICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwgYmxvY2tSYW5nZSwgeyB2b2lkcyB9KVxuICAgICAgICAgICAgdmFyIGUgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgZW5kLnBhdGgpID8gZW5kIDogRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIHMgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgc3RhcnQucGF0aCkgPyBzdGFydCA6IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBzLFxuICAgICAgICAgICAgICBmb2N1czogZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXNOZXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVEVYVCBMRUFGIE5PREUgLSBJdGVyYXRlIHRocm91Z2ggdGV4dCBjb250ZW50LCB5aWVsZGluZ1xyXG4gICAgICAgICAqIHBvc2l0aW9ucyBldmVyeSBgZGlzdGFuY2VgIG9mZnNldCBhY2NvcmRpbmcgdG8gYHVuaXRgLlxyXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgdmFyIGlzRmlyc3QgPSBQYXRoLmVxdWFscyhwYXRoLCBmaXJzdC5wYXRoKTsgLy8gUHJvb2YgdGhhdCB3ZSBhbHdheXMgZXhoYXVzdCB0ZXh0IG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCxcbiAgICAgICAgICAvLyAgICAgYGxlYWZUZXh0UmVtYWluaW5nPSR7bGVhZlRleHRSZW1haW5pbmd9IC0gYCtcbiAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBsZWFmIHRleHQgbm9kZWAsIHBhdGgpXG4gICAgICAgICAgLy8gUmVzZXQgYGxlYWZUZXh0YCBjb3VudGVycyBmb3IgbmV3IHRleHQgbm9kZS5cblxuICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IHJldmVyc2UgPyBmaXJzdC5vZmZzZXQgOiBub2RlLnRleHQubGVuZ3RoIC0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSBmaXJzdC5vZmZzZXQ7IC8vIFdvcmtzIGZvciByZXZlcnNlIHRvby5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBub2RlLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRSZW1haW5pbmcgOiAwO1xuICAgICAgICAgIH0gLy8gWWllbGQgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIG5vZGUgKHBvdGVudGlhbGx5KS5cblxuXG4gICAgICAgICAgaWYgKGlzRmlyc3QgfHwgaXNOZXdCbG9jayB8fCB1bml0ID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXNOZXdCbG9jayA9IGZhbHNlO1xuICAgICAgICAgIH0gLy8gWWllbGQgcG9zaXRpb25zIGV2ZXJ5IChkeW5hbWljYWxseSBjYWxjdWxhdGVkKSBgZGlzdGFuY2VgIG9mZnNldC5cblxuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIElmIGBsZWFmVGV4dGAgaGFzIGNhdWdodCB1cCB3aXRoIGBibG9ja1RleHRgIChkaXN0YW5jZT0wKSxcbiAgICAgICAgICAgIC8vIGFuZCBpZiBibG9ja1RleHQgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYW5vdGhlciBibG9jayBub2RlLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFkdmFuY2UgYmxvY2tUZXh0IGZvcndhcmQgYnkgdGhlIG5ldyBgZGlzdGFuY2VgLlxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChibG9ja1RleHQgPT09ICcnKSBicmVhaztcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoYmxvY2tUZXh0LCB1bml0LCByZXZlcnNlKTsgLy8gU3BsaXQgdGhlIHN0cmluZyBhdCB0aGUgcHJldmlvdXNseSBmb3VuZCBkaXN0YW5jZSBhbmQgdXNlIHRoZVxuICAgICAgICAgICAgICAvLyByZW1haW5pbmcgc3RyaW5nIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG5cbiAgICAgICAgICAgICAgYmxvY2tUZXh0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKGJsb2NrVGV4dCwgZGlzdGFuY2UsIHJldmVyc2UpWzFdO1xuICAgICAgICAgICAgfSAvLyBBZHZhbmNlIGBsZWFmVGV4dGAgYnkgdGhlIGN1cnJlbnQgYGRpc3RhbmNlYC5cblxuXG4gICAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dE9mZnNldCAtIGRpc3RhbmNlIDogbGVhZlRleHRPZmZzZXQgKyBkaXN0YW5jZTtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbGVhZlRleHRSZW1haW5pbmcgLSBkaXN0YW5jZTsgLy8gSWYgYGxlYWZUZXh0YCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhIG5ldyBsZWFmIG5vZGVcbiAgICAgICAgICAgIC8vIGFuZCBzZXQgZGlzdGFuY2UgdG8gdGhlIG92ZXJmbG93IGFtb3VudCwgc28gd2UnbGwgKG1heWJlKVxuICAgICAgICAgICAgLy8gY2F0Y2ggdXAgdG8gYmxvY2tUZXh0IGluIHRoZSBuZXh0IGxlYWYgdGV4dCBub2RlLlxuXG4gICAgICAgICAgICBpZiAobGVhZlRleHRSZW1haW5pbmcgPCAwKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gLWxlYWZUZXh0UmVtYWluaW5nO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gLy8gU3VjY2Vzc2Z1bGx5IHdhbGtlZCBgZGlzdGFuY2VgIG9mZnNldHMgdGhyb3VnaCBgbGVhZlRleHRgXG4gICAgICAgICAgICAvLyB0byBjYXRjaCB1cCB3aXRoIGBibG9ja1RleHRgLCBzbyB3ZSBjYW4gcmVzZXQgYGRpc3RhbmNlYFxuICAgICAgICAgICAgLy8gYW5kIHlpZWxkIHRoaXMgcG9zaXRpb24gaW4gdGhpcyBub2RlLlxuXG5cbiAgICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJvb2YgdGhhdCB1cG9uIGNvbXBsZXRpb24sIHdlJ3ZlIGV4YWh1c3RlZCBib3RoIGxlYWYgYW5kIGJsb2NrIHRleHQ6XG4gICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsIFwibGVhZlRleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLCBcImJsb2NrVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgICAvLyBIZWxwZXI6XG4gICAgICAvLyBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIG9mZnNldHMgZm9yIGEgc3RlcCBvZiBzaXplIGB1bml0YCBvbiBnaXZlbiBzdHJpbmcuXG5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjRGlzdGFuY2UodGV4dCwgdW5pdCwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHVuaXQgPT09ICdjaGFyYWN0ZXInKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCByZXZlcnNlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3dvcmQnKSB7XG4gICAgICAgIHJldHVybiBnZXRXb3JkRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdsaW5lJyB8fCB1bml0ID09PSAnYmxvY2snKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkbW9kZTQgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlNCA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlNCxcbiAgICAgICAgX29wdGlvbnMkdm9pZHM2ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczYgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM2O1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgIF9vcHRpb25zJGF0NiA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQ2ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ2O1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEJlZm9yZUxvY2F0aW9uID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCB7XG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcblxuICAgIGlmICghcG9pbnRCZWZvcmVMb2NhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfRWRpdG9yJGZpcnN0ID0gRWRpdG9yLmZpcnN0KGVkaXRvciwgW10pLFxuICAgICAgICBfRWRpdG9yJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkZmlyc3QsIDIpLFxuICAgICAgICB0byA9IF9FZGl0b3IkZmlyc3QyWzFdOyAvLyBUaGUgc2VhcmNoIGxvY2F0aW9uIGlzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB0byB0aGUgcGF0aCBvZlxuICAgIC8vIHRoZSBwb2ludCBiZWZvcmUgdGhlIGxvY2F0aW9uIHBhc3NlZCBpblxuXG5cbiAgICB2YXIgc3BhbiA9IFtwb2ludEJlZm9yZUxvY2F0aW9uLnBhdGgsIHRvXTtcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50MyA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICBfRWRpdG9yJHBhcmVudDQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudDMsIDEpLFxuICAgICAgICAgICAgcGFyZW50ID0gX0VkaXRvciRwYXJlbnQ0WzBdO1xuXG4gICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfRWRpdG9yJG5vZGVzNSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSxcbiAgICAgICAgX0VkaXRvciRub2RlczYgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzNSwgMSksXG4gICAgICAgIHByZXZpb3VzID0gX0VkaXRvciRub2RlczZbMF07XG5cbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgcmFuZ2Ugb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcmFuZ2U6IGZ1bmN0aW9uIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmICF0bykge1xuICAgICAgcmV0dXJuIGF0O1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBSYW5nZWAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHJhbmdlUmVmOiBmdW5jdGlvbiByYW5nZVJlZihlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eTMgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5MyA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHkzO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiByYW5nZSxcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eSxcbiAgICAgIHVucmVmOiBmdW5jdGlvbiB1bnJlZigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHJhbmdlUmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICAgICAgcmFuZ2VSZWZzW1wiZGVsZXRlXCJdKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcmFuZ2UgcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZnM6IGZ1bmN0aW9uIHJhbmdlUmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFJBTkdFX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBSQU5HRV9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIGN1c3RvbSBwcm9wZXJ0eSBmcm9tIGFsbCBvZiB0aGUgbGVhZiB0ZXh0IG5vZGVzIGluIHRoZSBjdXJyZW50XHJcbiAgICogc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgY29sbGFwc2VkLCB0aGUgcmVtb3ZhbCB3aWxsIGJlIHN0b3JlZCBvblxyXG4gICAqIGBlZGl0b3IubWFya3NgIGFuZCBhcHBsaWVkIHRvIHRoZSB0ZXh0IGluc2VydGVkIG5leHQuXHJcbiAgICovXG4gIHJlbW92ZU1hcms6IGZ1bmN0aW9uIHJlbW92ZU1hcmsoZWRpdG9yLCBrZXkpIHtcbiAgICBlZGl0b3IucmVtb3ZlTWFyayhrZXkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hbnVhbGx5IHNldCBpZiB0aGUgZWRpdG9yIHNob3VsZCBjdXJyZW50bHkgYmUgbm9ybWFsaXppbmcuXHJcbiAgICpcclxuICAgKiBOb3RlOiBVc2luZyB0aGlzIGluY29ycmVjdGx5IGNhbiBsZWF2ZSB0aGUgZWRpdG9yIGluIGFuIGludmFsaWQgc3RhdGUuXHJcbiAgICpcclxuICAgKi9cbiAgc2V0Tm9ybWFsaXppbmc6IGZ1bmN0aW9uIHNldE5vcm1hbGl6aW5nKGVkaXRvciwgaXNOb3JtYWxpemluZykge1xuICAgIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIGlzTm9ybWFsaXppbmcpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHRleHQgc3RyaW5nIGNvbnRlbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IGJ5IGRlZmF1bHQgdGhlIHRleHQgb2Ygdm9pZCBub2RlcyBpcyBjb25zaWRlcmVkIHRvIGJlIGFuIGVtcHR5XHJcbiAgICogc3RyaW5nLCByZWdhcmRsZXNzIG9mIGNvbnRlbnQsIHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGUgdm9pZHMgb3B0aW9uXHJcbiAgICovXG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHZvaWRzNyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM3ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNztcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzNSA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzNiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczUsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczZbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczZbMV07XG5cbiAgICB2YXIgdGV4dCA9ICcnO1xuXG4gICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pKSxcbiAgICAgICAgX3N0ZXA4O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDgkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDgudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwOCR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDgkdmFsdWVbMV07XG5cbiAgICAgICAgdmFyIHQgPSBub2RlLnRleHQ7XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIHQgPSB0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdCA9IHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgKz0gdDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I4LmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIG5vbi1oYW5naW5nIG9uZS5cclxuICAgKi9cbiAgdW5oYW5nUmFuZ2U6IGZ1bmN0aW9uIHVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHZvaWRzOCA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM4ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzODtcblxuICAgIHZhciBfUmFuZ2UkZWRnZXM3ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXM4ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNywgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzOFswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzOFsxXTsgLy8gUEVSRjogZXhpdCBlYXJseSBpZiB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlIGlzbid0IGhhbmdpbmcuXG5cblxuICAgIGlmIChzdGFydC5vZmZzZXQgIT09IDAgfHwgZW5kLm9mZnNldCAhPT0gMCB8fCBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgfHwgUGF0aC5oYXNQcmV2aW91cyhlbmQucGF0aCkpIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdDogZW5kLFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9LFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIGJsb2NrUGF0aCA9IGVuZEJsb2NrID8gZW5kQmxvY2tbMV0gOiBbXTtcbiAgICB2YXIgZmlyc3QgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBzdGFydCk7XG4gICAgdmFyIGJlZm9yZSA9IHtcbiAgICAgIGFuY2hvcjogZmlyc3QsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgICB2YXIgc2tpcCA9IHRydWU7XG5cbiAgICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGJlZm9yZSxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSksXG4gICAgICAgIF9zdGVwOTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA5JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA5LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDkkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXA5JHZhbHVlWzFdO1xuXG4gICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUudGV4dCAhPT0gJycgfHwgUGF0aC5pc0JlZm9yZShwYXRoLCBibG9ja1BhdGgpKSB7XG4gICAgICAgICAgZW5kID0ge1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogbm9kZS50ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjkuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I5LmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoIGEgdm9pZCBub2RlIGluIHRoZSBjdXJyZW50IGJyYW5jaCBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBcInZvaWRcIjogZnVuY3Rpb24gX3ZvaWQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGwgYSBmdW5jdGlvbiwgZGVmZXJyaW5nIG5vcm1hbGl6YXRpb24gdW50aWwgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gICAqL1xuICB3aXRob3V0Tm9ybWFsaXppbmc6IGZ1bmN0aW9uIHdpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZuKSB7XG4gICAgdmFyIHZhbHVlID0gRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKTtcbiAgICBFZGl0b3Iuc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmYWxzZSk7XG5cbiAgICB0cnkge1xuICAgICAgZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTtcbiAgfVxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0xvY2F0aW9uOiBmdW5jdGlvbiBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgU3BhbiA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgU3BhbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1NwYW46IGZ1bmN0aW9uIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDMgPSBbXCJjaGlsZHJlblwiXSxcbiAgICBfZXhjbHVkZWQyJDIgPSBbXCJ0ZXh0XCJdO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ0KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxudmFyIElTX05PREVfTElTVF9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIE5vZGUgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGFzc2VydGluZyB0aGF0IGl0J3MgYW4gYW5jZXN0b3Igbm9kZS5cclxuICAgKi9cbiAgYW5jZXN0b3I6IGZ1bmN0aW9uIGFuY2VzdG9yKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBhbmNlc3RvciBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gYSB0ZXh0IG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBhbmNlc3RvciBub2RlcyBhYm92ZSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBhbmNlc3RvciBpblxyXG4gICAqIHRoZSB0cmVlLCBidXQgeW91IGNhbiBwYXNzIHRoZSBgcmV2ZXJzZTogdHJ1ZWAgb3B0aW9uIHRvIGdvIGJvdHRvbS11cC5cclxuICAgKi9cbiAgYW5jZXN0b3JzOiBmdW5jdGlvbiogYW5jZXN0b3JzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChQYXRoLmFuY2VzdG9ycyhwYXRoLCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBuID0gTm9kZS5hbmNlc3Rvcihyb290LCBwKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gW24sIHBdO1xuICAgICAgICB5aWVsZCBlbnRyeTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY2hpbGQgb2YgYSBub2RlIGF0IGEgc3BlY2lmaWMgaW5kZXguXHJcbiAgICovXG4gIGNoaWxkOiBmdW5jdGlvbiBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiogY2hpbGRyZW4ocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciBjaGlsZHJlbiA9IGFuY2VzdG9yLmNoaWxkcmVuO1xuICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyBjaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgIHdoaWxlIChyZXZlcnNlID8gaW5kZXggPj0gMCA6IGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQgPSBOb2RlLmNoaWxkKGFuY2VzdG9yLCBpbmRleCk7XG4gICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5jb25jYXQoaW5kZXgpO1xuICAgICAgeWllbGQgW2NoaWxkLCBjaGlsZFBhdGhdO1xuICAgICAgaW5kZXggPSByZXZlcnNlID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYW4gZW50cnkgZm9yIHRoZSBjb21tb24gYW5jZXNldG9yIG5vZGUgb2YgdHdvIHBhdGhzLlxyXG4gICAqL1xuICBjb21tb246IGZ1bmN0aW9uIGNvbW1vbihyb290LCBwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIHAgPSBQYXRoLmNvbW1vbihwYXRoLCBhbm90aGVyKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhIGRlc2NlbmRhbnQgbm9kZS5cclxuICAgKi9cbiAgZGVzY2VuZGFudDogZnVuY3Rpb24gZGVzY2VuZGFudChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIHRoZSByb290IGVkaXRvciBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgZGVzY2VuZGFudCBub2RlIGVudHJpZXMgaW5zaWRlIGEgcm9vdCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50czogZnVuY3Rpb24qIGRlc2NlbmRhbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQoTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwMjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgdG8gY29lcmNlIGhlcmUgYmVjYXVzZSBjaGVja2luZyB0aGUgcGF0aCdzIGxlbmd0aCBkb2VzXG4gICAgICAgICAgLy8gZ3VhcmFudGVlIHRoYXQgYG5vZGVgIGlzIG5vdCBhIGBFZGl0b3JgLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cuXG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGdlbmVyYXRvciBvZiBhbGwgdGhlIGVsZW1lbnQgbm9kZXMgaW5zaWRlIGEgcm9vdCBub2RlLiBFYWNoIGl0ZXJhdGlvblxyXG4gICAqIHdpbGwgcmV0dXJuIGFuIGBFbGVtZW50RW50cnlgIHR1cGxlIGNvbnNpc3Rpbmcgb2YgYFtFbGVtZW50LCBQYXRoXWAuIElmIHRoZVxyXG4gICAqIHJvb3Qgbm9kZSBpcyBhbiBlbGVtZW50IGl0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGl0ZXJhdGlvbiBhcyB3ZWxsLlxyXG4gICAqL1xuICBlbGVtZW50czogZnVuY3Rpb24qIGVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQoTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwMztcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBFeHRyYWN0IHByb3BzIGZyb20gYSBOb2RlLlxyXG4gICAqL1xuICBleHRyYWN0UHJvcHM6IGZ1bmN0aW9uIGV4dHJhY3RQcm9wcyhub2RlKSB7XG4gICAgaWYgKEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSkge1xuICAgICAgbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnRleHQ7XG4gICAgICAgICAgdmFyIF9wcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMik7XG5cbiAgICAgIHJldHVybiBfcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBmaXJzdDogZnVuY3Rpb24gZmlyc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5bMF07XG4gICAgICAgIHAucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2xpY2VkIGZyYWdtZW50IHJlcHJlc2VudGVkIGJ5IGEgcmFuZ2UgaW5zaWRlIGEgcm9vdCBub2RlLlxyXG4gICAqL1xuICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQocm9vdCwgcmFuZ2UpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgYSBmcmFnbWVudCBzdGFydGluZyBmcm9tIGEgcm9vdCB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3Um9vdCA9IGltbWVyLnByb2R1Y2Uoe1xuICAgICAgY2hpbGRyZW46IHJvb3QuY2hpbGRyZW5cbiAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IGZ1bmN0aW9uIHBhc3MoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgICBwYXRoID0gX3JlZjJbMV07XG5cbiAgICAgICAgICByZXR1cm4gIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChub2RlRW50cmllcyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBwYXRoID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgICAgaWYgKCFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBsZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuICAgICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBzdGFydC5wYXRoKSkge1xuICAgICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgICBfbGVhZi50ZXh0ID0gX2xlYWYudGV4dC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChFZGl0b3IuaXNFZGl0b3IocikpIHtcbiAgICAgICAgci5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdSb290LmNoaWxkcmVuO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZGVzY2VuZGFudCBub2RlIHJlZmVycmVkIHRvIGJ5IGEgc3BlY2lmaWMgcGF0aC4gSWYgdGhlIHBhdGggaXMgYW5cclxuICAgKiBlbXB0eSBhcnJheSwgaXQgcmVmZXJzIHRvIHRoZSByb290IG5vZGUgaXRzZWxmLlxyXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uIGdldChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRlc2NlbmRhbnQgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIGRlc2NlbmRhbnQgbm9kZSBleGlzdHMgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBoYXM6IGZ1bmN0aW9uIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYE5vZGVgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gVGV4dC5pc1RleHQodmFsdWUpIHx8IEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSB8fCBFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBOb2RlYCBvYmplY3RzLlxyXG4gICAqL1xuICBpc05vZGVMaXN0OiBmdW5jdGlvbiBpc05vZGVMaXN0KHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjYWNoZWRSZXN1bHQgPSBJU19OT0RFX0xJU1RfQ0FDSEUuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChjYWNoZWRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlTGlzdCA9IHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBOb2RlLmlzTm9kZSh2YWwpO1xuICAgIH0pO1xuICAgIElTX05PREVfTElTVF9DQUNIRS5zZXQodmFsdWUsIGlzTm9kZUxpc3QpO1xuICAgIHJldHVybiBpc05vZGVMaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGFzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBsYXN0OiBmdW5jdGlvbiBsYXN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuXG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gbi5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBuID0gbi5jaGlsZHJlbltpXTtcbiAgICAgICAgcC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgZW5zdXJpbmcgaXQncyBhIGxlYWYgdGV4dCBub2RlLlxyXG4gICAqL1xuICBsZWFmOiBmdW5jdGlvbiBsZWFmKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbGVhZiBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gYSBub24tbGVhZiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGdlbmVyYXRvciBvZiB0aGUgaW4gYSBicmFuY2ggb2YgdGhlIHRyZWUsIGZyb20gYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3Qgbm9kZSBpbiB0aGUgdHJlZSxcclxuICAgKiBidXQgeW91IGNhbiBwYXNzIHRoZSBgcmV2ZXJzZTogdHJ1ZWAgb3B0aW9uIHRvIGdvIGJvdHRvbS11cC5cclxuICAgKi9cbiAgbGV2ZWxzOiBmdW5jdGlvbiogbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQoUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDU7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHAgPSBfc3RlcDUudmFsdWU7XG4gICAgICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIG1hdGNoZXMgYSBzZXQgb2YgcHJvcHMuXHJcbiAgICovXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMobm9kZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnRQcm9wcyhwcm9wcykgJiYgRWxlbWVudC5tYXRjaGVzKG5vZGUsIHByb3BzKSB8fCBUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0LmlzVGV4dFByb3BzKHByb3BzKSAmJiBUZXh0Lm1hdGNoZXMobm9kZSwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGdlbmVyYXRvciBvZiBhbGwgdGhlIG5vZGUgZW50cmllcyBvZiBhIHJvb3Qgbm9kZS4gRWFjaCBlbnRyeSBpc1xyXG4gICAqIHJldHVybmVkIGFzIGEgYFtOb2RlLCBQYXRoXWAgdHVwbGUsIHdpdGggdGhlIHBhdGggcmVmZXJyaW5nIHRvIHRoZSBub2RlJ3NcclxuICAgKiBwb3NpdGlvbiBpbnNpZGUgdGhlIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgbm9kZXM6IGZ1bmN0aW9uKiBub2Rlcyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBwYXNzID0gb3B0aW9ucy5wYXNzLFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlMiA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UyO1xuICAgIHZhciBfb3B0aW9ucyRmcm9tID0gb3B0aW9ucy5mcm9tLFxuICAgICAgICBmcm9tID0gX29wdGlvbnMkZnJvbSA9PT0gdm9pZCAwID8gW10gOiBfb3B0aW9ucyRmcm9tLFxuICAgICAgICB0byA9IG9wdGlvbnMudG87XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHAgPSBbXTtcbiAgICB2YXIgbiA9IHJvb3Q7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHRvICYmIChyZXZlcnNlID8gUGF0aC5pc0JlZm9yZShwLCB0bykgOiBQYXRoLmlzQWZ0ZXIocCwgdG8pKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuKSkge1xuICAgICAgICB5aWVsZCBbbiwgcF07XG4gICAgICB9IC8vIElmIHdlJ3JlIGFsbG93ZWQgdG8gZ28gZG93bndhcmQgYW5kIHdlIGhhdmVuJ3QgZGVzY2VuZGVkIHlldCwgZG8uXG5cblxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuKSAmJiAhVGV4dC5pc1RleHQobikgJiYgbi5jaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgKHBhc3MgPT0gbnVsbCB8fCBwYXNzKFtuLCBwXSkgPT09IGZhbHNlKSkge1xuICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IHJldmVyc2UgPyBuLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IocCwgZnJvbSkpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmcm9tW3AubGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLmNvbmNhdChuZXh0SW5kZXgpO1xuICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhdCB0aGUgcm9vdCBhbmQgd2UgY2FuJ3QgZ28gZG93biwgd2UncmUgZG9uZS5cblxuXG4gICAgICBpZiAocC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIElmIHdlJ3JlIGdvaW5nIGZvcndhcmQuLi5cblxuXG4gICAgICBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLm5leHQocCk7XG5cbiAgICAgICAgaWYgKE5vZGUuaGFzKHJvb3QsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgcCA9IG5ld1BhdGg7XG4gICAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIHdlJ3JlIGdvaW5nIGJhY2t3YXJkLi4uXG5cblxuICAgICAgaWYgKHJldmVyc2UgJiYgcFtwLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICAgIHZhciBfbmV3UGF0aCA9IFBhdGgucHJldmlvdXMocCk7XG5cbiAgICAgICAgcCA9IF9uZXdQYXRoO1xuICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBPdGhlcndpc2Ugd2UncmUgZ29pbmcgdXB3YXJkLi4uXG5cblxuICAgICAgcCA9IFBhdGgucGFyZW50KHApO1xuICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGFyZW50IG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICAgIHZhciBwID0gTm9kZS5nZXQocm9vdCwgcGFyZW50UGF0aCk7XG5cbiAgICBpZiAoVGV4dC5pc1RleHQocCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBvZiBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHJvb3QuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbmNhdGVuYXRlZCB0ZXh0IHN0cmluZyBvZiBhIG5vZGUncyBjb250ZW50LlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgaW5jbHVkZSBzcGFjZXMgb3IgbGluZSBicmVha3MgYmV0d2VlbiBibG9jayBub2Rlcy5cclxuICAgKiBJdCBpcyBub3QgYSB1c2VyLWZhY2luZyBzdHJpbmcsIGJ1dCBhIHN0cmluZyBmb3IgcGVyZm9ybWluZyBvZmZzZXQtcmVsYXRlZFxyXG4gICAqIGNvbXB1dGF0aW9ucyBmb3IgYSBub2RlLlxyXG4gICAqL1xuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIGxlYWYgdGV4dCBub2RlcyBpbiBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgdGV4dHM6IGZ1bmN0aW9uKiB0ZXh0cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDY7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXA2JHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwNiR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ3KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgT3BlcmF0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYE5vZGVPcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNOb2RlT3BlcmF0aW9uOiBmdW5jdGlvbiBpc05vZGVPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfbm9kZScpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc09wZXJhdGlvbjogZnVuY3Rpb24gaXNPcGVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5uZXdQYXRoKTtcblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgTm9kZS5pc05vZGUodmFsdWUubm9kZSk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnc3RyaW5nJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE9wZXJhdGlvbmAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNPcGVyYXRpb25MaXN0OiBmdW5jdGlvbiBpc09wZXJhdGlvbkxpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWwpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgU2VsZWN0aW9uT3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzU2VsZWN0aW9uT3BlcmF0aW9uOiBmdW5jdGlvbiBpc1NlbGVjdGlvbk9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ19zZWxlY3Rpb24nKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFRleHRPcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNUZXh0T3BlcmF0aW9uOiBmdW5jdGlvbiBpc1RleHRPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfdGV4dCcpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEludmVydCBhbiBvcGVyYXRpb24sIHJldHVybmluZyBhIG5ldyBvcGVyYXRpb24gdGhhdCB3aWxsIGV4YWN0bHkgdW5kbyB0aGVcclxuICAgKiBvcmlnaW5hbCB3aGVuIGFwcGxpZWQuXHJcbiAgICovXG4gIGludmVyc2U6IGZ1bmN0aW9uIGludmVyc2Uob3ApIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnc3BsaXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnByZXZpb3VzKG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuZXdQYXRoID0gb3AubmV3UGF0aCxcbiAgICAgICAgICAgICAgcGF0aCA9IG9wLnBhdGg7IC8vIFBFUkY6IGluIHRoaXMgY2FzZSB0aGUgbW92ZSBvcGVyYXRpb24gaXMgYSBuby1vcCBhbnl3YXlzLlxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgbW92ZSBoYXBwZW5zIGNvbXBsZXRlbHkgd2l0aGluIGEgc2luZ2xlIHBhcmVudCB0aGUgcGF0aCBhbmRcbiAgICAgICAgICAvLyBuZXdQYXRoIGFyZSBzdGFibGUgd2l0aCByZXNwZWN0IHRvIGVhY2ggb3RoZXIuXG5cblxuICAgICAgICAgIGlmIChQYXRoLmlzU2libGluZyhwYXRoLCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICAgICAgbmV3UGF0aDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgbW92ZSBkb2VzIG5vdCBoYXBwZW4gd2l0aGluIGEgc2luZ2xlIHBhcmVudCBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAgIC8vIGZvciB0aGUgbW92ZSB0byBpbXBhY3QgdGhlIHRydWUgcGF0aCB0byB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIG5vZGVcbiAgICAgICAgICAvLyB3YXMgcmVtb3ZlZCBmcm9tIGFuZCB3aGVyZSBpdCB3YXMgaW5zZXJ0ZWQuIFdlIGhhdmUgdG8gYWRqdXN0IGZvciB0aGlzXG4gICAgICAgICAgLy8gYW5kIGZpbmQgdGhlIG9yaWdpbmFsIHBhdGguIFdlIGNhbiBhY2NvbXBsaXNoIHRoaXMgKG9ubHkgaW4gbm9uLXNpYmxpbmcpXG4gICAgICAgICAgLy8gbW92ZXMgYnkgbG9va2luZyBhdCB0aGUgaW1wYWN0IG9mIHRoZSBtb3ZlIG9wZXJhdGlvbiBvbiB0aGUgbm9kZVxuICAgICAgICAgIC8vIGFmdGVyIHRoZSBvcmlnaW5hbCBtb3ZlIHBhdGguXG5cblxuICAgICAgICAgIHZhciBpbnZlcnNlUGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgICAgICB2YXIgaW52ZXJzZU5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShQYXRoLm5leHQocGF0aCksIG9wKTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcGF0aDogaW52ZXJzZVBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoOiBpbnZlcnNlTmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wcm9wZXJ0aWVzID0gb3AucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgX25ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgaWYgKF9wcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5uZXh0KG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBQYXRoID0ge1xuICAvKipcclxuICAgKiBHZXQgYSBsaXN0IG9mIGFuY2VzdG9yIHBhdGhzIGZvciBhIGdpdmVuIHBhdGguXHJcbiAgICpcclxuICAgKiBUaGUgcGF0aHMgYXJlIHNvcnRlZCBmcm9tIHNoYWxsb3dlc3QgdG8gZGVlcGVzdCBhbmNlc3Rvci4gSG93ZXZlciwgaWYgdGhlXHJcbiAgICogYHJldmVyc2U6IHRydWVgIG9wdGlvbiBpcyBwYXNzZWQsIHRoZXkgYXJlIHJldmVyc2VkLlxyXG4gICAqL1xuICBhbmNlc3RvcnM6IGZ1bmN0aW9uIGFuY2VzdG9ycyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uOiBmdW5jdGlvbiBjb21tb24ocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBjb21tb24gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggJiYgaSA8IGFub3RoZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuXG4gICAgICBpZiAoYXYgIT09IGJ2KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb21tb24ucHVzaChhdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1vbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDb21wYXJlIGEgcGF0aCB0byBhbm90aGVyLCByZXR1cm5pbmcgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBhdGhcclxuICAgKiB3YXMgYmVmb3JlLCBhdCwgb3IgYWZ0ZXIgdGhlIG90aGVyLlxyXG4gICAqXHJcbiAgICogTm90ZTogVHdvIHBhdGhzIG9mIHVuZXF1YWwgbGVuZ3RoIGNhbiBzdGlsbCByZWNlaXZlIGEgYDBgIHJlc3VsdCBpZiBvbmUgaXNcclxuICAgKiBkaXJlY3RseSBhYm92ZSBvciBiZWxvdyB0aGUgb3RoZXIuIElmIHlvdSB3YW50IGV4YWN0IG1hdGNoaW5nLCB1c2VcclxuICAgKiBbW1BhdGguZXF1YWxzXV0gaW5zdGVhZC5cclxuICAgKi9cbiAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHBhdGgubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSA8IGFub3RoZXJbaV0pIHJldHVybiAtMTtcbiAgICAgIGlmIChwYXRoW2ldID4gYW5vdGhlcltpXSkgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGVuZHMgYWZ0ZXIgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNBZnRlcjogZnVuY3Rpb24gZW5kc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2ID4gYnY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGVuZHMgYXQgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNBdDogZnVuY3Rpb24gZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBiZWZvcmUgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNCZWZvcmU6IGZ1bmN0aW9uIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSBhbm90aGVyLmxlbmd0aCAmJiBwYXRoLmV2ZXJ5KGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICByZXR1cm4gbiA9PT0gYW5vdGhlcltpXTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgcGF0aCBvZiBwcmV2aW91cyBzaWJsaW5nIG5vZGUgZXhpc3RzXHJcbiAgICovXG4gIGhhc1ByZXZpb3VzOiBmdW5jdGlvbiBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXI6IGZ1bmN0aW9uIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlOiBmdW5jdGlvbiBpc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGEgY2hpbGQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNDaGlsZDogZnVuY3Rpb24gaXNDaGlsZChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSBhbm90aGVyLmxlbmd0aCArIDEgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBlcXVhbCB0byBvciBhbiBhbmNlc3RvciBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NvbW1vbjogZnVuY3Rpb24gaXNDb21tb24ocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8PSBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGEgZGVzY2VuZGFudCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0Rlc2NlbmRhbnQ6IGZ1bmN0aW9uIGlzRGVzY2VuZGFudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyB0aGUgcGFyZW50IG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzUGFyZW50OiBmdW5jdGlvbiBpc1BhcmVudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoICsgMSA9PT0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlzIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFBhdGhgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNQYXRoOiBmdW5jdGlvbiBpc1BhdGgodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBzaWJsaW5nIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzU2libGluZzogZnVuY3Rpb24gaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBwYXRocyBhdCBldmVyeSBsZXZlbCBkb3duIHRvIGEgcGF0aC4gTm90ZTogdGhpcyBpcyB0aGUgc2FtZVxyXG4gICAqIGFzIGBQYXRoLmFuY2VzdG9yc2AsIGJ1dCBpbmNsdWRpbmcgdGhlIHBhdGggaXRzZWxmLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QuIEhvd2V2ZXIsIGlmIHRoZSBgcmV2ZXJzZTpcclxuICAgKiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgbGV2ZWxzOiBmdW5jdGlvbiBsZXZlbHMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZTIgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlMjtcbiAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKHBhdGguc2xpY2UoMCwgaSkpO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsaXN0LnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgbmV4dCBzaWJsaW5nIG5vZGUuXHJcbiAgICovXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBuZXh0IGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0ICsgMSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgb3BlcmF0aW9uIGNhbiBhZmZlY3QgcGF0aHMgb3Igbm90LiBVc2VkIGFzIGFuXHJcbiAgICogb3B0aW1pemF0aW9uIHdoZW4gdXBkYXRpbmcgZGlydHkgcGF0aHMgZHVyaW5nIG5vcm1hbGl6YXRpb25cclxuICAgKlxyXG4gICAqIE5PVEU6IFRoaXMgKm11c3QqIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiAndHJhbnNmb3JtJ1xyXG4gICAqIGJlbG93XHJcbiAgICovXG4gIG9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGg6IGZ1bmN0aW9uIG9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3BlcmF0aW9uKSB7XG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgcmV0dXJuIGEgbmV3IHBhdGggcmVmZXJyaW5nIHRvIHRoZSBwYXJlbnQgbm9kZSBhYm92ZSBpdC5cclxuICAgKi9cbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgcHJldmlvdXMgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gcHJldmlvdXMgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSBmaXJzdCBjaGlsZCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgd291bGQgcmVzdWx0IGluIGEgbmVnYXRpdmUgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgLSAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYSBwYXRoIHJlbGF0aXZlIHRvIGFuIGFuY2VzdG9yLlxyXG4gICAqL1xuICByZWxhdGl2ZTogZnVuY3Rpb24gcmVsYXRpdmUocGF0aCwgYW5jZXN0b3IpIHtcbiAgICBpZiAoIVBhdGguaXNBbmNlc3RvcihhbmNlc3RvciwgcGF0aCkgJiYgIVBhdGguZXF1YWxzKHBhdGgsIGFuY2VzdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcmVsYXRpdmUgcGF0aCBvZiBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbnNpZGUgYW5jZXN0b3IgW1wiKS5jb25jYXQoYW5jZXN0b3IsIFwiXSwgYmVjYXVzZSBpdCBpcyBub3QgYWJvdmUgb3IgZXF1YWwgdG8gdGhlIHBhdGguXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZShhbmNlc3Rvci5sZW5ndGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHBhdGggYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShwYXRoLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDsgLy8gUEVSRjogdXNlIGRlc3RydWN0aW5nIGluc3RlYWQgb2YgaW1tZXJcblxuICAgIHZhciBwID0gX3RvQ29uc3VtYWJsZUFycmF5KHBhdGgpO1xuXG4gICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7IC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG9wID0gb3BlcmF0aW9uLnBhdGg7XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AsIHApIHx8IFBhdGguZW5kc0JlZm9yZShvcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLCBwKSkge1xuICAgICAgICAgICAgcFtvcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3AgPSBvcGVyYXRpb24ucGF0aDtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AsIHApIHx8IFBhdGguaXNBbmNlc3Rvcihfb3AsIHApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AsIHApKSB7XG4gICAgICAgICAgICBwW19vcC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcDIgPSBvcGVyYXRpb24ucGF0aCxcbiAgICAgICAgICAgICAgcG9zaXRpb24gPSBvcGVyYXRpb24ucG9zaXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMiwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKF9vcDIsIHApKSB7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoXSArPSBwb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3AzID0gb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgICAgICAgIF9wb3NpdGlvbiA9IG9wZXJhdGlvbi5wb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AzLCBwKSkge1xuICAgICAgICAgICAgaWYgKGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgcFtwLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnYmFja3dhcmQnKSA7IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AzLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMywgcCkgJiYgcGF0aFtfb3AzLmxlbmd0aF0gPj0gX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGhdIC09IF9wb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcDQgPSBvcGVyYXRpb24ucGF0aCxcbiAgICAgICAgICAgICAgb25wID0gb3BlcmF0aW9uLm5ld1BhdGg7IC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDQsIG9ucCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzU2libGluZyhfb3A0LCBvbnApICYmIChQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxudmFyIFBhdGhSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcGF0aCByZWYncyBjdXJyZW50IHZhbHVlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQsXG4gICAgICAgIGFmZmluaXR5ID0gcmVmLmFmZmluaXR5O1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUGF0aC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcblxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ2KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ2KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBQb2ludCA9IHtcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBvaW50IHRvIGFub3RoZXIsIHJldHVybmluZyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgd2hldGhlciB0aGVcclxuICAgKiBwb2ludCB3YXMgYmVmb3JlLCBhdCwgb3IgYWZ0ZXIgdGhlIG90aGVyLlxyXG4gICAqL1xuICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gLTE7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gYW5vdGhlci5vZmZzZXQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXI6IGZ1bmN0aW9uIGlzQWZ0ZXIocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBiZWZvcmUgYW5vdGhlci5cclxuICAgKi9cbiAgaXNCZWZvcmU6IGZ1bmN0aW9uIGlzQmVmb3JlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMocG9pbnQsIGFub3RoZXIpIHtcbiAgICAvLyBQRVJGOiBlbnN1cmUgdGhlIG9mZnNldHMgYXJlIGVxdWFsIGZpcnN0IHNpbmNlIHRoZXkgYXJlIGNoZWFwZXIgdG8gY2hlY2suXG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gYW5vdGhlci5vZmZzZXQgJiYgUGF0aC5lcXVhbHMocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQb2ludGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1BvaW50OiBmdW5jdGlvbiBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIGEgcG9pbnQgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShwb2ludCwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIGltbWVyLnByb2R1Y2UocG9pbnQsIGZ1bmN0aW9uIChwKSB7XG4gICAgICBpZiAocCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgICAgIHZhciBwYXRoID0gcC5wYXRoLFxuICAgICAgICAgIG9mZnNldCA9IHAub2Zmc2V0O1xuXG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIChvcC5vZmZzZXQgPCBvZmZzZXQgfHwgb3Aub2Zmc2V0ID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIG9wLm9mZnNldCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgLT0gTWF0aC5taW4ob2Zmc2V0IC0gb3Aub2Zmc2V0LCBvcC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IFBhdGguaXNBbmNlc3RvcihvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBpZiAob3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AucG9zaXRpb24gPCBvZmZzZXQgfHwgb3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgICAgcC5vZmZzZXQgLT0gb3AucG9zaXRpb247XG4gICAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIF9vYmplY3RTcHJlYWQkNihfb2JqZWN0U3ByZWFkJDYoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBQb2ludFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwb2ludCByZWYncyBjdXJyZW50IHZhbHVlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQsXG4gICAgICAgIGFmZmluaXR5ID0gcmVmLmFmZmluaXR5O1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludCA9IFBvaW50LnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwb2ludDtcblxuICAgIGlmIChwb2ludCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDUob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFJhbmdlID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgcmFuZ2UsIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhclxyXG4gICAqIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gcmFuZ2UuZm9jdXM7XG4gICAgcmV0dXJuIFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpID09PSByZXZlcnNlID8gW2FuY2hvciwgZm9jdXNdIDogW2ZvY3VzLCBhbmNob3JdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZW5kIHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIGVuZDogZnVuY3Rpb24gZW5kKHJhbmdlKSB7XG4gICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICByZXR1cm4gZW5kO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhyYW5nZSwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocmFuZ2UuYW5jaG9yLCBhbm90aGVyLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKHJhbmdlLmZvY3VzLCBhbm90aGVyLmZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGluY2x1ZGVzIGEgcGF0aCwgYSBwb2ludCBvciBwYXJ0IG9mIGFub3RoZXIgcmFuZ2UuXHJcbiAgICovXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgaWYgKFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuYW5jaG9yKSB8fCBSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmZvY3VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgICAgIHJzID0gX1JhbmdlJGVkZ2VzNFswXSxcbiAgICAgICAgICByZSA9IF9SYW5nZSRlZGdlczRbMV07XG5cbiAgICAgIHZhciBfUmFuZ2UkZWRnZXM1ID0gUmFuZ2UuZWRnZXModGFyZ2V0KSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXM2ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNSwgMiksXG4gICAgICAgICAgdHMgPSBfUmFuZ2UkZWRnZXM2WzBdLFxuICAgICAgICAgIHRlID0gX1JhbmdlJGVkZ2VzNlsxXTtcblxuICAgICAgcmV0dXJuIFBvaW50LmlzQmVmb3JlKHJzLCB0cykgJiYgUG9pbnQuaXNBZnRlcihyZSwgdGUpO1xuICAgIH1cblxuICAgIHZhciBfUmFuZ2UkZWRnZXM3ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXM4ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNywgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzOFswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzOFsxXTtcblxuICAgIHZhciBpc0FmdGVyU3RhcnQgPSBmYWxzZTtcbiAgICB2YXIgaXNCZWZvcmVFbmQgPSBmYWxzZTtcblxuICAgIGlmIChQb2ludC5pc1BvaW50KHRhcmdldCkpIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBzdGFydCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIGVuZCkgPD0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUGF0aC5jb21wYXJlKHRhcmdldCwgc3RhcnQucGF0aCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUGF0aC5jb21wYXJlKHRhcmdldCwgZW5kLnBhdGgpIDw9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzQWZ0ZXJTdGFydCAmJiBpc0JlZm9yZUVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiBhIHJhbmdlIHdpdGggYW5vdGhlci5cclxuICAgKi9cbiAgaW50ZXJzZWN0aW9uOiBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByYW5nZS5hbmNob3I7XG4gICAgICAgIHJhbmdlLmZvY3VzO1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgX2V4Y2x1ZGVkJDIpO1xuXG4gICAgdmFyIF9SYW5nZSRlZGdlczkgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczEwID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzOSwgMiksXG4gICAgICAgIHMxID0gX1JhbmdlJGVkZ2VzMTBbMF0sXG4gICAgICAgIGUxID0gX1JhbmdlJGVkZ2VzMTBbMV07XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzMTEgPSBSYW5nZS5lZGdlcyhhbm90aGVyKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMTIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMxMSwgMiksXG4gICAgICAgIHMyID0gX1JhbmdlJGVkZ2VzMTJbMF0sXG4gICAgICAgIGUyID0gX1JhbmdlJGVkZ2VzMTJbMV07XG5cbiAgICB2YXIgc3RhcnQgPSBQb2ludC5pc0JlZm9yZShzMSwgczIpID8gczIgOiBzMTtcbiAgICB2YXIgZW5kID0gUG9pbnQuaXNCZWZvcmUoZTEsIGUyKSA/IGUxIDogZTI7XG5cbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ1KHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgYmFja3dhcmQsIG1lYW5pbmcgdGhhdCBpdHMgYW5jaG9yIHBvaW50IGFwcGVhcnMgaW4gdGhlXHJcbiAgICogZG9jdW1lbnQgX2FmdGVyXyBpdHMgZm9jdXMgcG9pbnQuXHJcbiAgICovXG4gIGlzQmFja3dhcmQ6IGZ1bmN0aW9uIGlzQmFja3dhcmQocmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgY29sbGFwc2VkLCBtZWFuaW5nIHRoYXQgYm90aCBpdHMgYW5jaG9yIGFuZCBmb2N1c1xyXG4gICAqIHBvaW50cyByZWZlciB0byB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGlzQ29sbGFwc2VkOiBmdW5jdGlvbiBpc0NvbGxhcHNlZChyYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gcmFuZ2UuZm9jdXM7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhhbmNob3IsIGZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4cGFuZGVkLlxyXG4gICAqXHJcbiAgICogVGhpcyBpcyB0aGUgb3Bwb3NpdGUgb2YgW1tSYW5nZS5pc0NvbGxhcHNlZF1dIGFuZCBpcyBwcm92aWRlZCBmb3IgbGVnaWJpbGl0eS5cclxuICAgKi9cbiAgaXNFeHBhbmRlZDogZnVuY3Rpb24gaXNFeHBhbmRlZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZm9yd2FyZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNCYWNrd2FyZF1dIGFuZCBpcyBwcm92aWRlZCBmb3IgbGVnaWJpbGl0eS5cclxuICAgKi9cbiAgaXNGb3J3YXJkOiBmdW5jdGlvbiBpc0ZvcndhcmQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgW1tSYW5nZV1dIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNSYW5nZTogZnVuY3Rpb24gaXNSYW5nZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBwb2ludCBlbnRyaWVzIGluIGEgcmFuZ2UuXHJcbiAgICovXG4gIHBvaW50czogZnVuY3Rpb24qIHBvaW50cyhyYW5nZSkge1xuICAgIHlpZWxkIFtyYW5nZS5hbmNob3IsICdhbmNob3InXTtcbiAgICB5aWVsZCBbcmFuZ2UuZm9jdXMsICdmb2N1cyddO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIF9SYW5nZSRlZGdlczEzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMxNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczEzLCAxKSxcbiAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMxNFswXTtcblxuICAgIHJldHVybiBzdGFydDtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSByYW5nZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gaW1tZXIucHJvZHVjZShyYW5nZSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdpbndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7XG4gICAgICB2YXIgYWZmaW5pdHlBbmNob3I7XG4gICAgICB2YXIgYWZmaW5pdHlGb2N1cztcblxuICAgICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAgIC8vIGF2b2lkIHRoZSB0d28gcG9pbnRzIHBhc3NpbmcgZWFjaCBvdGhlciBhbmQgZXhwYW5kaW5nIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocik7XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdvdXR3YXJkJykge1xuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBhZmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyLmFuY2hvciwgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgICB9KTtcbiAgICAgIHZhciBmb2N1cyA9IFBvaW50LnRyYW5zZm9ybShyLmZvY3VzLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlGb2N1c1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgci5hbmNob3IgPSBhbmNob3I7XG4gICAgICByLmZvY3VzID0gZm9jdXM7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBSYW5nZVJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSByYW5nZSByZWYncyBjdXJyZW50IHZhbHVlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQsXG4gICAgICAgIGFmZmluaXR5ID0gcmVmLmFmZmluaXR5O1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUmFuZ2UudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfc2NydWJiZXIgPSB1bmRlZmluZWQ7XG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgaW1wbGVtZW50cyBhIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLCB3aGljaCBpcyB1c2VkIGJ5IFNsYXRlXHJcbiAqIGludGVybmFsbHkgd2hlbiBnZW5lcmF0aW5nIGV4Y2VwdGlvbnMgY29udGFpbmluZyBlbmQgdXNlciBkYXRhLiBEZXZlbG9wZXJzXHJcbiAqIHVzaW5nIFNsYXRlIG1heSBjYWxsIFNjcnViYmVyLnNldFNjcnViYmVyKCkgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoaXNcclxuICogc3RyaW5naWZ5KCkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCB0byBwcmV2ZW50IHRoZSBjbGVhcnRleHQgbG9nZ2luZyBvZiAndGV4dCcgZmllbGRzIHdpdGhpbiBOb2RlczpcclxuICpcclxuICogICAgaW1wb3J0IHsgU2NydWJiZXIgfSBmcm9tICdzbGF0ZSc7XHJcbiAqICAgIFNjcnViYmVyLnNldFNjcnViYmVyKChrZXksIHZhbCkgPT4ge1xyXG4gKiAgICAgIGlmIChrZXkgPT09ICd0ZXh0JykgcmV0dXJuICcuLi5zY3J1YmJlZC4uLidcclxuICogICAgICByZXR1cm4gdmFsXHJcbiAqICAgIH0pO1xyXG4gKlxyXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIFNjcnViYmVyID0ge1xuICBzZXRTY3J1YmJlcjogZnVuY3Rpb24gc2V0U2NydWJiZXIoc2NydWJiZXIpIHtcbiAgICBfc2NydWJiZXIgPSBzY3J1YmJlcjtcbiAgfSxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cbn07XG5cbi8qXHJcbiAgQ3VzdG9tIGRlZXAgZXF1YWwgY29tcGFyaXNvbiBmb3IgU2xhdGUgbm9kZXMuXHJcblxuICBXZSBkb24ndCBuZWVkIGdlbmVyYWwgcHVycG9zZSBkZWVwIGVxdWFsaXR5O1xyXG4gIFNsYXRlIG9ubHkgc3VwcG9ydHMgcGxhaW4gdmFsdWVzLCBBcnJheXMsIGFuZCBuZXN0ZWQgb2JqZWN0cy5cclxuICBDb21wbGV4IHZhbHVlcyBuZXN0ZWQgaW5zaWRlIEFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cclxuXG4gIFNsYXRlIG9iamVjdHMgYXJlIGRlc2lnbmVkIHRvIGJlIHNlcmlhbGlzZWQsIHNvXHJcbiAgbWlzc2luZyBrZXlzIGFyZSBkZWxpYmVyYXRlbHkgbm9ybWFsaXNlZCB0byB1bmRlZmluZWQuXHJcbiAqL1xuXG52YXIgaXNEZWVwRXF1YWwgPSBmdW5jdGlvbiBpc0RlZXBFcXVhbChub2RlLCBhbm90aGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgdmFyIGEgPSBub2RlW2tleV07XG4gICAgdmFyIGIgPSBhbm90aGVyW2tleV07XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdChiKSkge1xuICAgICAgaWYgKCFpc0RlZXBFcXVhbChhLCBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYSAhPT0gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKlxyXG4gICAgRGVlcCBvYmplY3QgZXF1YWxpdHkgaXMgb25seSBuZWNlc3NhcnkgaW4gb25lIGRpcmVjdGlvbjsgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXHJcbiAgICB3ZSBhcmUgb25seSBsb29raW5nIGZvciBrZXlzIHRoYXQgYXJlIG1pc3NpbmcuXHJcbiAgICBBcyBhYm92ZSwgdW5kZWZpbmVkIGtleXMgYXJlIG5vcm1hbGlzZWQgdG8gbWlzc2luZy5cclxuICAqL1xuXG5cbiAgZm9yICh2YXIgX2tleSBpbiBhbm90aGVyKSB7XG4gICAgaWYgKG5vZGVbX2tleV0gPT09IHVuZGVmaW5lZCAmJiBhbm90aGVyW19rZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBfZXhjbHVkZWQkMSA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiQxID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDMoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIG93bktleXMkNChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgVGV4dCA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdHdvIHRleHQgbm9kZXMgYXJlIGVxdWFsLlxyXG4gICAqXHJcbiAgICogV2hlbiBsb29zZSBpcyBzZXQsIHRoZSB0ZXh0IGlzIG5vdCBjb21wYXJlZC4gVGhpcyBpc1xyXG4gICAqIHVzZWQgdG8gY2hlY2sgd2hldGhlciBzaWJsaW5nIHRleHQgbm9kZXMgY2FuIGJlIG1lcmdlZC5cclxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkbG9vc2UgPSBvcHRpb25zLmxvb3NlLFxuICAgICAgICBsb29zZSA9IF9vcHRpb25zJGxvb3NlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGxvb3NlO1xuXG4gICAgZnVuY3Rpb24gb21pdFRleHQob2JqKSB7XG4gICAgICBvYmoudGV4dDtcbiAgICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZCQxKTtcblxuICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgVGV4dGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1RleHQ6IGZ1bmN0aW9uIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnc3RyaW5nJztcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgVGV4dGAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNUZXh0TGlzdDogZnVuY3Rpb24gaXNUZXh0TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gVGV4dC5pc1RleHQodmFsKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBzb21lIHByb3BzIGFyZSBhIHBhcnRpYWwgb2YgVGV4dC5cclxuICAgKi9cbiAgaXNUZXh0UHJvcHM6IGZ1bmN0aW9uIGlzVGV4dFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiB0ZXh0IG1hdGNoZXMgc2V0IG9mIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBOb3RlOiB0aGlzIGlzIGZvciBtYXRjaGluZyBjdXN0b20gcHJvcGVydGllcywgYW5kIGl0IGRvZXMgbm90IGVuc3VyZSB0aGF0XHJcbiAgICogdGhlIGB0ZXh0YCBwcm9wZXJ0eSBhcmUgdHdvIG5vZGVzIGVxdWFsLlxyXG4gICAqL1xuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKHRleHQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IHRleHRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWF2ZXMgZm9yIGEgdGV4dCBub2RlIGdpdmVuIGRlY29yYXRpb25zLlxyXG4gICAqL1xuICBkZWNvcmF0aW9uczogZnVuY3Rpb24gZGVjb3JhdGlvbnMobm9kZSwgX2RlY29yYXRpb25zKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtfb2JqZWN0U3ByZWFkJDQoe30sIG5vZGUpXTtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKF9kZWNvcmF0aW9ucyksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBkZWMgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICB2YXIgYW5jaG9yID0gZGVjLmFuY2hvcixcbiAgICAgICAgICAgIGZvY3VzID0gZGVjLmZvY3VzLFxuICAgICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhkZWMsIF9leGNsdWRlZDIkMSk7XG5cbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGRlYyksXG4gICAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgICAgdmFyIGxlYWZFbmQgPSAwO1xuICAgICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgICB2YXIgZGVjb3JhdGlvbkVuZCA9IGVuZC5vZmZzZXQ7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKGxlYXZlcyksXG4gICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGxlYWYgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGVhZi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsZWFmU3RhcnQgPSBsZWFmRW5kO1xuICAgICAgICAgICAgbGVhZkVuZCArPSBsZW5ndGg7IC8vIElmIHRoZSByYW5nZSBlbmNvbXBhc3NlcyB0aGUgZW50aXJlIGxlYWYsIGFkZCB0aGUgcmFuZ2UuXG5cbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPD0gbGVhZlN0YXJ0ICYmIGxlYWZFbmQgPD0gZGVjb3JhdGlvbkVuZCkge1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGxlYWYsIHJlc3QpO1xuICAgICAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBJZiB0aGUgcmFuZ2UgZXhwYW5kZWQgYW5kIG1hdGNoIHRoZSBsZWFmLCBvciBzdGFydHMgYWZ0ZXIsIG9yIGVuZHMgYmVmb3JlIGl0LCBjb250aW51ZS5cblxuXG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ICE9PSBkZWNvcmF0aW9uRW5kICYmIChkZWNvcmF0aW9uU3RhcnQgPT09IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0KSB8fCBkZWNvcmF0aW9uU3RhcnQgPiBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPCBsZWFmU3RhcnQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0ICYmIGxlYWZTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBzcGxpdCB0aGUgbGVhZiwgYXQgdGhlIHN0YXJ0LCBlbmQsIG9yIGJvdGgsXG4gICAgICAgICAgICAvLyBhbmQgYWRkIHRoZSByYW5nZSB0byB0aGUgbWlkZGxlIGludGVyc2VjdGluZyBzZWN0aW9uLiBEbyB0aGUgZW5kXG4gICAgICAgICAgICAvLyBzcGxpdCBmaXJzdCBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgb2Zmc2V0IHRoYXQgd2F5LlxuXG5cbiAgICAgICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25FbmQgPCBsZWFmRW5kKSB7XG4gICAgICAgICAgICAgIHZhciBvZmYgPSBkZWNvcmF0aW9uRW5kIC0gbGVhZlN0YXJ0O1xuICAgICAgICAgICAgICBhZnRlciA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2Uob2ZmKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBvZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ID4gbGVhZlN0YXJ0KSB7XG4gICAgICAgICAgICAgIHZhciBfb2ZmID0gZGVjb3JhdGlvblN0YXJ0IC0gbGVhZlN0YXJ0O1xuXG4gICAgICAgICAgICAgIGJlZm9yZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWlkZGxlLCByZXN0KTtcblxuICAgICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgICBuZXh0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dC5wdXNoKG1pZGRsZSk7XG5cbiAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZWF2ZXMgPSBuZXh0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhdmVzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMihhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIGFwcGx5VG9EcmFmdCA9IGZ1bmN0aW9uIGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApIHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgcGF0aCA9IG9wLnBhdGgsXG4gICAgICAgICAgICBub2RlID0gb3Aubm9kZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIFxcXCJpbnNlcnRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBub2RlLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBwb2ludCA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW2tleV0gPSBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aCA9IG9wLnBhdGgsXG4gICAgICAgICAgICBvZmZzZXQgPSBvcC5vZmZzZXQsXG4gICAgICAgICAgICB0ZXh0ID0gb3AudGV4dDtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgICAgICB2YXIgX25vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aCk7XG5cbiAgICAgICAgdmFyIGJlZm9yZSA9IF9ub2RlLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICAgICAgICB2YXIgYWZ0ZXIgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgX25vZGUudGV4dCA9IGJlZm9yZSArIHRleHQgKyBhZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgX3BvaW50ID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleSA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoMiA9IG9wLnBhdGg7XG5cbiAgICAgICAgdmFyIF9ub2RlMiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2ID0gTm9kZS5nZXQoZWRpdG9yLCBwcmV2UGF0aCk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIF9pbmRleCA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlMikgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICBwcmV2LnRleHQgKz0gX25vZGUyLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIVRleHQuaXNUZXh0KF9ub2RlMikgJiYgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgdmFyIF9wcmV2JGNoaWxkcmVuO1xuXG4gICAgICAgICAgKF9wcmV2JGNoaWxkcmVuID0gcHJldi5jaGlsZHJlbikucHVzaC5hcHBseShfcHJldiRjaGlsZHJlbiwgX3RvQ29uc3VtYWJsZUFycmF5KF9ub2RlMi5jaGlsZHJlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmZhY2VzOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbm9kZTIpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4LCAxKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgX3BvaW50MiA9IF9zdGVwMyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXkyID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5Ml0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Miwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoMyA9IG9wLnBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoID0gb3AubmV3UGF0aDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBhIHBhdGggW1wiLmNvbmNhdChfcGF0aDMsIFwiXSB0byBuZXcgcGF0aCBbXCIpLmNvbmNhdChuZXdQYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgaW5zaWRlIGl0c2VsZi5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX3BhcmVudDIgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdOyAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIHNlY29uZCBzdGVwJ3MgcGF0aCBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGFwcGxpZWQuXG5cbiAgICAgICAgX3BhcmVudDIuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDIsIDEpO1xuXG4gICAgICAgIHZhciB0cnVlUGF0aCA9IFBhdGgudHJhbnNmb3JtKF9wYXRoMywgb3ApO1xuICAgICAgICB2YXIgbmV3UGFyZW50ID0gTm9kZS5nZXQoZWRpdG9yLCBQYXRoLnBhcmVudCh0cnVlUGF0aCkpO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSB0cnVlUGF0aFt0cnVlUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgbmV3UGFyZW50LmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgX25vZGUzKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgX3BvaW50MyA9IF9zdGVwNCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXkzID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5M10gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Mywgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGg0ID0gb3AucGF0aDtcbiAgICAgICAgdmFyIF9pbmRleDMgPSBfcGF0aDRbX3BhdGg0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBfcGFyZW50MyA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg0KTtcblxuICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7IC8vIFRyYW5zZm9ybSBhbGwgb2YgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cblxuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwNSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNS52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0ID0gX3N0ZXA1JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleTQgPSBfc3RlcDUkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ0LCBvcCk7XG5cbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsICYmIHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX3ByZXYgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihOb2RlLnRleHRzKGVkaXRvcikpLFxuICAgICAgICAgICAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gX3N0ZXA2JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IF9zdGVwNiR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoUGF0aC5jb21wYXJlKHAsIF9wYXRoNCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3ByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcmVmZXJOZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgbmV4dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5leHRbMV0sIF9wYXRoNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9ICFQYXRoLmhhc1ByZXZpb3VzKG5leHRbMV0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9IFBhdGguY29tbW9uKF9wcmV2WzFdLCBfcGF0aDQpLmxlbmd0aCA8IFBhdGguY29tbW9uKG5leHRbMV0sIF9wYXRoNCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcHJldiAmJiAhcHJlZmVyTmV4dCkge1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gX3ByZXZbMV07XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IF9wcmV2WzBdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5wYXRoID0gbmV4dFsxXTtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNSA9IG9wLnBhdGgsXG4gICAgICAgICAgICBfb2Zmc2V0ID0gb3Aub2Zmc2V0LFxuICAgICAgICAgICAgX3RleHQgPSBvcC50ZXh0O1xuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgICAgICB2YXIgX25vZGU0ID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGg1KTtcblxuICAgICAgICB2YXIgX2JlZm9yZSA9IF9ub2RlNC50ZXh0LnNsaWNlKDAsIF9vZmZzZXQpO1xuXG4gICAgICAgIHZhciBfYWZ0ZXIgPSBfbm9kZTQudGV4dC5zbGljZShfb2Zmc2V0ICsgX3RleHQubGVuZ3RoKTtcblxuICAgICAgICBfbm9kZTQudGV4dCA9IF9iZWZvcmUgKyBfYWZ0ZXI7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwNztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXA3JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA3LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludDUgPSBfc3RlcDckdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5NSA9IF9zdGVwNyR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTVdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDUsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNiA9IG9wLnBhdGgsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gb3AucHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChfcGF0aDYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSByb290IG5vZGUhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlNSA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg2KTtcblxuICAgICAgICBmb3IgKHZhciBfa2V5NiBpbiBuZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKF9rZXk2ID09PSAnY2hpbGRyZW4nIHx8IF9rZXk2ID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIFxcXCJcIi5jb25jYXQoX2tleTYsIFwiXFxcIiBwcm9wZXJ0eSBvZiBub2RlcyFcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1Byb3BlcnRpZXNbX2tleTZdO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTZdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbm9kZTVbX2tleTZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHByb3BlcnRpZXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgZGVmaW5lZCwgYnV0IGFyZSBub3cgbWlzc2luZywgbXVzdCBiZSBkZWxldGVkXG5cblxuICAgICAgICBmb3IgKHZhciBfa2V5NyBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9rZXk3KSkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5N107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9uZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcblxuICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0aW9uID0gX29iamVjdFNwcmVhZCQzKHt9LCBfbmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2tleTggaW4gX25ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBfdmFsdWUgPSBfbmV3UHJvcGVydGllc1tfa2V5OF07XG5cbiAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoX2tleTggPT09ICdhbmNob3InIHx8IF9rZXk4ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgXFxcIlwiLmNvbmNhdChfa2V5OCwgXCJcXFwiIHNlbGVjdGlvbiBwcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgc2VsZWN0aW9uW19rZXk4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OF0gPSBfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNyA9IG9wLnBhdGgsXG4gICAgICAgICAgICBwb3NpdGlvbiA9IG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgX3Byb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChfcGF0aDcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlNiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV3Tm9kZTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGU2KSkge1xuICAgICAgICAgIHZhciBfYmVmb3JlMiA9IF9ub2RlNi50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIyID0gX25vZGU2LnRleHQuc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgX25vZGU2LnRleHQgPSBfYmVmb3JlMjtcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogX2FmdGVyMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfYmVmb3JlMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYuY2hpbGRyZW4gPSBfYmVmb3JlMztcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlcjNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wYXJlbnQ0LmNoaWxkcmVuLnNwbGljZShfaW5kZXg0ICsgMSwgMCwgbmV3Tm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwODtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXA4JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA4LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludDYgPSBfc3RlcDgkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5OSA9IF9zdGVwOCR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDYsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I4LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb247XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cblxudmFyIEdlbmVyYWxUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIGVkaXRvciBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBpbW1lci5jcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGltbWVyLmNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGVjdGlvbiA9IGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlZGl0b3IuY2hpbGRyZW4gPSBpbW1lci5maW5pc2hEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBpbW1lci5pc0RyYWZ0KHNlbGVjdGlvbikgPyBpbW1lci5maW5pc2hEcmFmdChzZWxlY3Rpb24pIDogc2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyID0gW1wiY2hpbGRyZW5cIl07XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQxKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgTm9kZVRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIEluc2VydCBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIGluc2VydE5vZGVzOiBmdW5jdGlvbiBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkaGFuZ2luZyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzLFxuICAgICAgICAgIF9vcHRpb25zJG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTtcbiAgICAgIHZhciBhdCA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICAgIHNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0O1xuXG4gICAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfbm9kZXMgPSBub2RlcyxcbiAgICAgICAgICBfbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX25vZGVzLCAxKSxcbiAgICAgICAgICBub2RlID0gX25vZGVzMlswXTsgLy8gQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXG4gICAgICAvLyBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxuICAgICAgLy8gY29tbW9uIHVzZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIGZyb20gYSBub24tc2VsZWN0ZWQgc3RhdGUuXG5cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdCA9IFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdC5wYXRoLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICAgICAgICBlbnRyeSA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBfZW50cnkgPSBfc2xpY2VkVG9BcnJheShlbnRyeSwgMiksXG4gICAgICAgICAgICAgIF9tYXRjaFBhdGggPSBfZW50cnlbMV07XG5cbiAgICAgICAgICB2YXIgcGF0aFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgX21hdGNoUGF0aCk7XG4gICAgICAgICAgdmFyIGlzQXRFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgX21hdGNoUGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gaXNBdEVuZCA/IFBhdGgubmV4dChwYXRoKSA6IHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQoYXQpO1xuICAgICAgdmFyIGluZGV4ID0gYXRbYXQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobm9kZXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfbm9kZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgbm9kZTogX25vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IFBhdGgubmV4dChhdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgYXQgPSBQYXRoLnByZXZpb3VzKGF0KTtcblxuICAgICAgaWYgKHNlbGVjdCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuXG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTGlmdCBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIHVwd2FyZHMgaW4gdGhlIGRvY3VtZW50IHRyZWUsIHNwbGl0dGluZ1xyXG4gICAqIHRoZWlyIHBhcmVudCBpbiB0d28gaWYgbmVjZXNzYXJ5LlxyXG4gICAqL1xuICBsaWZ0Tm9kZXM6IGZ1bmN0aW9uIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgICAgIF9vcHRpb25zJG1vZGUyID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlMiA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlMixcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczIgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMjtcbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBwID0gX3JlZjJbMV07XG5cbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfcGF0aFJlZnMgPSBwYXRoUmVmczsgX2kgPCBfcGF0aFJlZnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwYXRoUmVmID0gX3BhdGhSZWZzW19pXTtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBsaWZ0IG5vZGUgYXQgYSBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgaGFzIGEgZGVwdGggb2YgbGVzcyB0aGFuIGAyYC5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudE5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5wYXJlbnQocGF0aCkpO1xuXG4gICAgICAgIHZhciBfcGFyZW50Tm9kZUVudHJ5ID0gX3NsaWNlZFRvQXJyYXkocGFyZW50Tm9kZUVudHJ5LCAyKSxcbiAgICAgICAgICAgIHBhcmVudCA9IF9wYXJlbnROb2RlRW50cnlbMF0sXG4gICAgICAgICAgICBwYXJlbnRQYXRoID0gX3BhcmVudE5vZGVFbnRyeVsxXTtcblxuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YXIgdG9QYXRoID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogdG9QYXRoLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXJlbnRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHZhciBfdG9QYXRoID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiBfdG9QYXRoLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNwbGl0UGF0aCA9IFBhdGgubmV4dChwYXRoKTtcblxuICAgICAgICAgIHZhciBfdG9QYXRoMiA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBzcGxpdFBhdGgsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNZXJnZSBhIG5vZGUgYXQgYSBsb2NhdGlvbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlIG9mIHRoZSBzYW1lIGRlcHRoLFxyXG4gICAqIHJlbW92aW5nIGFueSBlbXB0eSBjb250YWluaW5nIG5vZGVzIGFmdGVyIHRoZSBtZXJnZSBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIG1lcmdlTm9kZXM6IGZ1bmN0aW9uIG1lcmdlTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICAgIF9vcHRpb25zJGF0MiA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDIgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDI7XG4gICAgICB2YXIgX29wdGlvbnMkaGFuZ2luZzIgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmcyLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzMyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMzLFxuICAgICAgICAgIF9vcHRpb25zJG1vZGUzID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlMyA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlMztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMSksXG4gICAgICAgICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50MlswXTtcblxuICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfRWRpdG9yJG5vZGVzMyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSksXG4gICAgICAgICAgX0VkaXRvciRub2RlczQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzMywgMSksXG4gICAgICAgICAgY3VycmVudCA9IF9FZGl0b3Ikbm9kZXM0WzBdO1xuXG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY3VycmVudCB8fCAhcHJldikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfY3VycmVudCA9IF9zbGljZWRUb0FycmF5KGN1cnJlbnQsIDIpLFxuICAgICAgICAgIG5vZGUgPSBfY3VycmVudFswXSxcbiAgICAgICAgICBwYXRoID0gX2N1cnJlbnRbMV07XG5cbiAgICAgIHZhciBfcHJldiA9IF9zbGljZWRUb0FycmF5KHByZXYsIDIpLFxuICAgICAgICAgIHByZXZOb2RlID0gX3ByZXZbMF0sXG4gICAgICAgICAgcHJldlBhdGggPSBfcHJldlsxXTtcblxuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHByZXZQYXRoKTtcbiAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24ocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGxldmVscyA9IEFycmF5LmZyb20oRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgICAgICAgbiA9IF9yZWY0WzBdO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTsgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuXG4gICAgICB2YXIgZW1wdHlBbmNlc3RvciA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gbGV2ZWxzLmluY2x1ZGVzKG4pICYmIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBlbXB0eVJlZiA9IGVtcHR5QW5jZXN0b3IgJiYgRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbXB0eUFuY2VzdG9yWzFdKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgICAgdmFyIHBvc2l0aW9uOyAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuICAgICAgICBub2RlLnRleHQ7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHRoZSBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldk5vZGUpKSk7XG4gICAgICB9IC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cblxuXG4gICAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBuZXdQYXRoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gSWYgdGhlcmUgd2FzIGdvaW5nIHRvIGJlIGFuIGVtcHR5IGFuY2VzdG9yIG9mIHRoZSBub2RlIHRoYXQgd2FzIG1lcmdlZCxcbiAgICAgIC8vIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSB0cmVlLlxuXG5cbiAgICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbXB0eVJlZi5jdXJyZW50LFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuICAgICAgLy8gb2YgbWVyZ2luZyB0aGUgdHdvLiBUaGlzIGlzIGEgY29tbW9uIHJpY2ggdGV4dCBlZGl0b3IgYmVoYXZpb3IgdG9cbiAgICAgIC8vIHByZXZlbnQgbG9zaW5nIGZvcm1hdHRpbmcgd2hlbiBkZWxldGluZyBlbnRpcmUgbm9kZXMgd2hlbiB5b3UgaGF2ZSBhXG4gICAgICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbiAgICAgIC8vIGlmIHByZXZOb2RlIGlzIGZpcnN0IGNoaWxkIGluIHBhcmVudCxkb24ndCByZW1vdmUgaXQuXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSB8fCBUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycgJiYgcHJldlBhdGhbcHJldlBhdGgubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcHJldlBhdGgsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICAgIGVtcHR5UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiB0byBhIG5ldyBsb2NhdGlvbi5cclxuICAgKi9cbiAgbW92ZU5vZGVzOiBmdW5jdGlvbiBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0byA9IG9wdGlvbnMudG8sXG4gICAgICAgICAgX29wdGlvbnMkYXQzID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0MyA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MyxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlNCA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTQgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTQsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHM0ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczQ7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9SZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHRvKTtcbiAgICAgIHZhciB0YXJnZXRzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20odGFyZ2V0cywgZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmNlsxXTtcblxuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBfcGF0aFJlZnMyID0gcGF0aFJlZnM7IF9pMiA8IF9wYXRoUmVmczIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgcGF0aFJlZiA9IF9wYXRoUmVmczJbX2kyXTtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ21vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogbmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvUmVmLmN1cnJlbnQgJiYgUGF0aC5pc1NpYmxpbmcobmV3UGF0aCwgcGF0aCkgJiYgUGF0aC5pc0FmdGVyKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgICAgLy8gdG8gYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgaW5zdGVhZCBvZiBhZnRlci4gVG8gZW5zdXJlIG91ciBncm91cCBvZiBub2RlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgICAvLyBpbiB0aGUgY29ycmVjdCBvcmRlciB3ZSBpbmNyZW1lbnQgdG9SZWYgdG8gYWNjb3VudCBmb3IgdGhhdFxuICAgICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9SZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICByZW1vdmVOb2RlczogZnVuY3Rpb24gcmVtb3ZlTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkaGFuZ2luZzMgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmczID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmczLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzNSA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM1LFxuICAgICAgICAgIF9vcHRpb25zJG1vZGU1ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlNSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlNTtcbiAgICAgIHZhciBfb3B0aW9ucyRhdDQgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQ0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ0LFxuICAgICAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMiksXG4gICAgICAgICAgICBwID0gX3JlZjhbMV07XG5cbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgX2kzID0gMCwgX3BhdGhSZWZzMyA9IHBhdGhSZWZzOyBfaTMgPCBfcGF0aFJlZnMzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdmFyIHBhdGhSZWYgPSBfcGF0aFJlZnMzW19pM107XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgICAgIF9FZGl0b3Ikbm9kZTIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUsIDEpLFxuICAgICAgICAgICAgICBub2RlID0gX0VkaXRvciRub2RlMlswXTtcblxuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX25vZGUnLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgc2V0Tm9kZXM6IGZ1bmN0aW9uIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgICAgX29wdGlvbnMkYXQ1ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0NSA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NSxcbiAgICAgICAgICBjb21wYXJlID0gb3B0aW9ucy5jb21wYXJlLFxuICAgICAgICAgIG1lcmdlID0gb3B0aW9ucy5tZXJnZTtcbiAgICAgIHZhciBfb3B0aW9ucyRoYW5naW5nNCA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZzQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZzQsXG4gICAgICAgICAgX29wdGlvbnMkbW9kZTYgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU2ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU2LFxuICAgICAgICAgIF9vcHRpb25zJHNwbGl0ID0gb3B0aW9ucy5zcGxpdCxcbiAgICAgICAgICBzcGxpdCA9IF9vcHRpb25zJHNwbGl0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0LFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzNiA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczYgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM2O1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkgJiYgRWRpdG9yLmxlYWYoZWRpdG9yLCBhdC5hbmNob3IpWzBdLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQgaW4gYSBub24tZW1wdHkgbm9kZSBhbmQgJ3NwbGl0JyBpcyB0cnVlLCB0aGVyZSdzIG5vdGhpbmcgdG9cbiAgICAgICAgICAvLyBzZXQgdGhhdCB3b24ndCBnZXQgbm9ybWFsaXplZCBhd2F5XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlczUgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICBfUmFuZ2UkZWRnZXM2ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNSwgMiksXG4gICAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczZbMF0sXG4gICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM2WzFdO1xuXG4gICAgICAgIHZhciBzcGxpdE1vZGUgPSBtb2RlID09PSAnbG93ZXN0JyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnO1xuICAgICAgICB2YXIgZW5kQXRFbmRPZk5vZGUgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBlbmQsIGVuZC5wYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmQsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgICAgICBhbHdheXM6ICFzdGFydEF0U3RhcnRPZk5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb21wYXJlKSB7XG4gICAgICAgIGNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHByb3AsIG5vZGVQcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3AgIT09IG5vZGVQcm9wO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBub2RlID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICBwYXRoID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICB2YXIgbmV3UHJvcGVydGllcyA9IHt9OyAvLyBZb3UgY2FuJ3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIGVkaXRvciBub2RlLlxuXG4gICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKGsgPT09ICdjaGlsZHJlbicgfHwgayA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFyZShwcm9wc1trXSwgbm9kZVtrXSkpIHtcbiAgICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7IC8vIE9taXQgbmV3IHByb3BlcnRpZXMgZnJvbSB0aGUgb2xkIHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTsgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trXSAhPSBudWxsKSBuZXdQcm9wZXJ0aWVzW2tdID0gbWVyZ2Uobm9kZVtrXSwgcHJvcHNba10pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trXSAhPSBudWxsKSBuZXdQcm9wZXJ0aWVzW2tdID0gcHJvcHNba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzQ2hhbmdlcykge1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NldF9ub2RlJyxcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogbmV3UHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTcGxpdCB0aGUgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cclxuICAgKi9cbiAgc3BsaXROb2RlczogZnVuY3Rpb24gc3BsaXROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRtb2RlNyA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTcgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTcsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHM3ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczc7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICAgIF9vcHRpb25zJGF0NiA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDYgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDYsXG4gICAgICAgICAgX29wdGlvbnMkaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0ID0gX29wdGlvbnMkaGVpZ2h0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkaGVpZ2h0LFxuICAgICAgICAgIF9vcHRpb25zJGFsd2F5cyA9IG9wdGlvbnMuYWx3YXlzLFxuICAgICAgICAgIGFsd2F5cyA9IF9vcHRpb25zJGFsd2F5cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHdheXM7XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBkZWxldGVSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH0gLy8gSWYgdGhlIHRhcmdldCBpcyBhIHBhdGgsIHRoZSBkZWZhdWx0IGhlaWdodC1za2lwcGluZyBhbmQgcG9zaXRpb25cbiAgICAgIC8vIGNvdW50ZXJzIG5lZWQgdG8gYWNjb3VudCBmb3IgdXMgcG90ZW50aWFsbHkgc3BsaXR0aW5nIGF0IGEgbm9uLWxlYWYuXG5cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgcGF0aCA9IGF0O1xuICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQzID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQzLCAxKSxcbiAgICAgICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50NFswXTtcblxuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gbiA9PT0gcGFyZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIGhlaWdodCA9IHBvaW50LnBhdGgubGVuZ3RoIC0gcGF0aC5sZW5ndGggKyAxO1xuICAgICAgICBhdCA9IHBvaW50O1xuICAgICAgICBhbHdheXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJlZm9yZVJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBhZnRlclJlZjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZXM1ID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSksXG4gICAgICAgICAgICBfRWRpdG9yJG5vZGVzNiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXM1LCAxKSxcbiAgICAgICAgICAgIGhpZ2hlc3QgPSBfRWRpdG9yJG5vZGVzNlswXTtcblxuICAgICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbnVkZ2UgPSAwO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIF92b2lkTWF0Y2ggPSBfc2xpY2VkVG9BcnJheSh2b2lkTWF0Y2gsIDIpLFxuICAgICAgICAgICAgICB2b2lkTm9kZSA9IF92b2lkTWF0Y2hbMF0sXG4gICAgICAgICAgICAgIHZvaWRQYXRoID0gX3ZvaWRNYXRjaFsxXTtcblxuICAgICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudCh2b2lkTm9kZSkgJiYgZWRpdG9yLmlzSW5saW5lKHZvaWROb2RlKSkge1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgdm9pZFBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoIWFmdGVyKSB7XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZhciBhZnRlclBhdGggPSBQYXRoLm5leHQodm9pZFBhdGgpO1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgdGV4dCwge1xuICAgICAgICAgICAgICAgIGF0OiBhZnRlclBhdGgsXG4gICAgICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhZnRlciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGFmdGVyUGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgICAgICBhbHdheXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzaWJsaW5nSGVpZ2h0ID0gYXQucGF0aC5sZW5ndGggLSB2b2lkUGF0aC5sZW5ndGg7XG4gICAgICAgICAgaGVpZ2h0ID0gc2libGluZ0hlaWdodCArIDE7XG4gICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFmdGVyUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQpO1xuICAgICAgICB2YXIgZGVwdGggPSBhdC5wYXRoLmxlbmd0aCAtIGhlaWdodDtcblxuICAgICAgICB2YXIgX2hpZ2hlc3QgPSBfc2xpY2VkVG9BcnJheShoaWdoZXN0LCAyKSxcbiAgICAgICAgICAgIGhpZ2hlc3RQYXRoID0gX2hpZ2hlc3RbMV07XG5cbiAgICAgICAgdmFyIGxvd2VzdFBhdGggPSBhdC5wYXRoLnNsaWNlKDAsIGRlcHRoKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gaGVpZ2h0ID09PSAwID8gYXQub2Zmc2V0IDogYXQucGF0aFtkZXB0aF0gKyBudWRnZTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogbG93ZXN0UGF0aCxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSksXG4gICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgbm9kZSA9IF9zdGVwMyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBfcGF0aDIgPSBfc3RlcDMkdmFsdWVbMV07XG5cbiAgICAgICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoX3BhdGgyLmxlbmd0aCA8IGhpZ2hlc3RQYXRoLmxlbmd0aCB8fCBfcGF0aDIubGVuZ3RoID09PSAwIHx8ICF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfcG9pbnQyID0gYmVmb3JlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgaXNFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBfcG9pbnQyLCBfcGF0aDIpO1xuXG4gICAgICAgICAgICBpZiAoYWx3YXlzIHx8ICFiZWZvcmVSZWYgfHwgIUVkaXRvci5pc0VkZ2UoZWRpdG9yLCBfcG9pbnQyLCBfcGF0aDIpKSB7XG4gICAgICAgICAgICAgIHNwbGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBOb2RlLmV4dHJhY3RQcm9wcyhub2RlKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3BsaXRfbm9kZScsXG4gICAgICAgICAgICAgICAgcGF0aDogX3BhdGgyLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbiA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX3BvaW50ID0gYWZ0ZXJSZWYuY3VycmVudCB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcG9pbnQpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB2YXIgX2FmdGVyUmVmO1xuXG4gICAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgICAoX2FmdGVyUmVmID0gYWZ0ZXJSZWYpID09PSBudWxsIHx8IF9hZnRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgdW5zZXROb2RlczogZnVuY3Rpb24gdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgcHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cblxuICAgIHZhciBvYmogPSB7fTtcblxuICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShwcm9wcyksXG4gICAgICAgIF9zdGVwNDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICB2YXIga2V5ID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICBvYmpba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgfVxuXG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIG9iaiwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW53cmFwIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIGZyb20gYSBwYXJlbnQgbm9kZSwgc3BsaXR0aW5nIHRoZSBwYXJlbnQgaWZcclxuICAgKiBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgY29udGVudCBpbiB0aGUgcmFuZ2UgaXMgdW53cmFwcGVkLlxyXG4gICAqL1xuICB1bndyYXBOb2RlczogZnVuY3Rpb24gdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkbW9kZTggPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU4ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU4LFxuICAgICAgICAgIF9vcHRpb25zJHNwbGl0MiA9IG9wdGlvbnMuc3BsaXQsXG4gICAgICAgICAgc3BsaXQgPSBfb3B0aW9ucyRzcGxpdDIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkc3BsaXQyLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzOCA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczggPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM4O1xuICAgICAgdmFyIF9vcHRpb25zJGF0NyA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDcgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDcsXG4gICAgICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2VSZWYgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0KSA6IG51bGw7XG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIGZ1bmN0aW9uIChfcmVmOSkge1xuICAgICAgICB2YXIgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWYxMFsxXTtcblxuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0gLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgICAgLy8gdGhhdCB3cmFwIHRhcmdldCBub2RlLiBTbyB3ZSByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgICkucmV2ZXJzZSgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEocGF0aFJlZnMpLFxuICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgdmFyIHBhdGhSZWYgPSBfc3RlcDUudmFsdWU7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgICB2YXIgX0VkaXRvciRub2RlMyA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgICAgIF9FZGl0b3Ikbm9kZTQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUzLCAxKSxcbiAgICAgICAgICAgICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTRbMF07XG5cbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICAgIGlmIChzcGxpdCAmJiByYW5nZVJlZikge1xuICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFRyYW5zZm9ybXMubGlmdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyYW5nZVJlZikge1xuICAgICAgICByYW5nZVJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFdyYXAgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gaW4gYSBuZXcgY29udGFpbmVyIG5vZGUsIHNwbGl0dGluZyB0aGUgZWRnZXNcclxuICAgKiBvZiB0aGUgcmFuZ2UgZmlyc3QgdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgY29udGVudCBpbiB0aGUgcmFuZ2UgaXMgd3JhcHBlZC5cclxuICAgKi9cbiAgd3JhcE5vZGVzOiBmdW5jdGlvbiB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkbW9kZTkgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU5ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU5LFxuICAgICAgICAgIF9vcHRpb25zJHNwbGl0MyA9IG9wdGlvbnMuc3BsaXQsXG4gICAgICAgICAgc3BsaXQgPSBfb3B0aW9ucyRzcGxpdDMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkc3BsaXQzLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzOSA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM5O1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBfb3B0aW9ucyRhdDggPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQ4ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ4O1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIG1hdGNoID0gbWF0Y2hQYXRoKGVkaXRvciwgYXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShlbGVtZW50KSkge1xuICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzNyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICAgIF9SYW5nZSRlZGdlczggPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM3LCAyKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzOFswXSxcbiAgICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczhbMV07XG5cbiAgICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcm9vdHMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVkaXRvci5pc0VkaXRvcihuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSkpO1xuXG4gICAgICBmb3IgKHZhciBfaTQgPSAwLCBfcm9vdHMgPSByb290czsgX2k0IDwgX3Jvb3RzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIF9yb290cyRfaSA9IF9zbGljZWRUb0FycmF5KF9yb290c1tfaTRdLCAyKSxcbiAgICAgICAgICAgIHJvb3RQYXRoID0gX3Jvb3RzJF9pWzFdO1xuXG4gICAgICAgIHZhciBhID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBSYW5nZS5pbnRlcnNlY3Rpb24oYXQsIEVkaXRvci5yYW5nZShlZGl0b3IsIHJvb3RQYXRoKSkgOiBhdDtcblxuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaGVzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGEsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZXMgPSBfc2xpY2VkVG9BcnJheShtYXRjaGVzLCAxKSxcbiAgICAgICAgICAgICAgICBmaXJzdCA9IF9tYXRjaGVzWzBdO1xuXG4gICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgdmFyIF9maXJzdCA9IF9zbGljZWRUb0FycmF5KGZpcnN0LCAyKSxcbiAgICAgICAgICAgICAgICBmaXJzdFBhdGggPSBfZmlyc3RbMV07XG5cbiAgICAgICAgICAgIHZhciBfbGFzdCA9IF9zbGljZWRUb0FycmF5KGxhc3QsIDIpLFxuICAgICAgICAgICAgICAgIGxhc3RQYXRoID0gX2xhc3RbMV07XG5cbiAgICAgICAgICAgIGlmIChmaXJzdFBhdGgubGVuZ3RoID09PSAwICYmIGxhc3RQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIG1hdGNoaW5nIHBhcmVudCAtIHVzdWFsbHkgbWVhbnMgdGhlIG5vZGUgaXMgYW4gZWRpdG9yIC0gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmVxdWFscyhmaXJzdFBhdGgsIGxhc3RQYXRoKSA/IFBhdGgucGFyZW50KGZpcnN0UGF0aCkgOiBQYXRoLmNvbW1vbihmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIGNvbW1vbk5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgY29tbW9uUGF0aCk7XG5cbiAgICAgICAgICAgIHZhciBfY29tbW9uTm9kZUVudHJ5ID0gX3NsaWNlZFRvQXJyYXkoY29tbW9uTm9kZUVudHJ5LCAxKSxcbiAgICAgICAgICAgICAgICBjb21tb25Ob2RlID0gX2NvbW1vbk5vZGVFbnRyeVswXTtcblxuICAgICAgICAgICAgdmFyIGRlcHRoID0gY29tbW9uUGF0aC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgdmFyIHdyYXBwZXJQYXRoID0gUGF0aC5uZXh0KGxhc3RQYXRoLnNsaWNlKDAsIGRlcHRoKSk7XG5cbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gX29iamVjdFNwcmVhZCQyKF9vYmplY3RTcHJlYWQkMih7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB3cmFwcGVyLCB7XG4gICAgICAgICAgICAgIGF0OiB3cmFwcGVyUGF0aCxcbiAgICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNBbmNlc3Rvcihjb21tb25Ob2RlKSAmJiBjb21tb25Ob2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0bzogd3JhcHBlclBhdGguY29uY2F0KDApLFxuICAgICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBoYXNTaW5nbGVDaGlsZE5lc3QgPSBmdW5jdGlvbiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBub2RlKSB7XG4gIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcblxuICAgIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBlbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4vKipcclxuICogQ29udmVydCBhIHJhbmdlIGludG8gYSBwb2ludCBieSBkZWxldGluZyBpdCdzIGNvbnRlbnQuXHJcbiAqL1xuXG5cbnZhciBkZWxldGVSYW5nZSA9IGZ1bmN0aW9uIGRlbGV0ZVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9SYW5nZSRlZGdlczkgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczEwID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzOSwgMiksXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczEwWzFdO1xuXG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlXG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50UmVmLnVucmVmKCk7XG4gIH1cbn07XG5cbnZhciBtYXRjaFBhdGggPSBmdW5jdGlvbiBtYXRjaFBhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIHZhciBfRWRpdG9yJG5vZGU1ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKSxcbiAgICAgIF9FZGl0b3Ikbm9kZTYgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGU1LCAxKSxcbiAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGU2WzBdO1xuXG4gIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuID09PSBub2RlO1xuICB9O1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBTZWxlY3Rpb25UcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBDb2xsYXBzZSB0aGUgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBjb2xsYXBzZTogZnVuY3Rpb24gY29sbGFwc2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRlZGdlID0gb3B0aW9ucy5lZGdlLFxuICAgICAgICBlZGdlID0gX29wdGlvbnMkZWRnZSA9PT0gdm9pZCAwID8gJ2FuY2hvcicgOiBfb3B0aW9ucyRlZGdlO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbiksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMSksXG4gICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdO1xuXG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHN0YXJ0KTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbiksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczRbMV07XG5cbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KGVkaXRvcikge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBzZWxlY3Rpb24ncyBwb2ludCBmb3J3YXJkIG9yIGJhY2t3YXJkLlxyXG4gICAqL1xuICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgICAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2UsXG4gICAgICAgIF9vcHRpb25zJHVuaXQgPSBvcHRpb25zLnVuaXQsXG4gICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQsXG4gICAgICAgIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2U7XG4gICAgdmFyIF9vcHRpb25zJGVkZ2UyID0gb3B0aW9ucy5lZGdlLFxuICAgICAgICBlZGdlID0gX29wdGlvbnMkZWRnZTIgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9ucyRlZGdlMjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgIHVuaXQ6IHVuaXRcbiAgICB9O1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcblxuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuXG4gICAgICBpZiAoX3BvaW50KSB7XG4gICAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xuICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChlZGl0b3IsIHRhcmdldCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHRhcmdldCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHRhcmdldCk7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gc2V0dGluZyB0aGUgc2VsZWN0aW9uIGFuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYG51bGxgIHlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3QgYW4gYGFuY2hvcmAgYW5kIGBmb2N1c2AsIGJ1dCB5b3UgcGFzc2VkOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHRhcmdldCkpKTtcbiAgICB9XG5cbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgICAgbmV3UHJvcGVydGllczogdGFyZ2V0XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBwcm9wZXJ0aWVzIG9uIG9uZSBvZiB0aGUgc2VsZWN0aW9uJ3MgcG9pbnRzLlxyXG4gICAqL1xuICBzZXRQb2ludDogZnVuY3Rpb24gc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgX29wdGlvbnMkZWRnZTMgPSBvcHRpb25zLmVkZ2UsXG4gICAgICAgIGVkZ2UgPSBfb3B0aW9ucyRlZGdlMyA9PT0gdm9pZCAwID8gJ2JvdGgnIDogX29wdGlvbnMkZWRnZTM7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICB9XG5cbiAgICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgdmFyIHBvaW50ID0gZWRnZSA9PT0gJ2FuY2hvcicgPyBhbmNob3IgOiBmb2N1cztcbiAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgZWRnZSA9PT0gJ2FuY2hvcicgPyAnYW5jaG9yJyA6ICdmb2N1cycsIF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIHBvaW50KSwgcHJvcHMpKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBwcm9wZXJ0aWVzIG9uIHRoZSBzZWxlY3Rpb24uXHJcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG9sZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgVGV4dFRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIERlbGV0ZSBjb250ZW50IGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIF9kZWxldGUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlLFxuICAgICAgICAgIF9vcHRpb25zJHVuaXQgPSBvcHRpb25zLnVuaXQsXG4gICAgICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQgPT09IHZvaWQgMCA/ICdjaGFyYWN0ZXInIDogX29wdGlvbnMkdW5pdCxcbiAgICAgICAgICBfb3B0aW9ucyRkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UsXG4gICAgICAgICAgZGlzdGFuY2UgPSBfb3B0aW9ucyRkaXN0YW5jZSA9PT0gdm9pZCAwID8gMSA6IF9vcHRpb25zJGRpc3RhbmNlLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzO1xuICAgICAgdmFyIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICAgICAgX29wdGlvbnMkaGFuZ2luZyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzQ29sbGFwc2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiBSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgaXNDb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICAgIHZhciBmdXJ0aGVzdFZvaWQgPSBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiBmdXJ0aGVzdFZvaWQpIHtcbiAgICAgICAgICB2YXIgX2Z1cnRoZXN0Vm9pZCA9IF9zbGljZWRUb0FycmF5KGZ1cnRoZXN0Vm9pZCwgMiksXG4gICAgICAgICAgICAgIHZvaWRQYXRoID0gX2Z1cnRoZXN0Vm9pZFsxXTtcblxuICAgICAgICAgIGF0ID0gdm9pZFBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgICAgYXQgPSB7XG4gICAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgICAgZm9jdXM6IHRhcmdldFxuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZ2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgICBfZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgICB2YXIgZW5kT2ZEb2MgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuXG4gICAgICAgIGlmICghUG9pbnQuZXF1YWxzKF9lbmQsIGVuZE9mRG9jKSkge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczRbMF0sXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNFsxXTtcblxuICAgICAgdmFyIHN0YXJ0QmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgICB2YXIgc3RhcnRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGVuZFZvaWQgPSB2b2lkcyA/IG51bGwgOiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pOyAvLyBJZiB0aGUgc3RhcnQgb3IgZW5kIHBvaW50cyBhcmUgaW5zaWRlIGFuIGlubGluZSB2b2lkLCBudWRnZSB0aGVtIG91dC5cblxuICAgICAgaWYgKHN0YXJ0Vm9pZCkge1xuICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0QmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKHN0YXJ0QmxvY2tbMV0sIGJlZm9yZS5wYXRoKSkge1xuICAgICAgICAgIHN0YXJ0ID0gYmVmb3JlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGVuZCk7XG5cbiAgICAgICAgaWYgKGFmdGVyICYmIGVuZEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihlbmRCbG9ja1sxXSwgYWZ0ZXIucGF0aCkpIHtcbiAgICAgICAgICBlbmQgPSBhZnRlcjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBHZXQgdGhlIGhpZ2hlc3Qgbm9kZXMgdGhhdCBhcmUgY29tcGxldGVseSBpbnNpZGUgdGhlIHJhbmdlLCBhcyB3ZWxsIGFzXG4gICAgICAvLyB0aGUgc3RhcnQgYW5kIGVuZCBub2Rlcy5cblxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgdmFyIGxhc3RQYXRoO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSkpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9lbnRyeSA9IF9zbGljZWRUb0FycmF5KGVudHJ5LCAyKSxcbiAgICAgICAgICAgICAgX25vZGUyID0gX2VudHJ5WzBdLFxuICAgICAgICAgICAgICBfcGF0aDIgPSBfZW50cnlbMV07XG5cbiAgICAgICAgICBpZiAobGFzdFBhdGggJiYgUGF0aC5jb21wYXJlKF9wYXRoMiwgbGFzdFBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KF9ub2RlMikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIF9ub2RlMikgfHwgIVBhdGguaXNDb21tb24oX3BhdGgyLCBzdGFydC5wYXRoKSAmJiAhUGF0aC5pc0NvbW1vbihfcGF0aDIsIGVuZC5wYXRoKSkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIGxhc3RQYXRoID0gX3BhdGgyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWYyWzFdO1xuXG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuXG4gICAgICAgIHZhciBfRWRpdG9yJGxlYWYgPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludCksXG4gICAgICAgICAgICBfRWRpdG9yJGxlYWYyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsZWFmLCAxKSxcbiAgICAgICAgICAgIG5vZGUgPSBfRWRpdG9yJGxlYWYyWzBdO1xuXG4gICAgICAgIHZhciBwYXRoID0gX3BvaW50LnBhdGg7XG4gICAgICAgIHZhciBfc3RhcnQgPSBzdGFydCxcbiAgICAgICAgICAgIG9mZnNldCA9IF9zdGFydC5vZmZzZXQ7XG4gICAgICAgIHZhciB0ZXh0ID0gbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbW92ZWRUZXh0ID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXRoUmVmcy5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLnVucmVmKCk7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHIgIT09IG51bGw7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVuZFZvaWQpIHtcbiAgICAgICAgdmFyIF9wb2ludDIgPSBlbmRSZWYuY3VycmVudDtcblxuICAgICAgICB2YXIgX0VkaXRvciRsZWFmMyA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50MiksXG4gICAgICAgICAgICBfRWRpdG9yJGxlYWY0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRsZWFmMywgMSksXG4gICAgICAgICAgICBfbm9kZSA9IF9FZGl0b3IkbGVhZjRbMF07XG5cbiAgICAgICAgdmFyIF9wYXRoID0gX3BvaW50Mi5wYXRoO1xuXG4gICAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcblxuICAgICAgICB2YXIgX3RleHQgPSBfbm9kZS50ZXh0LnNsaWNlKF9vZmZzZXQsIGVuZC5vZmZzZXQpO1xuXG4gICAgICAgIGlmIChfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSBfdGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiBpc0Fjcm9zc0Jsb2NrcyAmJiBlbmRSZWYuY3VycmVudCAmJiBzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIEZvciBUaGFpIHNjcmlwdCwgZGVsZXRpbmcgTiBjaGFyYWN0ZXIocykgYmFja3dhcmQgc2hvdWxkIGRlbGV0ZVxuICAgICAgLy8gTiBjb2RlIHBvaW50KHMpIGluc3RlYWQgb2YgYW4gZW50aXJlIGdyYXBoZW1lIGNsdXN0ZXIuXG4gICAgICAvLyBUaGVyZWZvcmUsIHRoZSByZW1haW5pbmcgY29kZSBwb2ludHMgc2hvdWxkIGJlIGluc2VydGVkIGJhY2suXG5cblxuICAgICAgaWYgKGlzQ29sbGFwc2VkICYmIHJldmVyc2UgJiYgdW5pdCA9PT0gJ2NoYXJhY3RlcicgJiYgcmVtb3ZlZFRleHQubGVuZ3RoID4gMSAmJiByZW1vdmVkVGV4dC5tYXRjaCgvW1xcdTBFMDAtXFx1MEU3Rl0rLykpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgcmVtb3ZlZFRleHQuc2xpY2UoMCwgcmVtb3ZlZFRleHQubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0VW5yZWYgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgdmFyIGVuZFVucmVmID0gZW5kUmVmLnVucmVmKCk7XG4gICAgICB2YXIgcG9pbnQgPSByZXZlcnNlID8gc3RhcnRVbnJlZiB8fCBlbmRVbnJlZiA6IGVuZFVucmVmIHx8IHN0YXJ0VW5yZWY7XG5cbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwgJiYgcG9pbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnRGcmFnbWVudDogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmcyID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nMixcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczIgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMjtcbiAgICAgIHZhciBfb3B0aW9ucyRhdDIgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQyID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQyO1xuXG4gICAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzNSA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICAgICAgX1JhbmdlJGVkZ2VzNiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczUsIDIpLFxuICAgICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM2WzFdO1xuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgICAvLyBpbnN0ZWFkIHNpbmNlIGl0IHdpbGwgbmVlZCB0byBiZSBzcGxpdCBvdGhlcndpc2UuXG5cblxuICAgICAgdmFyIGlubGluZUVsZW1lbnRNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICAgIHZhciBfaW5saW5lRWxlbWVudE1hdGNoID0gX3NsaWNlZFRvQXJyYXkoaW5saW5lRWxlbWVudE1hdGNoLCAyKSxcbiAgICAgICAgICAgIF9pbmxpbmVQYXRoID0gX2lubGluZUVsZW1lbnRNYXRjaFsxXTtcblxuICAgICAgICBpZiAoRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICB9IGVsc2UgaWYgKEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICAgIGF0ID0gYmVmb3JlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBibG9ja01hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBhdDogYXQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfYmxvY2tNYXRjaCA9IF9zbGljZWRUb0FycmF5KGJsb2NrTWF0Y2gsIDIpLFxuICAgICAgICAgIGJsb2NrUGF0aCA9IF9ibG9ja01hdGNoWzFdO1xuXG4gICAgICB2YXIgaXNCbG9ja1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgICB2YXIgaXNCbG9ja0VtcHR5ID0gaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VTdGFydCA9ICFpc0Jsb2NrU3RhcnQgfHwgaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VFbmQgPSAhaXNCbG9ja0VuZDtcblxuICAgICAgdmFyIF9Ob2RlJGZpcnN0ID0gTm9kZS5maXJzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pLFxuICAgICAgICAgIF9Ob2RlJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0LCAyKSxcbiAgICAgICAgICBmaXJzdFBhdGggPSBfTm9kZSRmaXJzdDJbMV07XG5cbiAgICAgIHZhciBfTm9kZSRsYXN0ID0gTm9kZS5sYXN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSksXG4gICAgICAgICAgX05vZGUkbGFzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRsYXN0LCAyKSxcbiAgICAgICAgICBsYXN0UGF0aCA9IF9Ob2RlJGxhc3QyWzFdO1xuXG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICB2YXIgbWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoZXIoX3JlZjMpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgbiA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgcCA9IF9yZWY0WzFdO1xuXG4gICAgICAgIHZhciBpc1Jvb3QgPSBwLmxlbmd0aCA9PT0gMDtcblxuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxvY2tFbXB0eSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlU3RhcnQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGZpcnN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZUVuZCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgbGFzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoTm9kZS5ub2Rlcyh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwge1xuICAgICAgICBwYXNzOiBtYXRjaGVyXG4gICAgICB9KSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGlmIChtYXRjaGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRzID0gW107XG4gICAgICB2YXIgbWlkZGxlcyA9IFtdO1xuICAgICAgdmFyIGVuZHMgPSBbXTtcbiAgICAgIHZhciBzdGFydGluZyA9IHRydWU7XG4gICAgICB2YXIgaGFzQmxvY2tzID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX21hdGNoZXMgPSBtYXRjaGVzOyBfaSA8IF9tYXRjaGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX21hdGNoZXMkX2kgPSBfc2xpY2VkVG9BcnJheShfbWF0Y2hlc1tfaV0sIDEpLFxuICAgICAgICAgICAgbm9kZSA9IF9tYXRjaGVzJF9pWzBdO1xuXG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBoYXNCbG9ja3MgPSB0cnVlO1xuICAgICAgICAgIG1pZGRsZXMucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZykge1xuICAgICAgICAgIHN0YXJ0cy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZHMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pLFxuICAgICAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICAgICAgaW5saW5lTWF0Y2ggPSBfRWRpdG9yJG5vZGVzMlswXTtcblxuICAgICAgdmFyIF9pbmxpbmVNYXRjaCA9IF9zbGljZWRUb0FycmF5KGlubGluZU1hdGNoLCAyKSxcbiAgICAgICAgICBpbmxpbmVQYXRoID0gX2lubGluZU1hdGNoWzFdO1xuXG4gICAgICB2YXIgaXNJbmxpbmVTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIGlzSW5saW5lRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIGhhc0Jsb2NrcyA/IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogaGFzQmxvY2tzID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCcsXG4gICAgICAgIGFsd2F5czogaGFzQmxvY2tzICYmICghaXNCbG9ja1N0YXJ0IHx8IHN0YXJ0cy5sZW5ndGggPiAwKSAmJiAoIWlzQmxvY2tFbmQgfHwgZW5kcy5sZW5ndGggPiAwKSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgIWlzSW5saW5lU3RhcnQgfHwgaXNJbmxpbmVTdGFydCAmJiBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHN0YXJ0cywge1xuICAgICAgICBhdDogc3RhcnRSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzQmxvY2tFbXB0eSAmJiAhc3RhcnRzLmxlbmd0aCAmJiBtaWRkbGVzLmxlbmd0aCAmJiAhZW5kcy5sZW5ndGgpIHtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYmxvY2tQYXRoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1pZGRsZXMsIHtcbiAgICAgICAgYXQ6IG1pZGRsZVJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlbmRzLCB7XG4gICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFvcHRpb25zLmF0KSB7XG4gICAgICAgIHZhciBwYXRoO1xuXG4gICAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDAgJiYgZW5kUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhlbmRSZWYuY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWlkZGxlcy5sZW5ndGggPiAwICYmIG1pZGRsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMobWlkZGxlUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhzdGFydFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIF9lbmQyID0gRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfZW5kMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIG1pZGRsZVJlZi51bnJlZigpO1xuICAgICAgZW5kUmVmLnVucmVmKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgc3RyaW5nIG9mIHRleHQgaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyR2b2lkczMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMztcbiAgICAgIHZhciBfb3B0aW9ucyRhdDMgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQzID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQzO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5kID0gUmFuZ2UuZW5kKGF0KTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBlbmRSZWYudW5yZWYoKTtcbiAgICAgICAgICBhdCA9IHN0YXJ0UG9pbnQgfHwgZW5kUG9pbnQ7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgICAgZm9jdXM6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9hdCA9IGF0LFxuICAgICAgICAgIHBhdGggPSBfYXQucGF0aCxcbiAgICAgICAgICBvZmZzZXQgPSBfYXQub2Zmc2V0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0JyxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgVHJhbnNmb3JtcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIEdlbmVyYWxUcmFuc2Zvcm1zKSwgTm9kZVRyYW5zZm9ybXMpLCBTZWxlY3Rpb25UcmFuc2Zvcm1zKSwgVGV4dFRyYW5zZm9ybXMpO1xuXG5leHBvcnRzLkVkaXRvciA9IEVkaXRvcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkxvY2F0aW9uID0gTG9jYXRpb247XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuZXhwb3J0cy5PcGVyYXRpb24gPSBPcGVyYXRpb247XG5leHBvcnRzLlBhdGggPSBQYXRoO1xuZXhwb3J0cy5QYXRoUmVmID0gUGF0aFJlZjtcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbmV4cG9ydHMuUG9pbnRSZWYgPSBQb2ludFJlZjtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuUmFuZ2VSZWYgPSBSYW5nZVJlZjtcbmV4cG9ydHMuU2NydWJiZXIgPSBTY3J1YmJlcjtcbmV4cG9ydHMuU3BhbiA9IFNwYW47XG5leHBvcnRzLlRleHQgPSBUZXh0O1xuZXhwb3J0cy5UcmFuc2Zvcm1zID0gVHJhbnNmb3JtcztcbmV4cG9ydHMuY3JlYXRlRWRpdG9yID0gY3JlYXRlRWRpdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc1BsYWluT2JqZWN0IiwicmVxdWlyZSIsImltbWVyIiwidW53cmFwRXhwb3J0cyIsIngiLCJfX2VzTW9kdWxlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJmbiIsIm1vZHVsZSIsImFycmF5TGlrZVRvQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsImFyciIsImxlbiIsImxlbmd0aCIsImkiLCJhcnIyIiwiQXJyYXkiLCJhcnJheVdpdGhvdXRIb2xlcyIsIl9hcnJheVdpdGhvdXRIb2xlcyIsImlzQXJyYXkiLCJpdGVyYWJsZVRvQXJyYXkiLCJfaXRlcmFibGVUb0FycmF5IiwiaXRlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZnJvbSIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibyIsIm1pbkxlbiIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwidGVzdCIsIm5vbkl0ZXJhYmxlU3ByZWFkIiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwidG9Db25zdW1hYmxlQXJyYXkiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcnJheVdpdGhIb2xlcyIsIl9hcnJheVdpdGhIb2xlcyIsIml0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJlcnIiLCJub25JdGVyYWJsZVJlc3QiLCJfbm9uSXRlcmFibGVSZXN0Iiwic2xpY2VkVG9BcnJheSIsIl9zbGljZWRUb0FycmF5IiwiRElSVFlfUEFUSFMiLCJXZWFrTWFwIiwiRElSVFlfUEFUSF9LRVlTIiwiRkxVU0hJTkciLCJOT1JNQUxJWklORyIsIlBBVEhfUkVGUyIsIlBPSU5UX1JFRlMiLCJSQU5HRV9SRUZTIiwib3duS2V5cyQ5Iiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImFwcGx5IiwiX29iamVjdFNwcmVhZCQ5IiwidGFyZ2V0IiwiYXJndW1lbnRzIiwic291cmNlIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyIsIkYiLCJzIiwiZSIsImYiLCJub3JtYWxDb21wbGV0aW9uIiwiZGlkRXJyIiwic3RlcCIsIl9lMiIsIl9hcnJheUxpa2VUb0FycmF5JDciLCJjcmVhdGVFZGl0b3IiLCJlZGl0b3IiLCJjaGlsZHJlbiIsIm9wZXJhdGlvbnMiLCJzZWxlY3Rpb24iLCJtYXJrcyIsImlzSW5saW5lIiwiaXNWb2lkIiwibWFya2FibGVWb2lkIiwib25DaGFuZ2UiLCJvcCIsIl9pdGVyYXRvciIsIkVkaXRvciIsInBhdGhSZWZzIiwiX3N0ZXAiLCJyZWYiLCJQYXRoUmVmIiwidHJhbnNmb3JtIiwiX2l0ZXJhdG9yMiIsInBvaW50UmVmcyIsIl9zdGVwMiIsIl9yZWYiLCJQb2ludFJlZiIsIl9pdGVyYXRvcjMiLCJyYW5nZVJlZnMiLCJfc3RlcDMiLCJfcmVmMiIsIlJhbmdlUmVmIiwib2xkRGlydHlQYXRocyIsImdldCIsIm9sZERpcnR5UGF0aEtleXMiLCJTZXQiLCJkaXJ0eVBhdGhzIiwiZGlydHlQYXRoS2V5cyIsImFkZCIsInBhdGgiLCJqb2luIiwiaGFzIiwiUGF0aCIsIm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwibmV3UGF0aCIsIm5ld0RpcnR5UGF0aHMiLCJnZXREaXJ0eVBhdGhzIiwiX2l0ZXJhdG9yNSIsIl9zdGVwNSIsIl9wYXRoIiwic2V0IiwiVHJhbnNmb3JtcyIsIm5vcm1hbGl6ZSIsIm9wZXJhdGlvbiIsInR5cGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJhZGRNYXJrIiwibWF0Y2giLCJub2RlIiwiVGV4dCIsImlzVGV4dCIsIl9FZGl0b3IkcGFyZW50IiwicGFyZW50IiwiX0VkaXRvciRwYXJlbnQyIiwicGFyZW50Tm9kZSIsImV4cGFuZGVkU2VsZWN0aW9uIiwiUmFuZ2UiLCJpc0V4cGFuZGVkIiwibWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCIsIl9FZGl0b3Ikbm9kZSIsIl9FZGl0b3Ikbm9kZTIiLCJzZWxlY3RlZE5vZGUiLCJzZWxlY3RlZFBhdGgiLCJfRWRpdG9yJHBhcmVudDMiLCJfRWRpdG9yJHBhcmVudDQiLCJzZXROb2RlcyIsInNwbGl0Iiwidm9pZHMiLCJkZWxldGVCYWNrd2FyZCIsInVuaXQiLCJpc0NvbGxhcHNlZCIsInJldmVyc2UiLCJkZWxldGVGb3J3YXJkIiwiZGVsZXRlRnJhZ21lbnQiLCJkaXJlY3Rpb24iLCJnZXRGcmFnbWVudCIsIk5vZGUiLCJmcmFnbWVudCIsImluc2VydEJyZWFrIiwic3BsaXROb2RlcyIsImFsd2F5cyIsImluc2VydFNvZnRCcmVhayIsImluc2VydEZyYWdtZW50IiwiaW5zZXJ0Tm9kZSIsImluc2VydE5vZGVzIiwiaW5zZXJ0VGV4dCIsInRleHQiLCJub3JtYWxpemVOb2RlIiwiZW50cnkiLCJfZW50cnkiLCJFbGVtZW50IiwiaXNFbGVtZW50IiwiY2hpbGQiLCJhdCIsImNvbmNhdCIsInNob3VsZEhhdmVJbmxpbmVzIiwiaXNFZGl0b3IiLCJjdXJyZW50Tm9kZSIsIl9jaGlsZCIsInByZXYiLCJpc0xhc3QiLCJpc0lubGluZU9yVGV4dCIsInJlbW92ZU5vZGVzIiwibmV3Q2hpbGQiLCJfbmV3Q2hpbGQiLCJlcXVhbHMiLCJsb29zZSIsIm1lcmdlTm9kZXMiLCJyZW1vdmVNYXJrIiwiX0VkaXRvciRwYXJlbnQ1IiwiX0VkaXRvciRwYXJlbnQ2IiwiX0VkaXRvciRub2RlMyIsIl9FZGl0b3Ikbm9kZTQiLCJfRWRpdG9yJHBhcmVudDciLCJfRWRpdG9yJHBhcmVudDgiLCJ1bnNldE5vZGVzIiwibGV2ZWxzIiwiX3BhdGgyIiwiZGVzY2VuZGFudHMiLCJub2RlcyIsIl9yZWYzIiwiX3JlZjQiLCJwIiwiX3BhdGgzIiwiYW5jZXN0b3JzIiwicHJldmlvdXNQYXRoIiwicHJldmlvdXMiLCJfcGF0aDQiLCJvbGRBbmNlc3RvcnMiLCJuZXdBbmNlc3RvcnMiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiYW5jZXN0b3IiLCJfaXRlcmF0b3I3IiwiX3N0ZXA3IiwiX2FuY2VzdG9yIiwiX3AiLCJuZXdQYXJlbnQiLCJuZXdJbmRleCIsInJlc3VsdFBhdGgiLCJfcGF0aDUiLCJfYW5jZXN0b3JzIiwiX3BhdGg2IiwiX2xldmVscyIsIm5leHRQYXRoIiwic2hvdWxkTm9ybWFsaXplIiwiX3JlZjUiLCJpdGVyYXRpb24iLCJpbml0aWFsRGlydHlQYXRoc0xlbmd0aCIsIm1heEl0ZXJhdGlvbnMiLCJFcnJvciIsIm9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJvYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNiIsIl9hcnJheUxpa2VUb0FycmF5JDYiLCJnZXRDaGFyYWN0ZXJEaXN0YW5jZSIsInN0ciIsImlzUlRMIiwidW5kZWZpbmVkIiwiaXNMVFIiLCJjb2RlcG9pbnRzIiwiY29kZXBvaW50c0l0ZXJhdG9yUlRMIiwibGVmdCIsIkNvZGVwb2ludFR5cGUiLCJOb25lIiwicmlnaHQiLCJkaXN0YW5jZSIsImdiMTEiLCJnYjEyT3IxMyIsIl9jaGFyIiwiY29kZSIsImNvZGVQb2ludEF0IiwiZ2V0Q29kZXBvaW50VHlwZSIsImludGVyc2VjdHMiLCJaV0oiLCJFeHRQaWN0IiwiZW5kc1dpdGhFbW9qaVpXSiIsInN1YnN0cmluZyIsIlJJIiwiZW5kc1dpdGhPZGROdW1iZXJPZlJJcyIsImlzQm91bmRhcnlQYWlyIiwiU1BBQ0UiLCJQVU5DVFVBVElPTiIsIkNIQU1FTEVPTiIsImdldFdvcmREaXN0YW5jZSIsImRpc3QiLCJzdGFydGVkIiwiY2hhckRpc3QiLCJfc3BsaXRCeUNoYXJhY3RlckRpc3QiLCJzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UiLCJfc3BsaXRCeUNoYXJhY3RlckRpc3QyIiwiX2NoYXIyIiwicmVtYWluaW5nIiwiaXNXb3JkQ2hhcmFjdGVyIiwiX2NoYXIzIiwiX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MyIsIl9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDQiLCJuZXh0Q2hhciIsIm5leHRSZW1haW5pbmciLCJlbmQiLCJjaGFyMSIsImNoYXJBdCIsImlzTG93U3Vycm9nYXRlIiwiY2hhckNvZGVBdCIsImNoYXIyIiwiaXNIaWdoU3Vycm9nYXRlIiwiY2hhckNvZGUiLCJyZUV4dGVuZCIsInJlUHJlcGVuZCIsInJlU3BhY2luZ01hcmsiLCJyZUwiLCJyZVYiLCJyZVQiLCJyZUxWIiwicmVMVlQiLCJyZUV4dFBpY3QiLCJfY2hhcjQiLCJBbnkiLCJzZWFyY2giLCJFeHRlbmQiLCJQcmVwZW5kIiwiU3BhY2luZ01hcmsiLCJMIiwiViIsIlQiLCJMViIsIkxWVCIsInkiLCJOb25Cb3VuZGFyeVBhaXJzIiwiZmluZEluZGV4IiwiciIsImVuZGluZ0Vtb2ppWldKIiwiZW5kaW5nUklzIiwibnVtUklzIiwiaXNOb2RlTGlzdCIsImlzQW5jZXN0b3IiLCJpc0VsZW1lbnRMaXN0IiwiZXZlcnkiLCJ2YWwiLCJpc0VsZW1lbnRQcm9wcyIsInByb3BzIiwiaXNFbGVtZW50VHlwZSIsImVsZW1lbnRWYWwiLCJlbGVtZW50S2V5IiwibWF0Y2hlcyIsImVsZW1lbnQiLCJfZXhjbHVkZWQkNCIsIl9leGNsdWRlZDIkMyIsIm93bktleXMkOCIsIl9vYmplY3RTcHJlYWQkOCIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNSIsIl9hcnJheUxpa2VUb0FycmF5JDUiLCJJU19FRElUT1JfQ0FDSEUiLCJhYm92ZSIsIm9wdGlvbnMiLCJfb3B0aW9ucyR2b2lkcyIsIl9vcHRpb25zJG1vZGUiLCJtb2RlIiwiX29wdGlvbnMkYXQiLCJfc3RlcCR2YWx1ZSIsImlzUmFuZ2UiLCJhbmNob3IiLCJmb2N1cyIsImFmdGVyIiwicG9pbnQiLCJlZGdlIiwicmFuZ2UiLCJfb3B0aW9ucyRkaXN0YW5jZSIsImQiLCJwb3NpdGlvbnMiLCJiZWZvcmUiLCJzdGFydCIsIl9vcHRpb25zJGRpc3RhbmNlMiIsIl9vcHRpb25zJHVuaXQiLCJfb3B0aW9ucyR1bml0MiIsIl9vcHRpb25zJGRpcmVjdGlvbiIsImVkZ2VzIiwiZmlyc3QiLCJoYXNCbG9ja3MiLCJzb21lIiwiaXNCbG9jayIsImhhc0lubGluZXMiLCJoYXNUZXh0cyIsImNhY2hlZElzRWRpdG9yIiwiT3BlcmF0aW9uIiwiaXNPcGVyYXRpb25MaXN0IiwiaXNFbmQiLCJQb2ludCIsImlzRWRnZSIsImlzU3RhcnQiLCJpc0VtcHR5IiwiX2NoaWxkcmVuIiwiaXNOb3JtYWxpemluZyIsIm9mZnNldCIsImxhc3QiLCJsZWFmIiwiX29wdGlvbnMkYXQyIiwiX29wdGlvbnMkcmV2ZXJzZSIsIl9vcHRpb25zJHZvaWRzMiIsIl9zdGVwNCR2YWx1ZSIsIl9FZGl0b3Ikbm9kZXMiLCJfRWRpdG9yJG5vZGVzMiIsIl9tYXRjaCIsIl9ub2RlIiwiX3Jlc3QiLCJfRWRpdG9yJGxlYWYiLCJfRWRpdG9yJGxlYWYyIiwibWFya2VkVm9pZCIsImJsb2NrIiwiX3ByZXYiLCJwcmV2Tm9kZSIsInByZXZQYXRoIiwiX2Jsb2NrIiwiYmxvY2tQYXRoIiwiX25vZGUyIiwicmVzdCIsIl9vcHRpb25zJG1vZGUyIiwiX29wdGlvbnMkdm9pZHMzIiwiX29wdGlvbnMkYXQzIiwicG9pbnRBZnRlckxvY2F0aW9uIiwiX0VkaXRvciRsYXN0IiwiX0VkaXRvciRsYXN0MiIsInRvIiwic3BhbiIsImlzUGF0aCIsImluY2x1ZGVzIiwiX0VkaXRvciRub2RlczMiLCJfRWRpdG9yJG5vZGVzNCIsIl9vcHRpb25zJGF0NCIsIl9vcHRpb25zJG1vZGUzIiwiX29wdGlvbnMkdW5pdmVyc2FsIiwidW5pdmVyc2FsIiwiX29wdGlvbnMkcmV2ZXJzZTIiLCJfb3B0aW9ucyR2b2lkczQiLCJTcGFuIiwiaXNTcGFuIiwibm9kZUVudHJpZXMiLCJwYXNzIiwiaGl0IiwiX3N0ZXA1JHZhbHVlIiwiaXNMb3dlciIsImNvbXBhcmUiLCJlbWl0IiwiX29wdGlvbnMkZm9yY2UiLCJmb3JjZSIsImdldERpcnR5UGF0aEtleXMiLCJwb3BEaXJ0eVBhdGgiLCJwb3AiLCJhbGxQYXRocyIsImFsbFBhdGhLZXlzIiwibWFwIiwid2l0aG91dE5vcm1hbGl6aW5nIiwiX2RpcnR5UGF0aCIsIl9lbnRyeTIiLCJfIiwiZGlydHlQYXRoIiwicGFyZW50UGF0aCIsImRlcHRoIiwiX05vZGUkZmlyc3QiLCJfTm9kZSRmaXJzdDIiLCJmaXJzdFBhdGgiLCJfTm9kZSRsYXN0IiwiX05vZGUkbGFzdDIiLCJsYXN0UGF0aCIsImNvbW1vbiIsImlzUG9pbnQiLCJoYXNQYXRoIiwicGF0aFJlZiIsIl9vcHRpb25zJGFmZmluaXR5IiwiYWZmaW5pdHkiLCJjdXJyZW50IiwidW5yZWYiLCJyZWZzIiwiX29wdGlvbnMkZWRnZSIsIl9Ob2RlJGxhc3QzIiwiX05vZGUkbGFzdDQiLCJfTm9kZSRmaXJzdDMiLCJfTm9kZSRmaXJzdDQiLCJfUmFuZ2UkZWRnZXMiLCJfUmFuZ2UkZWRnZXMyIiwicG9pbnRSZWYiLCJfb3B0aW9ucyRhZmZpbml0eTIiLCJfb3B0aW9ucyRhdDUiLCJfb3B0aW9ucyR1bml0MyIsIl9vcHRpb25zJHJldmVyc2UzIiwiX29wdGlvbnMkdm9pZHM1IiwiX1JhbmdlJGVkZ2VzMyIsIl9SYW5nZSRlZGdlczQiLCJpc05ld0Jsb2NrIiwiYmxvY2tUZXh0IiwibGVhZlRleHRSZW1haW5pbmciLCJsZWFmVGV4dE9mZnNldCIsIl9zdGVwNyR2YWx1ZSIsInN0cmluZyIsImlzRmlyc3QiLCJjYWxjRGlzdGFuY2UiLCJfb3B0aW9ucyRtb2RlNCIsIl9vcHRpb25zJHZvaWRzNiIsIl9vcHRpb25zJGF0NiIsInBvaW50QmVmb3JlTG9jYXRpb24iLCJfRWRpdG9yJGZpcnN0IiwiX0VkaXRvciRmaXJzdDIiLCJfRWRpdG9yJG5vZGVzNSIsIl9FZGl0b3Ikbm9kZXM2IiwicmFuZ2VSZWYiLCJfb3B0aW9ucyRhZmZpbml0eTMiLCJzZXROb3JtYWxpemluZyIsIl9vcHRpb25zJHZvaWRzNyIsIl9SYW5nZSRlZGdlczUiLCJfUmFuZ2UkZWRnZXM2IiwiX2l0ZXJhdG9yOCIsIl9zdGVwOCIsIl9zdGVwOCR2YWx1ZSIsInQiLCJ1bmhhbmdSYW5nZSIsIl9vcHRpb25zJHZvaWRzOCIsIl9SYW5nZSRlZGdlczciLCJfUmFuZ2UkZWRnZXM4IiwiaGFzUHJldmlvdXMiLCJlbmRCbG9jayIsInNraXAiLCJfaXRlcmF0b3I5IiwiX3N0ZXA5IiwiX3N0ZXA5JHZhbHVlIiwiaXNCZWZvcmUiLCJfdm9pZCIsIkxvY2F0aW9uIiwiaXNMb2NhdGlvbiIsIl9leGNsdWRlZCQzIiwiX2V4Y2x1ZGVkMiQyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0IiwiX2FycmF5TGlrZVRvQXJyYXkkNCIsIklTX05PREVfTElTVF9DQUNIRSIsInJvb3QiLCJTY3J1YmJlciIsInN0cmluZ2lmeSIsImluZGV4IiwiYyIsImNoaWxkUGF0aCIsImFub3RoZXIiLCJkZXNjZW5kYW50IiwiX3N0ZXAyJHZhbHVlIiwiZWxlbWVudHMiLCJfc3RlcDMkdmFsdWUiLCJleHRyYWN0UHJvcHMiLCJwcm9wZXJ0aWVzIiwiX3Byb3BlcnRpZXMiLCJuZXdSb290IiwicHJvZHVjZSIsInNwbGljZSIsIl9sZWFmIiwiaXNOb2RlIiwiY2FjaGVkUmVzdWx0IiwiaXNUZXh0UHJvcHMiLCJfb3B0aW9ucyRmcm9tIiwidmlzaXRlZCIsImlzQWZ0ZXIiLCJuZXh0SW5kZXgiLCJfbmV3UGF0aCIsInRleHRzIiwiX3N0ZXA2JHZhbHVlIiwib3duS2V5cyQ3IiwiX29iamVjdFNwcmVhZCQ3IiwiaXNOb2RlT3BlcmF0aW9uIiwiaXNPcGVyYXRpb24iLCJlbmRzV2l0aCIsInBvc2l0aW9uIiwibmV3UHJvcGVydGllcyIsImlzU2VsZWN0aW9uT3BlcmF0aW9uIiwiaXNUZXh0T3BlcmF0aW9uIiwiaW52ZXJzZSIsImlzU2libGluZyIsImludmVyc2VQYXRoIiwiaW52ZXJzZU5ld1BhdGgiLCJfbmV3UHJvcGVydGllcyIsInBhdGhzIiwiYXYiLCJidiIsIm1pbiIsIk1hdGgiLCJlbmRzQWZ0ZXIiLCJhcyIsImJzIiwiZW5kc0F0IiwiZW5kc0JlZm9yZSIsImlzQ2hpbGQiLCJpc0NvbW1vbiIsImlzRGVzY2VuZGFudCIsImlzUGFyZW50IiwiYWwiLCJibCIsImxpc3QiLCJyZWxhdGl2ZSIsIl9vcCIsIl9vcDIiLCJfb3AzIiwiX3Bvc2l0aW9uIiwiX29wNCIsIm9ucCIsImNvcHkiLCJvd25LZXlzJDYiLCJfb2JqZWN0U3ByZWFkJDYiLCJyZXN1bHQiLCJfZXhjbHVkZWQkMiIsIm93bktleXMkNSIsIl9vYmplY3RTcHJlYWQkNSIsImlzQmFja3dhcmQiLCJycyIsInJlIiwidHMiLCJ0ZSIsImlzQWZ0ZXJTdGFydCIsImlzQmVmb3JlRW5kIiwiaW50ZXJzZWN0aW9uIiwiX1JhbmdlJGVkZ2VzOSIsIl9SYW5nZSRlZGdlczEwIiwiczEiLCJlMSIsIl9SYW5nZSRlZGdlczExIiwiX1JhbmdlJGVkZ2VzMTIiLCJzMiIsImUyIiwiaXNGb3J3YXJkIiwicG9pbnRzIiwiX1JhbmdlJGVkZ2VzMTMiLCJfUmFuZ2UkZWRnZXMxNCIsImFmZmluaXR5QW5jaG9yIiwiYWZmaW5pdHlGb2N1cyIsIl9zY3J1YmJlciIsInNldFNjcnViYmVyIiwic2NydWJiZXIiLCJKU09OIiwiaXNEZWVwRXF1YWwiLCJhIiwiYiIsIl9rZXkiLCJfZXhjbHVkZWQkMSIsIl9leGNsdWRlZDIkMSIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyIsIl9hcnJheUxpa2VUb0FycmF5JDMiLCJvd25LZXlzJDQiLCJfb2JqZWN0U3ByZWFkJDQiLCJfb3B0aW9ucyRsb29zZSIsIm9taXRUZXh0IiwiaXNUZXh0TGlzdCIsImRlY29yYXRpb25zIiwiX2RlY29yYXRpb25zIiwibGVhdmVzIiwiZGVjIiwibGVhZkVuZCIsImRlY29yYXRpb25TdGFydCIsImRlY29yYXRpb25FbmQiLCJsZWFmU3RhcnQiLCJhc3NpZ24iLCJtaWRkbGUiLCJvZmYiLCJfb2ZmIiwib3duS2V5cyQzIiwiX29iamVjdFNwcmVhZCQzIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMiIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyIiwiX2FycmF5TGlrZVRvQXJyYXkkMiIsImFwcGx5VG9EcmFmdCIsIl9wb2ludCIsIl9wYXJlbnQiLCJfaW5kZXgiLCJfcHJldiRjaGlsZHJlbiIsIl9wb2ludDIiLCJfa2V5MiIsIl9ub2RlMyIsIl9wYXJlbnQyIiwiX2luZGV4MiIsInRydWVQYXRoIiwiX3BvaW50MyIsIl9rZXkzIiwiX2luZGV4MyIsIl9wYXJlbnQzIiwiX3BvaW50NCIsIl9rZXk0IiwicHJlZmVyTmV4dCIsIl9vZmZzZXQiLCJfdGV4dCIsIl9ub2RlNCIsIl9iZWZvcmUiLCJfYWZ0ZXIiLCJfcG9pbnQ1IiwiX2tleTUiLCJfbm9kZTUiLCJfa2V5NiIsIl9rZXk3IiwiX2tleTgiLCJfdmFsdWUiLCJfcGF0aDciLCJfbm9kZTYiLCJfcGFyZW50NCIsIl9pbmRleDQiLCJuZXdOb2RlIiwiX2JlZm9yZTIiLCJfYWZ0ZXIyIiwiX2JlZm9yZTMiLCJfYWZ0ZXIzIiwiX3BvaW50NiIsIl9rZXk5IiwiR2VuZXJhbFRyYW5zZm9ybXMiLCJjcmVhdGVEcmFmdCIsImZpbmlzaERyYWZ0IiwiaXNEcmFmdCIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxIiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEiLCJfYXJyYXlMaWtlVG9BcnJheSQxIiwiTm9kZVRyYW5zZm9ybXMiLCJfb3B0aW9ucyRoYW5naW5nIiwiaGFuZ2luZyIsInNlbGVjdCIsIl9ub2RlcyIsIl9ub2RlczIiLCJfbWF0Y2hQYXRoIiwiaXNBdEVuZCIsImxpZnROb2RlcyIsIm1hdGNoUGF0aCIsIl9wYXRoUmVmcyIsInBhcmVudE5vZGVFbnRyeSIsIl9wYXJlbnROb2RlRW50cnkiLCJ0b1BhdGgiLCJtb3ZlTm9kZXMiLCJfdG9QYXRoIiwic3BsaXRQYXRoIiwiX3RvUGF0aDIiLCJfb3B0aW9ucyRoYW5naW5nMiIsIl9jdXJyZW50IiwiY29tbW9uUGF0aCIsImlzUHJldmlvdXNTaWJsaW5nIiwiZW1wdHlBbmNlc3RvciIsImhhc1NpbmdsZUNoaWxkTmVzdCIsImVtcHR5UmVmIiwidG9SZWYiLCJ0YXJnZXRzIiwiX3JlZjYiLCJfaTIiLCJfcGF0aFJlZnMyIiwiX29wdGlvbnMkaGFuZ2luZzMiLCJfb3B0aW9ucyRtb2RlNSIsImRlcHRocyIsIl9yZWY3IiwiX3JlZjgiLCJfaTMiLCJfcGF0aFJlZnMzIiwibWVyZ2UiLCJfb3B0aW9ucyRoYW5naW5nNCIsIl9vcHRpb25zJG1vZGU2IiwiX29wdGlvbnMkc3BsaXQiLCJzcGxpdE1vZGUiLCJlbmRBdEVuZE9mTm9kZSIsInN0YXJ0QXRTdGFydE9mTm9kZSIsInByb3AiLCJub2RlUHJvcCIsImhhc0NoYW5nZXMiLCJrIiwiX29wdGlvbnMkbW9kZTciLCJfb3B0aW9ucyRoZWlnaHQiLCJoZWlnaHQiLCJfb3B0aW9ucyRhbHdheXMiLCJkZWxldGVSYW5nZSIsImJlZm9yZVJlZiIsImFmdGVyUmVmIiwiaGlnaGVzdCIsInZvaWRNYXRjaCIsIm51ZGdlIiwiX3ZvaWRNYXRjaCIsInZvaWROb2RlIiwidm9pZFBhdGgiLCJhZnRlclBhdGgiLCJzaWJsaW5nSGVpZ2h0IiwiX2hpZ2hlc3QiLCJoaWdoZXN0UGF0aCIsImxvd2VzdFBhdGgiLCJfYWZ0ZXJSZWYiLCJ1bndyYXBOb2RlcyIsIl9vcHRpb25zJG1vZGU4IiwiX29wdGlvbnMkc3BsaXQyIiwiX29wdGlvbnMkYXQ3IiwiX3JlZjkiLCJfcmVmMTAiLCJfbG9vcCIsIndyYXBOb2RlcyIsIl9vcHRpb25zJG1vZGU5IiwiX29wdGlvbnMkc3BsaXQzIiwiX29wdGlvbnMkdm9pZHM5IiwiX29wdGlvbnMkYXQ4Iiwicm9vdHMiLCJfaTQiLCJfcm9vdHMiLCJfcm9vdHMkX2kiLCJyb290UGF0aCIsIl9yZXQiLCJfbWF0Y2hlcyIsIl9maXJzdCIsIl9sYXN0IiwiY29tbW9uTm9kZUVudHJ5IiwiX2NvbW1vbk5vZGVFbnRyeSIsImNvbW1vbk5vZGUiLCJ3cmFwcGVyUGF0aCIsIndyYXBwZXIiLCJfRWRpdG9yJG5vZGU1IiwiX0VkaXRvciRub2RlNiIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIlNlbGVjdGlvblRyYW5zZm9ybXMiLCJjb2xsYXBzZSIsImRlc2VsZWN0IiwibW92ZSIsIl9vcHRpb25zJGVkZ2UyIiwib3B0cyIsInNldFNlbGVjdGlvbiIsInNldFBvaW50IiwiX29wdGlvbnMkZWRnZTMiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJUZXh0VHJhbnNmb3JtcyIsIl9kZWxldGUiLCJmdXJ0aGVzdFZvaWQiLCJfZnVydGhlc3RWb2lkIiwiX2VuZCIsImVuZE9mRG9jIiwic3RhcnRCbG9jayIsImlzQWNyb3NzQmxvY2tzIiwiaXNTaW5nbGVUZXh0Iiwic3RhcnRWb2lkIiwiZW5kVm9pZCIsInN0YXJ0UmVmIiwiZW5kUmVmIiwicmVtb3ZlZFRleHQiLCJfc3RhcnQiLCJfRWRpdG9yJGxlYWYzIiwiX0VkaXRvciRsZWFmNCIsInN0YXJ0VW5yZWYiLCJlbmRVbnJlZiIsImlubGluZUVsZW1lbnRNYXRjaCIsIl9pbmxpbmVFbGVtZW50TWF0Y2giLCJfaW5saW5lUGF0aCIsImJsb2NrTWF0Y2giLCJfYmxvY2tNYXRjaCIsImlzQmxvY2tTdGFydCIsImlzQmxvY2tFbmQiLCJpc0Jsb2NrRW1wdHkiLCJtZXJnZVN0YXJ0IiwibWVyZ2VFbmQiLCJtYXRjaGVyIiwiaXNSb290Iiwic3RhcnRzIiwibWlkZGxlcyIsImVuZHMiLCJzdGFydGluZyIsIl9tYXRjaGVzJF9pIiwiaW5saW5lTWF0Y2giLCJfaW5saW5lTWF0Y2giLCJpbmxpbmVQYXRoIiwiaXNJbmxpbmVTdGFydCIsImlzSW5saW5lRW5kIiwibWlkZGxlUmVmIiwiX2VuZDIiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJfYXQiLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/slate/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/slate/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/slate/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar immer = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/index.js\");\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar arrayLikeToArray = createCommonjsModule(function (module) {\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayLikeToArray);\n\nvar arrayWithoutHoles = createCommonjsModule(function (module) {\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayWithoutHoles);\n\nvar iterableToArray = createCommonjsModule(function (module) {\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(iterableToArray);\n\nvar unsupportedIterableToArray = createCommonjsModule(function (module) {\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(unsupportedIterableToArray);\n\nvar nonIterableSpread = createCommonjsModule(function (module) {\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(nonIterableSpread);\n\nvar toConsumableArray = createCommonjsModule(function (module) {\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nvar defineProperty = createCommonjsModule(function (module) {\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _defineProperty = unwrapExports(defineProperty);\n\nvar arrayWithHoles = createCommonjsModule(function (module) {\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayWithHoles);\n\nvar iterableToArrayLimit = createCommonjsModule(function (module) {\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(iterableToArrayLimit);\n\nvar nonIterableRest = createCommonjsModule(function (module) {\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(nonIterableRest);\n\nvar slicedToArray = createCommonjsModule(function (module) {\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }\n\nfunction _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: function isInline() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    markableVoid: function markableVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    apply: function apply(op) {\n      var _iterator = _createForOfIteratorHelper$7(Editor.pathRefs(editor)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ref = _step.value;\n          PathRef.transform(ref, op);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper$7(Editor.pointRefs(editor)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _ref = _step2.value;\n          PointRef.transform(_ref, op);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper$7(Editor.rangeRefs(editor)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _ref2 = _step3.value;\n          RangeRef.transform(_ref2, op);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n      var dirtyPaths;\n      var dirtyPathKeys;\n\n      var add = function add(path) {\n        if (path) {\n          var key = path.join(',');\n\n          if (!dirtyPathKeys.has(key)) {\n            dirtyPathKeys.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n\n        var _iterator4 = _createForOfIteratorHelper$7(oldDirtyPaths),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var path = _step4.value;\n            var newPath = Path.transform(path, op);\n            add(newPath);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n      }\n\n      var newDirtyPaths = editor.getDirtyPaths(op);\n\n      var _iterator5 = _createForOfIteratorHelper$7(newDirtyPaths),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _path = _step5.value;\n          add(_path);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor, {\n        operation: op\n      }); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(function () {\n          FLUSHING.set(editor, false);\n          editor.onChange({\n            operation: op\n          });\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: function addMark(key, value) {\n      var selection = editor.selection;\n          editor.markableVoid;\n\n      if (selection) {\n        var match = function match(node, path) {\n          if (!Text.isText(node)) {\n            return false; // marks can only be applied to text\n          }\n\n          var _Editor$parent = Editor.parent(editor, path),\n              _Editor$parent2 = _slicedToArray(_Editor$parent, 2),\n              parentNode = _Editor$parent2[0];\n              _Editor$parent2[1];\n\n          return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n\n        if (!expandedSelection) {\n          var _Editor$node = Editor.node(editor, selection),\n              _Editor$node2 = _slicedToArray(_Editor$node, 2),\n              selectedNode = _Editor$node2[0],\n              selectedPath = _Editor$node2[1];\n\n          if (selectedNode && match(selectedNode, selectedPath)) {\n            var _Editor$parent3 = Editor.parent(editor, selectedPath),\n                _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n                parentNode = _Editor$parent4[0];\n\n            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n          }\n        }\n\n        if (expandedSelection || markAcceptingVoidSelected) {\n          Transforms.setNodes(editor, _defineProperty({}, key, value), {\n            match: match,\n            split: true,\n            voids: true\n          });\n        } else {\n          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, _defineProperty({}, key, value));\n\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n    deleteBackward: function deleteBackward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms[\"delete\"](editor, {\n          unit: unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: function deleteForward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms[\"delete\"](editor, {\n          unit: unit\n        });\n      }\n    },\n    deleteFragment: function deleteFragment(direction) {\n      var selection = editor.selection;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms[\"delete\"](editor, {\n          reverse: direction === 'backward'\n        });\n      }\n    },\n    getFragment: function getFragment() {\n      var selection = editor.selection;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: function insertBreak() {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertSoftBreak: function insertSoftBreak() {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: function insertFragment(fragment) {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: function insertNode(node) {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: function insertText(text) {\n      var selection = editor.selection,\n          marks = editor.marks;\n\n      if (selection) {\n        if (marks) {\n          var node = _objectSpread$9({\n            text: text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: function normalizeNode(entry) {\n      var _entry = _slicedToArray(entry, 2),\n          node = _entry[0],\n          path = _entry[1]; // There are no core normalizations for text nodes.\n\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = node.children[i];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (_child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: function removeMark(key) {\n      var selection = editor.selection;\n\n      if (selection) {\n        var match = function match(node, path) {\n          if (!Text.isText(node)) {\n            return false; // marks can only be applied to text\n          }\n\n          var _Editor$parent5 = Editor.parent(editor, path),\n              _Editor$parent6 = _slicedToArray(_Editor$parent5, 2),\n              parentNode = _Editor$parent6[0];\n              _Editor$parent6[1];\n\n          return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n\n        if (!expandedSelection) {\n          var _Editor$node3 = Editor.node(editor, selection),\n              _Editor$node4 = _slicedToArray(_Editor$node3, 2),\n              selectedNode = _Editor$node4[0],\n              selectedPath = _Editor$node4[1];\n\n          if (selectedNode && match(selectedNode, selectedPath)) {\n            var _Editor$parent7 = Editor.parent(editor, selectedPath),\n                _Editor$parent8 = _slicedToArray(_Editor$parent7, 1),\n                parentNode = _Editor$parent8[0];\n\n            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n          }\n        }\n\n        if (expandedSelection || markAcceptingVoidSelected) {\n          Transforms.unsetNodes(editor, key, {\n            match: match,\n            split: true,\n            voids: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n\n    /**\r\n     * Get the \"dirty\" paths generated from an operation.\r\n     */\n    getDirtyPaths: function getDirtyPaths(op) {\n      switch (op.type) {\n        case 'insert_text':\n        case 'remove_text':\n        case 'set_node':\n          {\n            var path = op.path;\n            return Path.levels(path);\n          }\n\n        case 'insert_node':\n          {\n            var node = op.node,\n                _path2 = op.path;\n            var levels = Path.levels(_path2);\n            var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  p = _ref4[1];\n\n              return _path2.concat(p);\n            });\n            return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n          }\n\n        case 'merge_node':\n          {\n            var _path3 = op.path;\n            var ancestors = Path.ancestors(_path3);\n            var previousPath = Path.previous(_path3);\n            return [].concat(_toConsumableArray(ancestors), [previousPath]);\n          }\n\n        case 'move_node':\n          {\n            var _path4 = op.path,\n                newPath = op.newPath;\n\n            if (Path.equals(_path4, newPath)) {\n              return [];\n            }\n\n            var oldAncestors = [];\n            var newAncestors = [];\n\n            var _iterator6 = _createForOfIteratorHelper$7(Path.ancestors(_path4)),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var ancestor = _step6.value;\n                var p = Path.transform(ancestor, op);\n                oldAncestors.push(p);\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            var _iterator7 = _createForOfIteratorHelper$7(Path.ancestors(newPath)),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var _ancestor = _step7.value;\n\n                var _p = Path.transform(_ancestor, op);\n\n                newAncestors.push(_p);\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n\n            var newParent = newAncestors[newAncestors.length - 1];\n            var newIndex = newPath[newPath.length - 1];\n            var resultPath = newParent.concat(newIndex);\n            return [].concat(oldAncestors, newAncestors, [resultPath]);\n          }\n\n        case 'remove_node':\n          {\n            var _path5 = op.path;\n\n            var _ancestors = Path.ancestors(_path5);\n\n            return _toConsumableArray(_ancestors);\n          }\n\n        case 'split_node':\n          {\n            var _path6 = op.path;\n\n            var _levels = Path.levels(_path6);\n\n            var nextPath = Path.next(_path6);\n            return [].concat(_toConsumableArray(_levels), [nextPath]);\n          }\n\n        default:\n          {\n            return [];\n          }\n      }\n    },\n    shouldNormalize: function shouldNormalize(_ref5) {\n      var iteration = _ref5.iteration,\n          initialDirtyPathsLength = _ref5.initialDirtyPathsLength;\n      var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n\n      if (iteration > maxIterations) {\n        throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n      }\n\n      return true;\n    }\n  };\n  return editor;\n};\n\nvar objectWithoutPropertiesLoose = createCommonjsModule(function (module) {\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(objectWithoutPropertiesLoose);\n\nvar objectWithoutProperties = createCommonjsModule(function (module) {\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }\n\nfunction _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0; // Evaluation of these conditions are deferred.\n\n  var gb11 = null; // Is GB11 applicable?\n\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n\n  var _iterator = _createForOfIteratorHelper$6(codepoints),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n\n      var code = _char.codePointAt(0);\n\n      if (!code) break;\n      var type = getCodepointType(_char, code);\n\n      var _ref = isLTR ? [right, type] : [type, left];\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      left = _ref2[0];\n      right = _ref2[1];\n\n      if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n        if (isLTR) {\n          gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n        } else {\n          gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n        }\n\n        if (!gb11) break;\n      }\n\n      if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n        if (gb12Or13 !== null) {\n          gb12Or13 = !gb12Or13;\n        } else {\n          if (isLTR) {\n            gb12Or13 = true;\n          } else {\n            gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n          }\n        }\n\n        if (!gb12Or13) break;\n      }\n\n      if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n        break;\n      }\n\n      distance += _char.length;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n\n    var _splitByCharacterDist = splitByCharacterDistance(text, charDist, isRTL),\n        _splitByCharacterDist2 = _slicedToArray(_splitByCharacterDist, 2),\n        _char2 = _splitByCharacterDist2[0],\n        remaining = _splitByCharacterDist2[1];\n\n    if (isWordCharacter(_char2, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n\n    text = remaining;\n  }\n\n  return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */\n\nvar splitByCharacterDistance = function splitByCharacterDistance(str, dist, isRTL) {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = function isWordCharacter(_char3, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (SPACE.test(_char3)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(_char3)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n\n    var _splitByCharacterDist3 = splitByCharacterDistance(remaining, charDist, isRTL),\n        _splitByCharacterDist4 = _slicedToArray(_splitByCharacterDist3, 2),\n        nextChar = _splitByCharacterDist4[0],\n        nextRemaining = _splitByCharacterDist4[1];\n\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(_char3)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */\n\n\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n\n    yield char1;\n  }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\nvar isHighSurrogate = function isHighSurrogate(charCode) {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\n\nvar isLowSurrogate = function isLowSurrogate(charCode) {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\n\nvar CodepointType;\n\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\n\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\n\nvar getCodepointType = function getCodepointType(_char4, code) {\n  var type = CodepointType.Any;\n\n  if (_char4.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n\n  if (_char4.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n\n  if (_char4.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n\n  if (_char4.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n\n  if (_char4.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n\n  if (_char4.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n\n  if (_char4.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n\n  if (_char4.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n\n  if (_char4.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n\n  return type;\n};\n\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\n\nvar NonBoundaryPairs = [// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT], // GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T], // GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T], // GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ], // GB9a\n[CodepointType.Any, CodepointType.SpacingMark], // GB9b\n[CodepointType.Prepend, CodepointType.Any], // GB11\n[CodepointType.ZWJ, CodepointType.ExtPict], // GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\n\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(function (r) {\n    return intersects(left, r[0]) && intersects(right, r[1]);\n  }) === -1;\n}\n\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\n\nvar endsWithEmojiZWJ = function endsWithEmojiZWJ(str) {\n  return str.search(endingEmojiZWJ) !== -1;\n};\n\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\n\nvar endsWithOddNumberOfRIs = function endsWithOddNumberOfRIs(str) {\n  var match = str.match(endingRIs);\n\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n/**\r\n * Shared the function with isElementType utility\r\n */\n\nvar isElement = function isElement(value) {\n  return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\n\n\nvar Element = {\n  /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */\n  isAncestor: function isAncestor(value) {\n    return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children);\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement: isElement,\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Element.isElement(val);\n    });\n  },\n\n  /**\r\n   * Check if a set of props is a partial of Element.\r\n   */\n  isElementProps: function isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nvar _excluded$4 = [\"text\"],\n    _excluded2$3 = [\"text\"];\n\nfunction ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }\n\nfunction _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above: function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids,\n        _options$mode = options.mode,\n        mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n        _options$at = options.at,\n        at = _options$at === void 0 ? editor.selection : _options$at,\n        match = options.match;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    var _iterator = _createForOfIteratorHelper$5(Editor.levels(editor, {\n      at: path,\n      voids: voids,\n      match: match,\n      reverse: reverse\n    })),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            n = _step$value[0],\n            p = _step$value[1];\n\n        if (Text.isText(n)) continue;\n\n        if (Range.isRange(at)) {\n          if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n            return [n, p];\n          }\n        } else {\n          if (!Path.equals(path, p)) {\n            return [n, p];\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark: function addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after: function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance;\n    var d = 0;\n    var target;\n\n    var _iterator2 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range\n    }))),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var p = _step2.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before: function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance2 = options.distance,\n        distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n    var d = 0;\n    var target;\n\n    var _iterator3 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range,\n      reverse: true\n    }))),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var p = _step3.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward: function deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward: function deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit2 = options.unit,\n        unit = _options$unit2 === void 0 ? 'character' : _options$unit2;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment: function deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$direction = options.direction,\n        direction = _options$direction === void 0 ? 'forward' : _options$direction;\n    editor.deleteFragment(direction);\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges: function edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end: function end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first: function first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment: function fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks: function hasBlocks(editor, element) {\n    return element.children.some(function (n) {\n      return Element.isElement(n) && Editor.isBlock(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines: function hasInlines(editor, element) {\n    return element.children.some(function (n) {\n      return Text.isText(n) || Editor.isInline(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts: function hasTexts(editor, element) {\n    return element.children.every(function (n) {\n      return Text.isText(n);\n    });\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak: function insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertSoftBreak: function insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode: function insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText: function insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock: function isBlock(editor, value) {\n    return !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor: function isEditor(value) {\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor;\n    }\n\n    if (!isPlainObject.isPlainObject(value)) {\n      return false;\n    }\n\n    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || isPlainObject.isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd: function isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge: function isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty: function isEmpty(editor, element) {\n    var children = element.children;\n\n    var _children = _slicedToArray(children, 1),\n        first = _children[0];\n\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline: function isInline(editor, value) {\n    return editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing: function isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart: function isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid: function isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last: function last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf: function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  levels: function* levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$at2 = options.at,\n        at = _options$at2 === void 0 ? editor.selection : _options$at2,\n        _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse,\n        _options$voids2 = options.voids,\n        voids = _options$voids2 === void 0 ? false : _options$voids2;\n    var match = options.match;\n\n    if (match == null) {\n      match = function match() {\n        return true;\n      };\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var levels = [];\n    var path = Editor.path(editor, at);\n\n    var _iterator4 = _createForOfIteratorHelper$5(Node.levels(editor, path)),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _slicedToArray(_step4.value, 2),\n            n = _step4$value[0],\n            p = _step4$value[1];\n\n        if (!match(n, p)) {\n          continue;\n        }\n\n        levels.push([n, p]);\n\n        if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    if (reverse) {\n      levels.reverse();\n    }\n\n    yield* levels;\n  },\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks: function marks(editor) {\n    var marks = editor.marks,\n        selection = editor.selection;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var _Editor$nodes = Editor.nodes(editor, {\n        match: Text.isText\n      }),\n          _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n          match = _Editor$nodes2[0];\n\n      if (match) {\n        var _match = _slicedToArray(match, 1),\n            _node = _match[0];\n\n        _node.text;\n            var _rest = _objectWithoutProperties(_node, _excluded$4);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var anchor = selection.anchor;\n    var path = anchor.path;\n\n    var _Editor$leaf = Editor.leaf(editor, path),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n        node = _Editor$leaf2[0];\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var markedVoid = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n);\n        }\n      });\n\n      if (!markedVoid) {\n        var block = Editor.above(editor, {\n          match: function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          }\n        });\n\n        if (prev && block) {\n          var _prev = _slicedToArray(prev, 2),\n              prevNode = _prev[0],\n              prevPath = _prev[1];\n\n          var _block = _slicedToArray(block, 2),\n              blockPath = _block[1];\n\n          if (Path.isAncestor(blockPath, prevPath)) {\n            node = prevNode;\n          }\n        }\n      }\n    }\n\n    var _node2 = node;\n        _node2.text;\n        var rest = _objectWithoutProperties(_node2, _excluded2$3);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next: function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode2 = options.mode,\n        mode = _options$mode2 === void 0 ? 'lowest' : _options$mode2,\n        _options$voids3 = options.voids,\n        voids = _options$voids3 === void 0 ? false : _options$voids3;\n    var match = options.match,\n        _options$at3 = options.at,\n        at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n    if (!at) {\n      return;\n    }\n\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids: voids\n    });\n    if (!pointAfterLocation) return;\n\n    var _Editor$last = Editor.last(editor, []),\n        _Editor$last2 = _slicedToArray(_Editor$last, 2),\n        to = _Editor$last2[1];\n\n    var span = [pointAfterLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent = Editor.parent(editor, at),\n            _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n            parent = _Editor$parent2[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes3 = Editor.nodes(editor, {\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n        next = _Editor$nodes4[0];\n\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node: function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  nodes: function* nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$at4 = options.at,\n        at = _options$at4 === void 0 ? editor.selection : _options$at4,\n        _options$mode3 = options.mode,\n        mode = _options$mode3 === void 0 ? 'all' : _options$mode3,\n        _options$universal = options.universal,\n        universal = _options$universal === void 0 ? false : _options$universal,\n        _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2,\n        _options$voids4 = options.voids,\n        voids = _options$voids4 === void 0 ? false : _options$voids4;\n    var match = options.match;\n\n    if (!match) {\n      match = function match() {\n        return true;\n      };\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var from;\n    var to;\n\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    var nodeEntries = Node.nodes(editor, {\n      reverse: reverse,\n      from: from,\n      to: to,\n      pass: function pass(_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            n = _ref2[0];\n\n        return voids ? false : Element.isElement(n) && Editor.isVoid(editor, n);\n      }\n    });\n    var matches = [];\n    var hit;\n\n    var _iterator5 = _createForOfIteratorHelper$5(nodeEntries),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _step5$value = _slicedToArray(_step5.value, 2),\n            node = _step5$value[0],\n            path = _step5$value[1];\n\n        var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n        if (mode === 'highest' && isLower) {\n          continue;\n        }\n\n        if (!match(node, path)) {\n          // If we've arrived at a leaf text node that is not lower than the last\n          // hit, then we've found a branch that doesn't include a match, which\n          // means the match is not universal.\n          if (universal && !isLower && Text.isText(node)) {\n            return;\n          } else {\n            continue;\n          }\n        } // If there's a match and it's lower than the last, update the hit.\n\n\n        if (mode === 'lowest' && isLower) {\n          hit = [node, path];\n          continue;\n        } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n        var emit = mode === 'lowest' ? hit : [node, path];\n\n        if (emit) {\n          if (universal) {\n            matches.push(emit);\n          } else {\n            yield emit;\n          }\n        }\n\n        hit = [node, path];\n      } // Since lowest is always emitting one behind, catch up at the end.\n\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n\n\n    if (universal) {\n      yield* matches;\n    }\n  },\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize: function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$force = options.force,\n        force = _options$force === void 0 ? false : _options$force,\n        operation = options.operation;\n\n    var getDirtyPaths = function getDirtyPaths(editor) {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    var getDirtyPathKeys = function getDirtyPathKeys(editor) {\n      return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n\n    var popDirtyPath = function popDirtyPath(editor) {\n      var path = getDirtyPaths(editor).pop();\n      var key = path.join(',');\n      getDirtyPathKeys(editor)[\"delete\"](key);\n      return path;\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            p = _ref4[1];\n\n        return p;\n      });\n      var allPathKeys = new Set(allPaths.map(function (p) {\n        return p.join(',');\n      }));\n      DIRTY_PATHS.set(editor, allPaths);\n      DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, function () {\n      /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */\n      var _iterator6 = _createForOfIteratorHelper$5(getDirtyPaths(editor)),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _dirtyPath = _step6.value;\n\n          if (Node.has(editor, _dirtyPath)) {\n            var _entry = Editor.node(editor, _dirtyPath);\n\n            var _entry2 = _slicedToArray(_entry, 2),\n                node = _entry2[0],\n                _ = _entry2[1];\n            /*\r\n              The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n              So there is some risk here.\r\n                         As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n              by definition adding children to an empty node can't cause other paths to change.\r\n            */\n\n\n            if (Element.isElement(node) && node.children.length === 0) {\n              editor.normalizeNode(_entry, {\n                operation: operation\n              });\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var dirtyPaths = getDirtyPaths(editor);\n      var initialDirtyPathsLength = dirtyPaths.length;\n      var iteration = 0;\n\n      while (dirtyPaths.length !== 0) {\n        if (!editor.shouldNormalize({\n          dirtyPaths: dirtyPaths,\n          iteration: iteration,\n          initialDirtyPathsLength: initialDirtyPathsLength,\n          operation: operation\n        })) {\n          return;\n        }\n\n        var dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n        if (Node.has(editor, dirtyPath)) {\n          var entry = Editor.node(editor, dirtyPath);\n          editor.normalizeNode(entry, {\n            operation: operation\n          });\n        }\n\n        iteration++;\n        dirtyPaths = getDirtyPaths(editor);\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent: function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path: function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var depth = options.depth,\n        edge = options.edge;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var _Node$first = Node.first(editor, at),\n            _Node$first2 = _slicedToArray(_Node$first, 2),\n            firstPath = _Node$first2[1];\n\n        at = firstPath;\n      } else if (edge === 'end') {\n        var _Node$last = Node.last(editor, at),\n            _Node$last2 = _slicedToArray(_Node$last, 2),\n            lastPath = _Node$last2[1];\n\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n  hasPath: function hasPath(editor, path) {\n    return Node.has(editor, path);\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef: function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    var ref = {\n      current: path,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs: function pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point: function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'start' : _options$edge;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var _Node$last3 = Node.last(editor, at),\n            _Node$last4 = _slicedToArray(_Node$last3, 2),\n            lastPath = _Node$last4[1];\n\n        path = lastPath;\n      } else {\n        var _Node$first3 = Node.first(editor, at),\n            _Node$first4 = _slicedToArray(_Node$first3, 2),\n            firstPath = _Node$first4[1];\n\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path: path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef: function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity2 = options.affinity,\n        affinity = _options$affinity2 === void 0 ? 'forward' : _options$affinity2;\n    var ref = {\n      current: point,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs: function pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */\n  positions: function* positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$at5 = options.at,\n        at = _options$at5 === void 0 ? editor.selection : _options$at5,\n        _options$unit3 = options.unit,\n        unit = _options$unit3 === void 0 ? 'offset' : _options$unit3,\n        _options$reverse3 = options.reverse,\n        reverse = _options$reverse3 === void 0 ? false : _options$reverse3,\n        _options$voids5 = options.voids,\n        voids = _options$voids5 === void 0 ? false : _options$voids5;\n\n    if (!at) {\n      return;\n    }\n    /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */\n\n\n    var range = Editor.range(editor, at);\n\n    var _Range$edges3 = Range.edges(range),\n        _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n        start = _Range$edges4[0],\n        end = _Range$edges4[1];\n\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n\n    var _iterator7 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n      at: at,\n      reverse: reverse,\n      voids: voids\n    })),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _step7$value = _slicedToArray(_step7.value, 2),\n            node = _step7$value[0],\n            path = _step7$value[1];\n\n        /*\r\n         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n         */\n        if (Element.isElement(node)) {\n          // Void nodes are a special case, so by default we will always\n          // yield their first point. If the `voids` option is set to true,\n          // then we will iterate over their content.\n          if (!voids && editor.isVoid(node)) {\n            yield Editor.start(editor, path);\n            continue;\n          } // Inline element nodes are ignored as they don't themselves\n          // contribute to `blockText` or `leafText` - their parent and\n          // children do.\n\n\n          if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n\n          if (Editor.hasInlines(editor, node)) {\n            // We always exhaust block nodes before encountering a new one:\n            //   console.assert(blockText === '',\n            //     `blockText='${blockText}' - `+\n            //     `not exhausted before new block node`, path)\n            // Ensure range considered is capped to `range`, in the\n            // start/end edge cases where block extends beyond range.\n            // Equivalent to this, but presumably more performant:\n            //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n            //   blockRange = Range.intersection(range, blockRange) // intersect\n            //   blockText = Editor.string(editor, blockRange, { voids })\n            var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n            var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n            blockText = Editor.string(editor, {\n              anchor: s,\n              focus: e\n            }, {\n              voids: voids\n            });\n            isNewBlock = true;\n          }\n        }\n        /*\r\n         * TEXT LEAF NODE - Iterate through text content, yielding\r\n         * positions every `distance` offset according to `unit`.\r\n         */\n\n\n        if (Text.isText(node)) {\n          var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n          //   console.assert(leafTextRemaining <= 0,\n          //     `leafTextRemaining=${leafTextRemaining} - `+\n          //     `not exhausted before new leaf text node`, path)\n          // Reset `leafText` counters for new text node.\n\n          if (isFirst) {\n            leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n            leafTextOffset = first.offset; // Works for reverse too.\n          } else {\n            leafTextRemaining = node.text.length;\n            leafTextOffset = reverse ? leafTextRemaining : 0;\n          } // Yield position at the start of node (potentially).\n\n\n          if (isFirst || isNewBlock || unit === 'offset') {\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n            isNewBlock = false;\n          } // Yield positions every (dynamically calculated) `distance` offset.\n\n\n          while (true) {\n            // If `leafText` has caught up with `blockText` (distance=0),\n            // and if blockText is exhausted, break to get another block node,\n            // otherwise advance blockText forward by the new `distance`.\n            if (distance === 0) {\n              if (blockText === '') break;\n              distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n              // remaining string for the next iteration.\n\n              blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n            } // Advance `leafText` by the current `distance`.\n\n\n            leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n            leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n            // and set distance to the overflow amount, so we'll (maybe)\n            // catch up to blockText in the next leaf text node.\n\n            if (leafTextRemaining < 0) {\n              distance = -leafTextRemaining;\n              break;\n            } // Successfully walked `distance` offsets through `leafText`\n            // to catch up with `blockText`, so we can reset `distance`\n            // and yield this position in this node.\n\n\n            distance = 0;\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n          }\n        }\n      } // Proof that upon completion, we've exahusted both leaf and block text:\n      //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n      //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n      // Helper:\n      // Return the distance in offsets for a step of size `unit` on given string.\n\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n\n      return 1;\n    }\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous: function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode4 = options.mode,\n        mode = _options$mode4 === void 0 ? 'lowest' : _options$mode4,\n        _options$voids6 = options.voids,\n        voids = _options$voids6 === void 0 ? false : _options$voids6;\n    var match = options.match,\n        _options$at6 = options.at,\n        at = _options$at6 === void 0 ? editor.selection : _options$at6;\n\n    if (!at) {\n      return;\n    }\n\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids: voids\n    });\n\n    if (!pointBeforeLocation) {\n      return;\n    }\n\n    var _Editor$first = Editor.first(editor, []),\n        _Editor$first2 = _slicedToArray(_Editor$first, 2),\n        to = _Editor$first2[1]; // The search location is from the start of the document to the path of\n    // the point before the location passed in\n\n\n    var span = [pointBeforeLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent3 = Editor.parent(editor, at),\n            _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n            parent = _Editor$parent4[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes5 = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n        previous = _Editor$nodes6[0];\n\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range: function range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef: function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity3 = options.affinity,\n        affinity = _options$affinity3 === void 0 ? 'forward' : _options$affinity3;\n    var ref = {\n      current: range,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs: function rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark: function removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */\n  setNormalizing: function setNormalizing(editor, isNormalizing) {\n    NORMALIZING.set(editor, isNormalizing);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start: function start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */\n  string: function string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids7 = options.voids,\n        voids = _options$voids7 === void 0 ? false : _options$voids7;\n    var range = Editor.range(editor, at);\n\n    var _Range$edges5 = Range.edges(range),\n        _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n        start = _Range$edges6[0],\n        end = _Range$edges6[1];\n\n    var text = '';\n\n    var _iterator8 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids: voids\n    })),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _step8$value = _slicedToArray(_step8.value, 2),\n            node = _step8$value[0],\n            path = _step8$value[1];\n\n        var t = node.text;\n\n        if (Path.equals(path, end.path)) {\n          t = t.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          t = t.slice(start.offset);\n        }\n\n        text += t;\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange: function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids8 = options.voids,\n        voids = _options$voids8 === void 0 ? false : _options$voids8;\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      voids: voids\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    var _iterator9 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids: voids\n    })),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n            node = _step9$value[0],\n            path = _step9$value[1];\n\n        if (skip) {\n          skip = false;\n          continue;\n        }\n\n        if (node.text !== '' || Path.isBefore(path, blockPath)) {\n          end = {\n            path: path,\n            offset: node.text.length\n          };\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  \"void\": function _void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isVoid(editor, n);\n      }\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n\n    try {\n      fn();\n    } finally {\n      Editor.setNormalizing(editor, value);\n    }\n\n    Editor.normalize(editor);\n  }\n};\n\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n}; // eslint-disable-next-line no-redeclare\n\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\n\nvar _excluded$3 = [\"children\"],\n    _excluded2$2 = [\"text\"];\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }\n\nfunction _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  ancestors: function* ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _iterator = _createForOfIteratorHelper$4(Path.ancestors(path, options)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var p = _step.value;\n        var n = Node.ancestor(root, p);\n        var entry = [n, p];\n        yield entry;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  children: function* children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var ancestor = Node.ancestor(root, path);\n    var children = ancestor.children;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  descendants: function* descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _iterator2 = _createForOfIteratorHelper$4(Node.nodes(root, options)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            node = _step2$value[0],\n            path = _step2$value[1];\n\n        if (path.length !== 0) {\n          // NOTE: we have to coerce here because checking the path's length does\n          // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n          yield [node, path];\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  },\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  elements: function* elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _iterator3 = _createForOfIteratorHelper$4(Node.nodes(root, options)),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n            node = _step3$value[0],\n            path = _step3$value[1];\n\n        if (Element.isElement(node)) {\n          yield [node, path];\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  },\n\n  /**\r\n   * Extract props from a Node.\r\n   */\n  extractProps: function extractProps(node) {\n    if (Element.isAncestor(node)) {\n      node.children;\n          var properties = _objectWithoutProperties(node, _excluded$3);\n\n      return properties;\n    } else {\n      node.text;\n          var _properties = _objectWithoutProperties(node, _excluded2$2);\n\n      return _properties;\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var newRoot = immer.produce({\n      children: root.children\n    }, function (r) {\n      var _Range$edges = Range.edges(range),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              path = _ref2[1];\n\n          return !Range.includes(range, path);\n        }\n      });\n\n      var _iterator4 = _createForOfIteratorHelper$4(nodeEntries),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              path = _step4$value[1];\n\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get: function get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has: function has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList: function isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(function (val) {\n      return Node.isNode(val);\n    });\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  levels: function* levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _iterator5 = _createForOfIteratorHelper$4(Path.levels(path, options)),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var p = _step5.value;\n        var n = Node.get(root, p);\n        yield [n, p];\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  },\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  nodes: function* nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var pass = options.pass,\n        _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n    var _options$from = options.from,\n        from = _options$from === void 0 ? [] : _options$from,\n        to = options.to;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't descended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string: function string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  texts: function* texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _iterator6 = _createForOfIteratorHelper$4(Node.nodes(root, options)),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var _step6$value = _slicedToArray(_step6.value, 2),\n            node = _step6$value[0],\n            path = _step6$value[1];\n\n        if (Text.isText(node)) {\n          yield [node, path];\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n};\n\nfunction ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Operation = {\n  /**\r\n   * Check if a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check if a value is an `Operation` object.\r\n   */\n  isOperation: function isOperation(value) {\n    if (!isPlainObject.isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject.isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Operation.isOperation(val);\n    });\n  },\n\n  /**\r\n   * Check if a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check if a value is a `TextOperation` object.\r\n   */\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n              path = op.path; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var properties = op.properties,\n              newProperties = op.newProperties;\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n              _newProperties = op.newProperties;\n\n          if (_properties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common: function common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n\n  /**\r\n   * Check if the path of previous sibling node exists\r\n   */\n  hasPrevious: function hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */\n  operationCanTransformPath: function operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null; // PERF: use destructing instead of immer\n\n    var p = _toConsumableArray(path);\n\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n    if (path.length === 0) {\n      return p;\n    }\n\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var op = operation.path;\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var _op = operation.path;\n\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var _op2 = operation.path,\n              position = operation.position;\n\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var _op3 = operation.path,\n              _position = operation.position;\n\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var _op4 = operation.path,\n              onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n\n            p[_op4.length - 1] -= 1;\n          }\n\n          break;\n        }\n    }\n\n    return p;\n  }\n};\n\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint: function isPoint(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(point, function (p) {\n      if (p === null) {\n        return null;\n      }\n\n      var _options$affinity = options.affinity,\n          affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n      var path = p.path,\n          offset = p.offset;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\n\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar _excluded$2 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end: function end(range) {\n    var _Range$edges = Range.edges(range),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        end = _Range$edges2[1];\n\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var _Range$edges3 = Range.edges(range),\n          _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n          rs = _Range$edges4[0],\n          re = _Range$edges4[1];\n\n      var _Range$edges5 = Range.edges(target),\n          _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n          ts = _Range$edges6[0],\n          te = _Range$edges6[1];\n\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1];\n\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection: function intersection(range, another) {\n    range.anchor;\n        range.focus;\n        var rest = _objectWithoutProperties(range, _excluded$2);\n\n    var _Range$edges9 = Range.edges(range),\n        _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n        s1 = _Range$edges10[0],\n        e1 = _Range$edges10[1];\n\n    var _Range$edges11 = Range.edges(another),\n        _Range$edges12 = _slicedToArray(_Range$edges11, 2),\n        s2 = _Range$edges12[0],\n        e2 = _Range$edges12[1];\n\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$5({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange: function isRange(value) {\n    return isPlainObject.isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  points: function* points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start: function start(range) {\n    var _Range$edges13 = Range.edges(range),\n        _Range$edges14 = _slicedToArray(_Range$edges13, 1),\n        start = _Range$edges14[0];\n\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform: function transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(range, function (r) {\n      if (r === null) {\n        return null;\n      }\n\n      var _options$affinity = options.affinity,\n          affinity = _options$affinity === void 0 ? 'inward' : _options$affinity;\n      var affinityAnchor;\n      var affinityFocus;\n\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\n\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */\n// eslint-disable-next-line no-redeclare\n\nvar Scrubber = {\n  setScrubber: function setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify: function stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\n\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */\n\nvar isDeepEqual = function isDeepEqual(node, another) {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n\n    if (isPlainObject.isPlainObject(a) && isPlainObject.isPlainObject(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */\n\n\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar _excluded$1 = [\"text\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\n\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */\n  equals: function equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$loose = options.loose,\n        loose = _options$loose === void 0 ? false : _options$loose;\n\n    function omitText(obj) {\n      obj.text;\n          var rest = _objectWithoutProperties(obj, _excluded$1);\n\n      return rest;\n    }\n\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText: function isText(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Text.isText(val);\n    });\n  },\n\n  /**\r\n   * Check if some props are a partial of Text.\r\n   */\n  isTextProps: function isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations: function decorations(node, _decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    var _iterator = _createForOfIteratorHelper$3(_decorations),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dec = _step.value;\n\n        var anchor = dec.anchor,\n            focus = dec.focus,\n            rest = _objectWithoutProperties(dec, _excluded2$1);\n\n        var _Range$edges = Range.edges(dec),\n            _Range$edges2 = _slicedToArray(_Range$edges, 2),\n            start = _Range$edges2[0],\n            end = _Range$edges2[1];\n\n        var next = [];\n        var leafEnd = 0;\n        var decorationStart = start.offset;\n        var decorationEnd = end.offset;\n\n        var _iterator2 = _createForOfIteratorHelper$3(leaves),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var leaf = _step2.value;\n            var length = leaf.text.length;\n            var leafStart = leafEnd;\n            leafEnd += length; // If the range encompasses the entire leaf, add the range.\n\n            if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n              Object.assign(leaf, rest);\n              next.push(leaf);\n              continue;\n            } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n            if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n              next.push(leaf);\n              continue;\n            } // Otherwise we need to split the leaf, at the start, end, or both,\n            // and add the range to the middle intersecting section. Do the end\n            // split first since we don't need to update the offset that way.\n\n\n            var middle = leaf;\n            var before = void 0;\n            var after = void 0;\n\n            if (decorationEnd < leafEnd) {\n              var off = decorationEnd - leafStart;\n              after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(off)\n              });\n              middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(0, off)\n              });\n            }\n\n            if (decorationStart > leafStart) {\n              var _off = decorationStart - leafStart;\n\n              before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(0, _off)\n              });\n              middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(_off)\n              });\n            }\n\n            Object.assign(middle, rest);\n\n            if (before) {\n              next.push(before);\n            }\n\n            next.push(middle);\n\n            if (after) {\n              next.push(after);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        leaves = next;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return leaves;\n  }\n};\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\n\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar applyToDraft = function applyToDraft(editor, selection, op) {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var path = op.path,\n            node = op.node;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n\n        parent.children.splice(index, 0, node);\n\n        if (selection) {\n          var _iterator = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                  point = _step$value[0],\n                  key = _step$value[1];\n\n              selection[key] = Point.transform(point, op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'insert_text':\n      {\n        var _path = op.path,\n            offset = op.offset,\n            text = op.text;\n        if (text.length === 0) break;\n\n        var _node = Node.leaf(editor, _path);\n\n        var before = _node.text.slice(0, offset);\n\n        var after = _node.text.slice(offset);\n\n        _node.text = before + text + after;\n\n        if (selection) {\n          var _iterator2 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  _point = _step2$value[0],\n                  _key = _step2$value[1];\n\n              selection[_key] = Point.transform(_point, op);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'merge_node':\n      {\n        var _path2 = op.path;\n\n        var _node2 = Node.get(editor, _path2);\n\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n\n        var _parent = Node.parent(editor, _path2);\n\n        var _index = _path2[_path2.length - 1];\n\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          var _prev$children;\n\n          (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n\n        _parent.children.splice(_index, 1);\n\n        if (selection) {\n          var _iterator3 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                  _point2 = _step3$value[0],\n                  _key2 = _step3$value[1];\n\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'move_node':\n      {\n        var _path3 = op.path,\n            newPath = op.newPath;\n\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n\n        var _node3 = Node.get(editor, _path3);\n\n        var _parent2 = Node.parent(editor, _path3);\n\n        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n\n        _parent2.children.splice(_index2, 1);\n\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n\n        if (selection) {\n          var _iterator4 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _step4$value = _slicedToArray(_step4.value, 2),\n                  _point3 = _step4$value[0],\n                  _key3 = _step4$value[1];\n\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_node':\n      {\n        var _path4 = op.path;\n        var _index3 = _path4[_path4.length - 1];\n\n        var _parent3 = Node.parent(editor, _path4);\n\n        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n\n\n        if (selection) {\n          var _iterator5 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _step5$value = _slicedToArray(_step5.value, 2),\n                  _point4 = _step5$value[0],\n                  _key4 = _step5$value[1];\n\n              var result = Point.transform(_point4, op);\n\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n\n                var next = void 0;\n\n                var _iterator6 = _createForOfIteratorHelper$2(Node.texts(editor)),\n                    _step6;\n\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var _step6$value = _slicedToArray(_step6.value, 2),\n                        n = _step6$value[0],\n                        p = _step6$value[1];\n\n                    if (Path.compare(p, _path4) === -1) {\n                      _prev = [n, p];\n                    } else {\n                      next = [n, p];\n                      break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n\n                var preferNext = false;\n\n                if (_prev && next) {\n                  if (Path.equals(next[1], _path4)) {\n                    preferNext = !Path.hasPrevious(next[1]);\n                  } else {\n                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                  }\n                }\n\n                if (_prev && !preferNext) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_text':\n      {\n        var _path5 = op.path,\n            _offset = op.offset,\n            _text = op.text;\n        if (_text.length === 0) break;\n\n        var _node4 = Node.leaf(editor, _path5);\n\n        var _before = _node4.text.slice(0, _offset);\n\n        var _after = _node4.text.slice(_offset + _text.length);\n\n        _node4.text = _before + _after;\n\n        if (selection) {\n          var _iterator7 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _step7$value = _slicedToArray(_step7.value, 2),\n                  _point5 = _step7$value[0],\n                  _key5 = _step7$value[1];\n\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'set_node':\n      {\n        var _path6 = op.path,\n            properties = op.properties,\n            newProperties = op.newProperties;\n\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n\n        var _node5 = Node.get(editor, _path6);\n\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n\n          var value = newProperties[_key6];\n\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        } // properties that were previously defined, but are now missing, must be deleted\n\n\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n\n        break;\n      }\n\n    case 'set_selection':\n      {\n        var _newProperties = op.newProperties;\n\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _objectSpread$3({}, _newProperties);\n          }\n\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'split_node':\n      {\n        var _path7 = op.path,\n            position = op.position,\n            _properties = op.properties;\n\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n\n        var _node6 = Node.get(editor, _path7);\n\n        var _parent4 = Node.parent(editor, _path7);\n\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n\n          var _after2 = _node6.text.slice(position);\n\n          _node6.text = _before2;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n\n          var _after3 = _node6.children.slice(position);\n\n          _node6.children = _before3;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            children: _after3\n          });\n        }\n\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n\n        if (selection) {\n          var _iterator8 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _step8$value = _slicedToArray(_step8.value, 2),\n                  _point6 = _step8$value[0],\n                  _key9 = _step8$value[1];\n\n              selection[_key9] = Point.transform(_point6, op);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n\n        break;\n      }\n  }\n\n  return selection;\n}; // eslint-disable-next-line no-redeclare\n\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform: function transform(editor, op) {\n    editor.children = immer.createDraft(editor.children);\n    var selection = editor.selection && immer.createDraft(editor.selection);\n\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = immer.finishDraft(editor.children);\n\n      if (selection) {\n        editor.selection = immer.isDraft(selection) ? immer.finishDraft(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\n\nvar _excluded = [\"text\"],\n    _excluded2 = [\"children\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\n\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes: function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging,\n          _options$voids = options.voids,\n          voids = _options$voids === void 0 ? false : _options$voids,\n          _options$mode = options.mode,\n          mode = _options$mode === void 0 ? 'lowest' : _options$mode;\n      var at = options.at,\n          match = options.match,\n          select = options.select;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var _nodes = nodes,\n          _nodes2 = _slicedToArray(_nodes, 1),\n          node = _nodes2[0]; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at, {\n            voids: voids\n          });\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges = Range.edges(at),\n              _Range$edges2 = _slicedToArray(_Range$edges, 2),\n              end = _Range$edges2[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = function match(n) {\n              return Text.isText(n);\n            };\n          } else if (editor.isInline(node)) {\n            match = function match(n) {\n              return Text.isText(n) || Editor.isInline(editor, n);\n            };\n          } else {\n            match = function match(n) {\n              return Element.isElement(n) && Editor.isBlock(editor, n);\n            };\n          }\n        }\n\n        var _Editor$nodes = Editor.nodes(editor, {\n          at: at.path,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n            _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n            entry = _Editor$nodes2[0];\n\n        if (entry) {\n          var _entry = _slicedToArray(entry, 2),\n              _matchPath = _entry[1];\n\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at: at,\n            match: match,\n            mode: mode,\n            voids: voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      var _iterator = _createForOfIteratorHelper$1(nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _node = _step.value;\n\n          var _path = parentPath.concat(index);\n\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path,\n            node: _node\n          });\n          at = Path.next(at);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      at = Path.previous(at);\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes: function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at = options.at,\n          at = _options$at === void 0 ? editor.selection : _options$at,\n          _options$mode2 = options.mode,\n          mode = _options$mode2 === void 0 ? 'lowest' : _options$mode2,\n          _options$voids2 = options.voids,\n          voids = _options$voids2 === void 0 ? false : _options$voids2;\n      var match = options.match;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            p = _ref2[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n        var pathRef = _pathRefs[_i];\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n\n        var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2),\n            parent = _parentNodeEntry[0],\n            parentPath = _parentNodeEntry[1];\n\n        var index = path[path.length - 1];\n        var length = parent.children.length;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids: voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids: voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids: voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids: voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids: voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids: voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes: function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at2 = options.at,\n          at = _options$at2 === void 0 ? editor.selection : _options$at2;\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2,\n          _options$voids3 = options.voids,\n          voids = _options$voids3 === void 0 ? false : _options$voids3,\n          _options$mode3 = options.mode,\n          mode = _options$mode3 === void 0 ? 'lowest' : _options$mode3;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var _Editor$parent = Editor.parent(editor, at),\n              _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n              parent = _Editor$parent2[0];\n\n          match = function match(n) {\n            return parent.children.includes(n);\n          };\n        } else {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges3 = Range.edges(at),\n              _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n              end = _Range$edges4[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var _Editor$nodes3 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      }),\n          _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n          current = _Editor$nodes4[0];\n\n      var prev = Editor.previous(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var _current = _slicedToArray(current, 2),\n          node = _current[0],\n          path = _current[1];\n\n      var _prev = _slicedToArray(prev, 2),\n          prevNode = _prev[0],\n          prevPath = _prev[1];\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            n = _ref4[0];\n\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: function match(n) {\n          return levels.includes(n) && hasSingleChildNest(editor, n);\n        }\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        node.text;\n            var rest = _objectWithoutProperties(node, _excluded);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        node.children;\n            var _rest = _objectWithoutProperties(node, _excluded2);\n\n        position = prevNode.children.length;\n        properties = _rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids: voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids: voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      // if prevNode is first child in parent,don't remove it.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0) {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids: voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position: position,\n          properties: properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes: function moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var to = options.to,\n          _options$at3 = options.at,\n          at = _options$at3 === void 0 ? editor.selection : _options$at3,\n          _options$mode4 = options.mode,\n          mode = _options$mode4 === void 0 ? 'lowest' : _options$mode4,\n          _options$voids4 = options.voids,\n          voids = _options$voids4 === void 0 ? false : _options$voids4;\n      var match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(targets, function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            p = _ref6[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++) {\n        var pathRef = _pathRefs2[_i2];\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path: path,\n            newPath: newPath\n          });\n        }\n\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes: function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging3 = options.hanging,\n          hanging = _options$hanging3 === void 0 ? false : _options$hanging3,\n          _options$voids5 = options.voids,\n          voids = _options$voids5 === void 0 ? false : _options$voids5,\n          _options$mode5 = options.mode,\n          mode = _options$mode5 === void 0 ? 'lowest' : _options$mode5;\n      var _options$at4 = options.at,\n          at = _options$at4 === void 0 ? editor.selection : _options$at4,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      var depths = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(depths, function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            p = _ref8[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++) {\n        var pathRef = _pathRefs3[_i3];\n        var path = pathRef.unref();\n\n        if (path) {\n          var _Editor$node = Editor.node(editor, path),\n              _Editor$node2 = _slicedToArray(_Editor$node, 1),\n              node = _Editor$node2[0];\n\n          editor.apply({\n            type: 'remove_node',\n            path: path,\n            node: node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes: function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at5 = options.at,\n          at = _options$at5 === void 0 ? editor.selection : _options$at5,\n          compare = options.compare,\n          merge = options.merge;\n      var _options$hanging4 = options.hanging,\n          hanging = _options$hanging4 === void 0 ? false : _options$hanging4,\n          _options$mode6 = options.mode,\n          mode = _options$mode6 === void 0 ? 'lowest' : _options$mode6,\n          _options$split = options.split,\n          split = _options$split === void 0 ? false : _options$split,\n          _options$voids6 = options.voids,\n          voids = _options$voids6 === void 0 ? false : _options$voids6;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      if (split && Range.isRange(at)) {\n        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n          // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n          // set that won't get normalized away\n          return;\n        }\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n\n        var _Range$edges5 = Range.edges(at),\n            _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n            start = _Range$edges6[0],\n            end = _Range$edges6[1];\n\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          mode: splitMode,\n          voids: voids,\n          always: !endAtEndOfNode\n        });\n        var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          mode: splitMode,\n          voids: voids,\n          always: !startAtStartOfNode\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      if (!compare) {\n        compare = function compare(prop, nodeProp) {\n          return prop !== nodeProp;\n        };\n      }\n\n      var _iterator2 = _createForOfIteratorHelper$1(Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      })),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              node = _step2$value[0],\n              path = _step2$value[1];\n\n          var properties = {};\n          var newProperties = {}; // You can't set properties on the editor node.\n\n          if (path.length === 0) {\n            continue;\n          }\n\n          var hasChanges = false;\n\n          for (var k in props) {\n            if (k === 'children' || k === 'text') {\n              continue;\n            }\n\n            if (compare(props[k], node[k])) {\n              hasChanges = true; // Omit new properties from the old properties list\n\n              if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n\n              if (merge) {\n                if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n              } else {\n                if (props[k] != null) newProperties[k] = props[k];\n              }\n            }\n          }\n\n          if (hasChanges) {\n            editor.apply({\n              type: 'set_node',\n              path: path,\n              properties: properties,\n              newProperties: newProperties\n            });\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes: function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode7 = options.mode,\n          mode = _options$mode7 === void 0 ? 'lowest' : _options$mode7,\n          _options$voids7 = options.voids,\n          voids = _options$voids7 === void 0 ? false : _options$voids7;\n      var match = options.match,\n          _options$at6 = options.at,\n          at = _options$at6 === void 0 ? editor.selection : _options$at6,\n          _options$height = options.height,\n          height = _options$height === void 0 ? 0 : _options$height,\n          _options$always = options.always,\n          always = _options$always === void 0 ? false : _options$always;\n\n      if (match == null) {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n\n        var _Editor$parent3 = Editor.parent(editor, path),\n            _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n            parent = _Editor$parent4[0];\n\n        match = function match(n) {\n          return n === parent;\n        };\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var afterRef;\n\n      try {\n        var _Editor$nodes5 = Editor.nodes(editor, {\n          at: at,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n            _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n            highest = _Editor$nodes6[0];\n\n        if (!highest) {\n          return;\n        }\n\n        var voidMatch = Editor[\"void\"](editor, {\n          at: at,\n          mode: 'highest'\n        });\n        var nudge = 0;\n\n        if (!voids && voidMatch) {\n          var _voidMatch = _slicedToArray(voidMatch, 2),\n              voidNode = _voidMatch[0],\n              voidPath = _voidMatch[1];\n\n          if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n            var after = Editor.after(editor, voidPath);\n\n            if (!after) {\n              var text = {\n                text: ''\n              };\n              var afterPath = Path.next(voidPath);\n              Transforms.insertNodes(editor, text, {\n                at: afterPath,\n                voids: voids\n              });\n              after = Editor.point(editor, afterPath);\n            }\n\n            at = after;\n            always = true;\n          }\n\n          var siblingHeight = at.path.length - voidPath.length;\n          height = siblingHeight + 1;\n          always = true;\n        }\n\n        afterRef = Editor.pointRef(editor, at);\n        var depth = at.path.length - height;\n\n        var _highest = _slicedToArray(highest, 2),\n            highestPath = _highest[1];\n\n        var lowestPath = at.path.slice(0, depth);\n        var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n        var _iterator3 = _createForOfIteratorHelper$1(Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids: voids\n        })),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n                node = _step3$value[0],\n                _path2 = _step3$value[1];\n\n            var split = false;\n\n            if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n              break;\n            }\n\n            var _point2 = beforeRef.current;\n            var isEnd = Editor.isEnd(editor, _point2, _path2);\n\n            if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path2)) {\n              split = true;\n              var properties = Node.extractProps(node);\n              editor.apply({\n                type: 'split_node',\n                path: _path2,\n                position: position,\n                properties: properties\n              });\n            }\n\n            position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (options.at == null) {\n          var _point = afterRef.current || Editor.end(editor, []);\n\n          Transforms.select(editor, _point);\n        }\n      } finally {\n        var _afterRef;\n\n        beforeRef.unref();\n        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes: function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    var _iterator4 = _createForOfIteratorHelper$1(props),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var key = _step4.value;\n        obj[key] = null;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes: function unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode8 = options.mode,\n          mode = _options$mode8 === void 0 ? 'lowest' : _options$mode8,\n          _options$split2 = options.split,\n          split = _options$split2 === void 0 ? false : _options$split2,\n          _options$voids8 = options.voids,\n          voids = _options$voids8 === void 0 ? false : _options$voids8;\n      var _options$at7 = options.at,\n          at = _options$at7 === void 0 ? editor.selection : _options$at7,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            p = _ref10[1];\n\n        return Editor.pathRef(editor, p);\n      } // unwrapNode will call liftNode which does not support splitting the node when nested.\n      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n      // that wrap target node. So we reverse the order.\n      ).reverse();\n\n      var _iterator5 = _createForOfIteratorHelper$1(pathRefs),\n          _step5;\n\n      try {\n        var _loop = function _loop() {\n          var pathRef = _step5.value;\n          var path = pathRef.unref();\n\n          var _Editor$node3 = Editor.node(editor, path),\n              _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n              node = _Editor$node4[0];\n\n          var range = Editor.range(editor, path);\n\n          if (split && rangeRef) {\n            range = Range.intersection(rangeRef.current, range);\n          }\n\n          Transforms.liftNodes(editor, {\n            at: range,\n            match: function match(n) {\n              return Element.isAncestor(node) && node.children.includes(n);\n            },\n            voids: voids\n          });\n        };\n\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes: function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode9 = options.mode,\n          mode = _options$mode9 === void 0 ? 'lowest' : _options$mode9,\n          _options$split3 = options.split,\n          split = _options$split3 === void 0 ? false : _options$split3,\n          _options$voids9 = options.voids,\n          voids = _options$voids9 === void 0 ? false : _options$voids9;\n      var match = options.match,\n          _options$at8 = options.at,\n          at = _options$at8 === void 0 ? editor.selection : _options$at8;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n          };\n        } else {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var _Range$edges7 = Range.edges(at),\n            _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n            start = _Range$edges8[0],\n            end = _Range$edges8[1];\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          voids: voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          voids: voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at: at,\n        match: editor.isInline(element) ? function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        } : function (n) {\n          return Editor.isEditor(n);\n        },\n        mode: 'lowest',\n        voids: voids\n      }));\n\n      for (var _i4 = 0, _roots = roots; _i4 < _roots.length; _i4++) {\n        var _roots$_i = _slicedToArray(_roots[_i4], 2),\n            rootPath = _roots$_i[1];\n\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match: match,\n          mode: mode,\n          voids: voids\n        }));\n\n        if (matches.length > 0) {\n          var _ret = function () {\n            var _matches = _slicedToArray(matches, 1),\n                first = _matches[0];\n\n            var last = matches[matches.length - 1];\n\n            var _first = _slicedToArray(first, 2),\n                firstPath = _first[1];\n\n            var _last = _slicedToArray(last, 2),\n                lastPath = _last[1];\n\n            if (firstPath.length === 0 && lastPath.length === 0) {\n              // if there's no matching parent - usually means the node is an editor - don't do anything\n              return \"continue\";\n            }\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n\n            var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1),\n                commonNode = _commonNodeEntry[0];\n\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids: voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: function match(n) {\n                return Element.isAncestor(commonNode) && commonNode.children.includes(n);\n              },\n              to: wrapperPath.concat(0),\n              voids: voids\n            });\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n      }\n    });\n  }\n};\n\nvar hasSingleChildNest = function hasSingleChildNest(editor, node) {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\n\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges9 = Range.edges(range),\n        _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n        end = _Range$edges10[1];\n\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms[\"delete\"](editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = function matchPath(editor, path) {\n  var _Editor$node5 = Editor.node(editor, path),\n      _Editor$node6 = _slicedToArray(_Editor$node5, 1),\n      node = _Editor$node6[0];\n\n  return function (n) {\n    return n === node;\n  };\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse: function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'anchor' : _options$edge;\n    var selection = editor.selection;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var _Range$edges = Range.edges(selection),\n          _Range$edges2 = _slicedToArray(_Range$edges, 1),\n          start = _Range$edges2[0];\n\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var _Range$edges3 = Range.edges(selection),\n          _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n          end = _Range$edges4[1];\n\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move: function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var selection = editor.selection;\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance,\n        _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit,\n        _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var _options$edge2 = options.edge,\n        edge = _options$edge2 === void 0 ? null : _options$edge2;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var opts = {\n      distance: distance,\n      unit: unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select: function select(editor, target) {\n    var selection = editor.selection;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint: function setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var selection = editor.selection;\n    var _options$edge3 = options.edge,\n        edge = _options$edge3 === void 0 ? 'both' : _options$edge3;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, _defineProperty({}, edge === 'anchor' ? 'anchor' : 'focus', _objectSpread$1(_objectSpread$1({}, point), props)));\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection: function setSelection(editor, props) {\n    var selection = editor.selection;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  \"delete\": function _delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$reverse = options.reverse,\n          reverse = _options$reverse === void 0 ? false : _options$reverse,\n          _options$unit = options.unit,\n          unit = _options$unit === void 0 ? 'character' : _options$unit,\n          _options$distance = options.distance,\n          distance = _options$distance === void 0 ? 1 : _options$distance,\n          _options$voids = options.voids,\n          voids = _options$voids === void 0 ? false : _options$voids;\n      var _options$at = options.at,\n          at = _options$at === void 0 ? editor.selection : _options$at,\n          _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging;\n\n      if (!at) {\n        return;\n      }\n\n      var isCollapsed = false;\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        isCollapsed = true;\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor[\"void\"](editor, {\n          at: at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var _furthestVoid = _slicedToArray(furthestVoid, 2),\n              voidPath = _furthestVoid[1];\n\n          at = voidPath;\n        } else {\n          var opts = {\n            unit: unit,\n            distance: distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at: at,\n          voids: voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        var _Range$edges = Range.edges(at),\n            _Range$edges2 = _slicedToArray(_Range$edges, 2),\n            _end = _Range$edges2[1];\n\n        var endOfDoc = Editor.end(editor, []);\n\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids: voids\n          });\n        }\n      }\n\n      var _Range$edges3 = Range.edges(at),\n          _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n          start = _Range$edges4[0],\n          end = _Range$edges4[1];\n\n      var startBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        at: start,\n        voids: voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        at: end,\n        voids: voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor[\"void\"](editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor[\"void\"](editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      var _iterator = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        voids: voids\n      })),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n\n          var _entry = _slicedToArray(entry, 2),\n              _node2 = _entry[0],\n              _path2 = _entry[1];\n\n          if (lastPath && Path.compare(_path2, lastPath) === 0) {\n            continue;\n          }\n\n          if (!voids && Element.isElement(_node2) && Editor.isVoid(editor, _node2) || !Path.isCommon(_path2, start.path) && !Path.isCommon(_path2, end.path)) {\n            matches.push(entry);\n            lastPath = _path2;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            p = _ref2[1];\n\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n      var removedText = '';\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n\n        var _Editor$leaf = Editor.leaf(editor, _point),\n            _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n            node = _Editor$leaf2[0];\n\n        var path = _point.path;\n        var _start = start,\n            offset = _start.offset;\n        var text = node.text.slice(offset);\n\n        if (text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: path,\n            offset: offset,\n            text: text\n          });\n          removedText = text;\n        }\n      }\n\n      pathRefs.reverse().map(function (r) {\n        return r.unref();\n      }).filter(function (r) {\n        return r !== null;\n      }).forEach(function (p) {\n        return Transforms.removeNodes(editor, {\n          at: p,\n          voids: voids\n        });\n      });\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n\n        var _Editor$leaf3 = Editor.leaf(editor, _point2),\n            _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n            _node = _Editor$leaf4[0];\n\n        var _path = _point2.path;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node.text.slice(_offset, end.offset);\n\n        if (_text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path,\n            offset: _offset,\n            text: _text\n          });\n          removedText = _text;\n        }\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids: voids\n        });\n      } // For Thai script, deleting N character(s) backward should delete\n      // N code point(s) instead of an entire grapheme cluster.\n      // Therefore, the remaining code points should be inserted back.\n\n\n      if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n      }\n\n      var startUnref = startRef.unref();\n      var endUnref = endRef.unref();\n      var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2,\n          _options$voids2 = options.voids,\n          voids = _options$voids2 === void 0 ? false : _options$voids2;\n      var _options$at2 = options.at,\n          at = _options$at2 === void 0 ? editor.selection : _options$at2;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at, {\n            voids: voids\n          });\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges5 = Range.edges(at),\n              _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n              end = _Range$edges6[1];\n\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at: at,\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (inlineElementMatch) {\n        var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2),\n            _inlinePath = _inlineElementMatch[1];\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        at: at,\n        voids: voids\n      });\n\n      var _blockMatch = _slicedToArray(blockMatch, 2),\n          blockPath = _blockMatch[1];\n\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var isBlockEmpty = isBlockStart && isBlockEnd;\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n\n      var _Node$first = Node.first({\n        children: fragment\n      }, []),\n          _Node$first2 = _slicedToArray(_Node$first, 2),\n          firstPath = _Node$first2[1];\n\n      var _Node$last = Node.last({\n        children: fragment\n      }, []),\n          _Node$last2 = _slicedToArray(_Node$last, 2),\n          lastPath = _Node$last2[1];\n\n      var matches = [];\n\n      var matcher = function matcher(_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            n = _ref4[0],\n            p = _ref4[1];\n\n        var isRoot = p.length === 0;\n\n        if (isRoot) {\n          return false;\n        }\n\n        if (isBlockEmpty) {\n          return true;\n        }\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      var _iterator2 = _createForOfIteratorHelper(Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var entry = _step2.value;\n\n          if (matcher(entry)) {\n            matches.push(entry);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n        var _matches$_i = _slicedToArray(_matches[_i], 1),\n            node = _matches$_i[0];\n\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var _Editor$nodes = Editor.nodes(editor, {\n        at: at,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      }),\n          _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n          inlineMatch = _Editor$nodes2[0];\n\n      var _inlineMatch = _slicedToArray(inlineMatch, 2),\n          inlinePath = _inlineMatch[1];\n\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at: at,\n        match: function match(n) {\n          return hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: hasBlocks ? 'lowest' : 'highest',\n        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n        voids: voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n        Transforms[\"delete\"](editor, {\n          at: blockPath,\n          voids: voids\n        });\n      }\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        mode: 'lowest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0 && endRef.current) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0 && middleRef.current) {\n          path = Path.previous(middleRef.current);\n        } else if (startRef.current) {\n          path = Path.previous(startRef.current);\n        }\n\n        if (path) {\n          var _end2 = Editor.end(editor, path);\n\n          Transforms.select(editor, _end2);\n        }\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$voids3 = options.voids,\n          voids = _options$voids3 === void 0 ? false : _options$voids3;\n      var _options$at3 = options.at,\n          at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at,\n            voids: voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      })) {\n        return;\n      }\n\n      var _at = at,\n          path = _at.path,\n          offset = _at.offset;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\nexports.Editor = Editor;\nexports.Element = Element;\nexports.Location = Location;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Path = Path;\nexports.PathRef = PathRef;\nexports.Point = Point;\nexports.PointRef = PointRef;\nexports.Range = Range;\nexports.RangeRef = RangeRef;\nexports.Scrubber = Scrubber;\nexports.Span = Span;\nexports.Text = Text;\nexports.Transforms = Transforms;\nexports.createEditor = createEditor;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELG9CQUFvQixtQkFBTyxDQUFDLHFGQUFpQjtBQUM3QyxZQUFZLG1CQUFPLENBQUMsdURBQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUEsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsT0FBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNB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QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FB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LEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTzs7QUFFNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9GQUFvRixjQUFjO0FBQ2xHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxR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Q0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNERBQTRELGNBQWM7QUFDMUU7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUUzVSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8saURBQWlELG1GQUFtRixPQUFPO0FBQ3RnQiwyRUFBMkU7O0FBRTNFLGNBQWM7QUFDZCxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsWUFBWTtBQUNaLGVBQWU7QUFDZixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixZQUFZO0FBQ1osa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BwYXlsb2FkY21zL3RlbXBsYXRlLWVjb21tZXJjZS8uL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmpzPzg1ZjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xudmFyIGltbWVyID0gcmVxdWlyZSgnaW1tZXInKTtcblxuZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheUxpa2VUb0FycmF5KTtcblxudmFyIGFycmF5V2l0aG91dEhvbGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5V2l0aG91dEhvbGVzKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXRlcmFibGVUb0FycmF5KTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyh1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSk7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobm9uSXRlcmFibGVTcHJlYWQpO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IHVud3JhcEV4cG9ydHModG9Db25zdW1hYmxlQXJyYXkpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHVud3JhcEV4cG9ydHMoZGVmaW5lUHJvcGVydHkpO1xuXG52YXIgYXJyYXlXaXRoSG9sZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlXaXRoSG9sZXMpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXRlcmFibGVUb0FycmF5TGltaXQpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobm9uSXRlcmFibGVSZXN0KTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IHVud3JhcEV4cG9ydHMoc2xpY2VkVG9BcnJheSk7XG5cbnZhciBESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRElSVFlfUEFUSF9LRVlTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBGTFVTSElORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9STUFMSVpJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBBVEhfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUE9JTlRfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUkFOR0VfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIG93bktleXMkOShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDkoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ3KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBTbGF0ZSBgRWRpdG9yYCBvYmplY3QuXHJcbiAqL1xuXG52YXIgY3JlYXRlRWRpdG9yID0gZnVuY3Rpb24gY3JlYXRlRWRpdG9yKCkge1xuICB2YXIgZWRpdG9yID0ge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgbWFya3M6IG51bGwsXG4gICAgaXNJbmxpbmU6IGZ1bmN0aW9uIGlzSW5saW5lKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNWb2lkOiBmdW5jdGlvbiBpc1ZvaWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtYXJrYWJsZVZvaWQ6IGZ1bmN0aW9uIG1hcmthYmxlVm9pZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseShvcCkge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciByZWYgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcikpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgUmFuZ2VSZWYudHJhbnNmb3JtKF9yZWYyLCBvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgICAgdmFyIG9sZERpcnR5UGF0aEtleXMgPSBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgICAgdmFyIGRpcnR5UGF0aHM7XG4gICAgICB2YXIgZGlydHlQYXRoS2V5cztcblxuICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuXG4gICAgICAgICAgaWYgKCFkaXJ0eVBhdGhLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBkaXJ0eVBhdGhLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgZGlydHlQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKFBhdGgub3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcCkpIHtcbiAgICAgICAgZGlydHlQYXRocyA9IFtdO1xuICAgICAgICBkaXJ0eVBhdGhLZXlzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhvbGREaXJ0eVBhdGhzKSxcbiAgICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICAgICAgYWRkKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBvbGREaXJ0eVBhdGhzO1xuICAgICAgICBkaXJ0eVBhdGhLZXlzID0gb2xkRGlydHlQYXRoS2V5cztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0RpcnR5UGF0aHMgPSBlZGl0b3IuZ2V0RGlydHlQYXRocyhvcCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhuZXdEaXJ0eVBhdGhzKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9wYXRoID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgIGFkZChfcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuXG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhzKTtcbiAgICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhLZXlzKTtcbiAgICAgIFRyYW5zZm9ybXMudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvciwge1xuICAgICAgICBvcGVyYXRpb246IG9wXG4gICAgICB9KTsgLy8gQ2xlYXIgYW55IGZvcm1hdHMgYXBwbGllZCB0byB0aGUgY3Vyc29yIGlmIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cblxuICAgICAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogb3BcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlZGl0b3Iub3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmsoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgICAgZWRpdG9yLm1hcmthYmxlVm9pZDtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChub2RlLCBwYXRoKSB7XG4gICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50LCAyKSxcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IF9FZGl0b3IkcGFyZW50MlswXTtcbiAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQyWzFdO1xuXG4gICAgICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgICAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX0VkaXRvciRub2RlID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pLFxuICAgICAgICAgICAgICBfRWRpdG9yJG5vZGUyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlLCAyKSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2RlID0gX0VkaXRvciRub2RlMlswXSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRQYXRoID0gX0VkaXRvciRub2RlMlsxXTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQzID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCksXG4gICAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQzLCAxKSxcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQ0WzBdO1xuXG4gICAgICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSksIHtcbiAgICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpKTtcblxuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVCYWNrd2FyZDogZnVuY3Rpb24gZGVsZXRlQmFja3dhcmQodW5pdCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZUZvcndhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUZvcndhcmQodW5pdCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgIHVuaXQ6IHVuaXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGcmFnbWVudDogZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICByZXZlcnNlOiBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24gZ2V0RnJhZ21lbnQoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGluc2VydEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRCcmVhaygpIHtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluc2VydFNvZnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrKCkge1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgfSxcbiAgICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0KHRleHQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgIG1hcmtzID0gZWRpdG9yLm1hcmtzO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtYXJrcykge1xuICAgICAgICAgIHZhciBub2RlID0gX29iamVjdFNwcmVhZCQ5KHtcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9LCBtYXJrcyk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybWFsaXplTm9kZTogZnVuY3Rpb24gbm9ybWFsaXplTm9kZShlbnRyeSkge1xuICAgICAgdmFyIF9lbnRyeSA9IF9zbGljZWRUb0FycmF5KGVudHJ5LCAyKSxcbiAgICAgICAgICBub2RlID0gX2VudHJ5WzBdLFxuICAgICAgICAgIHBhdGggPSBfZW50cnlbMV07IC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEVuc3VyZSB0aGF0IGJsb2NrIGFuZCBpbmxpbmUgbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgdGV4dCBjaGlsZC5cblxuXG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZCwge1xuICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgaGF2ZSBibG9jayBvciBpbmxpbmUgY2hpbGRyZW4uXG5cblxuICAgICAgdmFyIHNob3VsZEhhdmVJbmxpbmVzID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pIHx8IGVkaXRvci5pc0lubGluZShub2RlLmNoaWxkcmVuWzBdKSk7IC8vIFNpbmNlIHdlJ2xsIGJlIGFwcGx5aW5nIG9wZXJhdGlvbnMgd2hpbGUgaXRlcmF0aW5nLCBrZWVwIHRyYWNrIG9mIGFuXG4gICAgICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cblxuICAgICAgdmFyIG4gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQoY3VycmVudE5vZGUpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIF9jaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBwcmV2ID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbiAtIDFdO1xuICAgICAgICB2YXIgaXNMYXN0ID0gaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgaXNJbmxpbmVPclRleHQgPSBUZXh0LmlzVGV4dChfY2hpbGQpIHx8IEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkgJiYgZWRpdG9yLmlzSW5saW5lKF9jaGlsZCk7IC8vIE9ubHkgYWxsb3cgYmxvY2sgbm9kZXMgaW4gdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBhbmQgcGFyZW50IGJsb2Nrc1xuICAgICAgICAvLyB0aGF0IG9ubHkgY29udGFpbiBibG9jayBub2Rlcy4gU2ltaWxhcmx5LCBvbmx5IGFsbG93IGlubGluZSBub2RlcyBpblxuICAgICAgICAvLyBvdGhlciBpbmxpbmUgbm9kZXMsIG9yIHBhcmVudCBibG9ja3MgdGhhdCBvbmx5IGNvbnRhaW4gaW5saW5lcyBhbmRcbiAgICAgICAgLy8gdGV4dC5cblxuICAgICAgICBpZiAoaXNJbmxpbmVPclRleHQgIT09IHNob3VsZEhhdmVJbmxpbmVzKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBpbmxpbmUgbm9kZXMgYXJlIHN1cnJvdW5kZWQgYnkgdGV4dCBub2Rlcy5cbiAgICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKF9jaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIF9uZXdDaGlsZCwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuICsgMSksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyB0aGF0IGFyZSBlbXB0eSBvciBtYXRjaC5cbiAgICAgICAgICBpZiAocHJldiAhPSBudWxsICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICBpZiAoVGV4dC5lcXVhbHMoX2NoaWxkLCBwcmV2LCB7XG4gICAgICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXYudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiAtIDEpLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9jaGlsZC50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlTWFyazogZnVuY3Rpb24gcmVtb3ZlTWFyayhrZXkpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG5vZGUsIHBhdGgpIHtcbiAgICAgICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfRWRpdG9yJHBhcmVudDUgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50NSwgMiksXG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBfRWRpdG9yJHBhcmVudDZbMF07XG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NlsxXTtcblxuICAgICAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZTMgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiksXG4gICAgICAgICAgICAgIF9FZGl0b3Ikbm9kZTQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUzLCAyKSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2RlID0gX0VkaXRvciRub2RlNFswXSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRQYXRoID0gX0VkaXRvciRub2RlNFsxXTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQ3ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCksXG4gICAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ4ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQ3LCAxKSxcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQ4WzBdO1xuXG4gICAgICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG5cbiAgICAgICAgICBkZWxldGUgbWFya3Nba2V5XTtcbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgXCJkaXJ0eVwiIHBhdGhzIGdlbmVyYXRlZCBmcm9tIGFuIG9wZXJhdGlvbi5cclxuICAgICAqL1xuICAgIGdldERpcnR5UGF0aHM6IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMob3ApIHtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gb3AucGF0aDtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLmxldmVscyhwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gb3Aubm9kZSxcbiAgICAgICAgICAgICAgICBfcGF0aDIgPSBvcC5wYXRoO1xuICAgICAgICAgICAgdmFyIGxldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoMik7XG4gICAgICAgICAgICB2YXIgZGVzY2VuZGFudHMgPSBUZXh0LmlzVGV4dChub2RlKSA/IFtdIDogQXJyYXkuZnJvbShOb2RlLm5vZGVzKG5vZGUpLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgICAgICAgcCA9IF9yZWY0WzFdO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfcGF0aDIuY29uY2F0KHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsZXZlbHMpLCBfdG9Db25zdW1hYmxlQXJyYXkoZGVzY2VuZGFudHMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoMyA9IG9wLnBhdGg7XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGgzKTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1BhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMyk7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbmNlc3RvcnMpLCBbcHJldmlvdXNQYXRoXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoNCA9IG9wLnBhdGgsXG4gICAgICAgICAgICAgICAgbmV3UGF0aCA9IG9wLm5ld1BhdGg7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDQsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIG5ld0FuY2VzdG9ycyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoUGF0aC5hbmNlc3RvcnMoX3BhdGg0KSksXG4gICAgICAgICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IF9zdGVwNi52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IFBhdGgudHJhbnNmb3JtKGFuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgICAgICAgb2xkQW5jZXN0b3JzLnB1c2gocCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpLFxuICAgICAgICAgICAgICAgIF9zdGVwNztcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2FuY2VzdG9yID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG5cbiAgICAgICAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3QW5jZXN0b3JzW25ld0FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRQYXRoID0gbmV3UGFyZW50LmNvbmNhdChuZXdJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KG9sZEFuY2VzdG9ycywgbmV3QW5jZXN0b3JzLCBbcmVzdWx0UGF0aF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoNSA9IG9wLnBhdGg7XG5cbiAgICAgICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg1KTtcblxuICAgICAgICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShfYW5jZXN0b3JzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoNiA9IG9wLnBhdGg7XG5cbiAgICAgICAgICAgIHZhciBfbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGg2KTtcblxuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KF9wYXRoNik7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfbGV2ZWxzKSwgW25leHRQYXRoXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZE5vcm1hbGl6ZTogZnVuY3Rpb24gc2hvdWxkTm9ybWFsaXplKF9yZWY1KSB7XG4gICAgICB2YXIgaXRlcmF0aW9uID0gX3JlZjUuaXRlcmF0aW9uLFxuICAgICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoID0gX3JlZjUuaW5pdGlhbERpcnR5UGF0aHNMZW5ndGg7XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoICogNDI7IC8vIEhBQ0s6IGJldHRlciB3YXk/XG5cbiAgICAgIGlmIChpdGVyYXRpb24gPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXhJdGVyYXRpb25zLCBcIiBpdGVyYXRpb25zISBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGluY29ycmVjdCBub3JtYWxpemF0aW9uIGxvZ2ljIHRoYXQgbGVhdmVzIGEgbm9kZSBpbiBhbiBpbnZhbGlkIHN0YXRlLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2U7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gdW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllcyk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDYoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIENoYXJhY3RlciAoZ3JhcGhlbWUgY2x1c3RlcikgYm91bmRhcmllcyBhcmUgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG9cbi8vIHRoZSBkZWZhdWx0IGdyYXBoZW1lIGNsdXN0ZXIgYm91bmRhcnkgc3BlY2lmaWNhdGlvbiwgZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnMgdmFyaWFudFsxXS5cbi8vXG4vLyBSZWZlcmVuY2VzOlxuLy9cbi8vIFsxXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0RlZmF1bHRfR3JhcGhlbWVfQ2x1c3Rlcl9UYWJsZVxuLy8gWzJdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dFxuLy8gWzNdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QuaHRtbFxuLy8gWzRdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QudHh0XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldENoYXJhY3RlckRpc3RhbmNlKHN0cikge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgaXNMVFIgPSAhaXNSVEw7XG4gIHZhciBjb2RlcG9pbnRzID0gaXNSVEwgPyBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSA6IHN0cjtcbiAgdmFyIGxlZnQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciByaWdodCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRXZhbHVhdGlvbiBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBkZWZlcnJlZC5cblxuICB2YXIgZ2IxMSA9IG51bGw7IC8vIElzIEdCMTEgYXBwbGljYWJsZT9cblxuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihjb2RlcG9pbnRzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfY2hhciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICB2YXIgY29kZSA9IF9jaGFyLmNvZGVQb2ludEF0KDApO1xuXG4gICAgICBpZiAoIWNvZGUpIGJyZWFrO1xuICAgICAgdmFyIHR5cGUgPSBnZXRDb2RlcG9pbnRUeXBlKF9jaGFyLCBjb2RlKTtcblxuICAgICAgdmFyIF9yZWYgPSBpc0xUUiA/IFtyaWdodCwgdHlwZV0gOiBbdHlwZSwgbGVmdF07XG5cbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICBsZWZ0ID0gX3JlZjJbMF07XG4gICAgICByaWdodCA9IF9yZWYyWzFdO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlpXSikgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5FeHRQaWN0KSkge1xuICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIGRpc3RhbmNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZ2IxMSkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuUkkpICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuUkkpKSB7XG4gICAgICAgIGlmIChnYjEyT3IxMyAhPT0gbnVsbCkge1xuICAgICAgICAgIGdiMTJPcjEzID0gIWdiMTJPcjEzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgICAgZ2IxMk9yMTMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnYjEyT3IxMyA9IGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdiMTJPcjEzKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGxlZnQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiByaWdodCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2UgKz0gX2NoYXIubGVuZ3RoO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlIHx8IDE7XG59O1xudmFyIFNQQUNFID0gL1xccy87XG52YXIgUFVOQ1RVQVRJT04gPSAvW1xcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbnZhciBDSEFNRUxFT04gPSAvWydcXHUyMDE4XFx1MjAxOV0vO1xuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cblxudmFyIGdldFdvcmREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFdvcmREaXN0YW5jZSh0ZXh0KSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBkaXN0ID0gMDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgaXNSVEwpO1xuXG4gICAgdmFyIF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpLFxuICAgICAgICBfc3BsaXRCeUNoYXJhY3RlckRpc3QyID0gX3NsaWNlZFRvQXJyYXkoX3NwbGl0QnlDaGFyYWN0ZXJEaXN0LCAyKSxcbiAgICAgICAgX2NoYXIyID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MlswXSxcbiAgICAgICAgcmVtYWluaW5nID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MlsxXTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoX2NoYXIyLCByZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRleHQgPSByZW1haW5pbmc7XG4gIH1cblxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcclxuICogU3BsaXQgYSBzdHJpbmcgaW4gdHdvIHBhcnRzIGF0IGEgZ2l2ZW4gZGlzdGFuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHdoZW5cclxuICogYGlzUlRMYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gKi9cblxudmFyIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShzdHIsIGRpc3QsIGlzUlRMKSB7XG4gIGlmIChpc1JUTCkge1xuICAgIHZhciBhdCA9IHN0ci5sZW5ndGggLSBkaXN0O1xuICAgIHJldHVybiBbc3RyLnNsaWNlKGF0LCBzdHIubGVuZ3RoKSwgc3RyLnNsaWNlKDAsIGF0KV07XG4gIH1cblxuICByZXR1cm4gW3N0ci5zbGljZSgwLCBkaXN0KSwgc3RyLnNsaWNlKGRpc3QpXTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcclxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxyXG4gKi9cblxudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihfY2hhcjMsIHJlbWFpbmluZykge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIGlmIChTUEFDRS50ZXN0KF9jaGFyMykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuXG5cbiAgaWYgKENIQU1FTEVPTi50ZXN0KF9jaGFyMykpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcblxuICAgIHZhciBfc3BsaXRCeUNoYXJhY3RlckRpc3QzID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgY2hhckRpc3QsIGlzUlRMKSxcbiAgICAgICAgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0NCA9IF9zbGljZWRUb0FycmF5KF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDMsIDIpLFxuICAgICAgICBuZXh0Q2hhciA9IF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDRbMF0sXG4gICAgICAgIG5leHRSZW1haW5pbmcgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3Q0WzFdO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihuZXh0Q2hhciwgbmV4dFJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoUFVOQ1RVQVRJT04udGVzdChfY2hhcjMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIEl0ZXJhdGUgb24gY29kZXBvaW50cyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAqL1xuXG5cbnZhciBjb2RlcG9pbnRzSXRlcmF0b3JSVEwgPSBmdW5jdGlvbiogY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikge1xuICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcjEgPSBzdHIuY2hhckF0KGVuZCAtIGkpO1xuXG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcblxuICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyMi5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB5aWVsZCBjaGFyMiArIGNoYXIxO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpZWxkIGNoYXIxO1xuICB9XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG52YXIgaXNIaWdoU3Vycm9nYXRlID0gZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGQ4MDAgJiYgY2hhckNvZGUgPD0gMHhkYmZmO1xufTtcbi8qKlxyXG4gKiBJcyBgY2hhckNvZGVgIGEgbG93IHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG5cbnZhciBpc0xvd1N1cnJvZ2F0ZSA9IGZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGRjMDAgJiYgY2hhckNvZGUgPD0gMHhkZmZmO1xufTtcblxudmFyIENvZGVwb2ludFR5cGU7XG5cbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcblxudmFyIHJlRXh0ZW5kID0gL14oPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSQvO1xudmFyIHJlUHJlcGVuZCA9IC9eKD86W1xcdTA2MDAtXFx1MDYwNVxcdTA2RERcXHUwNzBGXFx1MDg5MFxcdTA4OTFcXHUwOEUyXFx1MEQ0RV18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRFxcdUREQzJcXHVEREMzXXxcXHVEODA2W1xcdUREM0ZcXHVERDQxXFx1REUzQVxcdURFODQtXFx1REU4OV18XFx1RDgwN1xcdURENDYpJC87XG52YXIgcmVTcGFjaW5nTWFyayA9IC9eKD86W1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkZcXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzBcXHUwQ0MxXFx1MENDM1xcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MEQwMlxcdTBEMDNcXHUwRDNGXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBEODJcXHUwRDgzXFx1MEREMFxcdTBERDFcXHUwREQ4LVxcdTBEREVcXHUwREYyXFx1MERGM1xcdTBFMzNcXHUwRUIzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAzMVxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDg0XFx1MTcxNVxcdTE3MzRcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGN1xcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkUtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUNdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ0NVxcdURENDZcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERENFXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQzM1LVxcdURDMzdcXHVEQzQwXFx1REM0MVxcdURDNDVcXHVEQ0IxXFx1RENCMlxcdURDQjlcXHVEQ0JCXFx1RENCQ1xcdURDQkVcXHVEQ0MxXFx1RERCMFxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjZdfFxcdUQ4MDZbXFx1REMyQy1cXHVEQzJFXFx1REMzOFxcdUREMzEtXFx1REQzNVxcdUREMzdcXHVERDM4XFx1REQzRFxcdURENDBcXHVERDQyXFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERGXFx1RERFNFxcdURFMzlcXHVERTU3XFx1REU1OFxcdURFOTddfFxcdUQ4MDdbXFx1REMyRlxcdURDM0VcXHVEQ0E5XFx1RENCMVxcdURDQjRcXHVERDhBLVxcdUREOEVcXHVERDkzXFx1REQ5NFxcdUREOTZcXHVERUY1XFx1REVGNl18XFx1RDgxQltcXHVERjUxLVxcdURGODdcXHVERkYwXFx1REZGMV18XFx1RDgzNFtcXHVERDY2XFx1REQ2RF0pJC87XG52YXIgcmVMID0gL15bXFx1MTEwMC1cXHUxMTVGXFx1QTk2MC1cXHVBOTdDXSQvO1xudmFyIHJlViA9IC9eW1xcdTExNjAtXFx1MTFBN1xcdUQ3QjAtXFx1RDdDNl0kLztcbnZhciByZVQgPSAvXltcXHUxMUE4LVxcdTExRkZcXHVEN0NCLVxcdUQ3RkJdJC87XG52YXIgcmVMViA9IC9eW1xcdUFDMDBcXHVBQzFDXFx1QUMzOFxcdUFDNTRcXHVBQzcwXFx1QUM4Q1xcdUFDQThcXHVBQ0M0XFx1QUNFMFxcdUFDRkNcXHVBRDE4XFx1QUQzNFxcdUFENTBcXHVBRDZDXFx1QUQ4OFxcdUFEQTRcXHVBREMwXFx1QUREQ1xcdUFERjhcXHVBRTE0XFx1QUUzMFxcdUFFNENcXHVBRTY4XFx1QUU4NFxcdUFFQTBcXHVBRUJDXFx1QUVEOFxcdUFFRjRcXHVBRjEwXFx1QUYyQ1xcdUFGNDhcXHVBRjY0XFx1QUY4MFxcdUFGOUNcXHVBRkI4XFx1QUZENFxcdUFGRjBcXHVCMDBDXFx1QjAyOFxcdUIwNDRcXHVCMDYwXFx1QjA3Q1xcdUIwOThcXHVCMEI0XFx1QjBEMFxcdUIwRUNcXHVCMTA4XFx1QjEyNFxcdUIxNDBcXHVCMTVDXFx1QjE3OFxcdUIxOTRcXHVCMUIwXFx1QjFDQ1xcdUIxRThcXHVCMjA0XFx1QjIyMFxcdUIyM0NcXHVCMjU4XFx1QjI3NFxcdUIyOTBcXHVCMkFDXFx1QjJDOFxcdUIyRTRcXHVCMzAwXFx1QjMxQ1xcdUIzMzhcXHVCMzU0XFx1QjM3MFxcdUIzOENcXHVCM0E4XFx1QjNDNFxcdUIzRTBcXHVCM0ZDXFx1QjQxOFxcdUI0MzRcXHVCNDUwXFx1QjQ2Q1xcdUI0ODhcXHVCNEE0XFx1QjRDMFxcdUI0RENcXHVCNEY4XFx1QjUxNFxcdUI1MzBcXHVCNTRDXFx1QjU2OFxcdUI1ODRcXHVCNUEwXFx1QjVCQ1xcdUI1RDhcXHVCNUY0XFx1QjYxMFxcdUI2MkNcXHVCNjQ4XFx1QjY2NFxcdUI2ODBcXHVCNjlDXFx1QjZCOFxcdUI2RDRcXHVCNkYwXFx1QjcwQ1xcdUI3MjhcXHVCNzQ0XFx1Qjc2MFxcdUI3N0NcXHVCNzk4XFx1QjdCNFxcdUI3RDBcXHVCN0VDXFx1QjgwOFxcdUI4MjRcXHVCODQwXFx1Qjg1Q1xcdUI4NzhcXHVCODk0XFx1QjhCMFxcdUI4Q0NcXHVCOEU4XFx1QjkwNFxcdUI5MjBcXHVCOTNDXFx1Qjk1OFxcdUI5NzRcXHVCOTkwXFx1QjlBQ1xcdUI5QzhcXHVCOUU0XFx1QkEwMFxcdUJBMUNcXHVCQTM4XFx1QkE1NFxcdUJBNzBcXHVCQThDXFx1QkFBOFxcdUJBQzRcXHVCQUUwXFx1QkFGQ1xcdUJCMThcXHVCQjM0XFx1QkI1MFxcdUJCNkNcXHVCQjg4XFx1QkJBNFxcdUJCQzBcXHVCQkRDXFx1QkJGOFxcdUJDMTRcXHVCQzMwXFx1QkM0Q1xcdUJDNjhcXHVCQzg0XFx1QkNBMFxcdUJDQkNcXHVCQ0Q4XFx1QkNGNFxcdUJEMTBcXHVCRDJDXFx1QkQ0OFxcdUJENjRcXHVCRDgwXFx1QkQ5Q1xcdUJEQjhcXHVCREQ0XFx1QkRGMFxcdUJFMENcXHVCRTI4XFx1QkU0NFxcdUJFNjBcXHVCRTdDXFx1QkU5OFxcdUJFQjRcXHVCRUQwXFx1QkVFQ1xcdUJGMDhcXHVCRjI0XFx1QkY0MFxcdUJGNUNcXHVCRjc4XFx1QkY5NFxcdUJGQjBcXHVCRkNDXFx1QkZFOFxcdUMwMDRcXHVDMDIwXFx1QzAzQ1xcdUMwNThcXHVDMDc0XFx1QzA5MFxcdUMwQUNcXHVDMEM4XFx1QzBFNFxcdUMxMDBcXHVDMTFDXFx1QzEzOFxcdUMxNTRcXHVDMTcwXFx1QzE4Q1xcdUMxQThcXHVDMUM0XFx1QzFFMFxcdUMxRkNcXHVDMjE4XFx1QzIzNFxcdUMyNTBcXHVDMjZDXFx1QzI4OFxcdUMyQTRcXHVDMkMwXFx1QzJEQ1xcdUMyRjhcXHVDMzE0XFx1QzMzMFxcdUMzNENcXHVDMzY4XFx1QzM4NFxcdUMzQTBcXHVDM0JDXFx1QzNEOFxcdUMzRjRcXHVDNDEwXFx1QzQyQ1xcdUM0NDhcXHVDNDY0XFx1QzQ4MFxcdUM0OUNcXHVDNEI4XFx1QzRENFxcdUM0RjBcXHVDNTBDXFx1QzUyOFxcdUM1NDRcXHVDNTYwXFx1QzU3Q1xcdUM1OThcXHVDNUI0XFx1QzVEMFxcdUM1RUNcXHVDNjA4XFx1QzYyNFxcdUM2NDBcXHVDNjVDXFx1QzY3OFxcdUM2OTRcXHVDNkIwXFx1QzZDQ1xcdUM2RThcXHVDNzA0XFx1QzcyMFxcdUM3M0NcXHVDNzU4XFx1Qzc3NFxcdUM3OTBcXHVDN0FDXFx1QzdDOFxcdUM3RTRcXHVDODAwXFx1QzgxQ1xcdUM4MzhcXHVDODU0XFx1Qzg3MFxcdUM4OENcXHVDOEE4XFx1QzhDNFxcdUM4RTBcXHVDOEZDXFx1QzkxOFxcdUM5MzRcXHVDOTUwXFx1Qzk2Q1xcdUM5ODhcXHVDOUE0XFx1QzlDMFxcdUM5RENcXHVDOUY4XFx1Q0ExNFxcdUNBMzBcXHVDQTRDXFx1Q0E2OFxcdUNBODRcXHVDQUEwXFx1Q0FCQ1xcdUNBRDhcXHVDQUY0XFx1Q0IxMFxcdUNCMkNcXHVDQjQ4XFx1Q0I2NFxcdUNCODBcXHVDQjlDXFx1Q0JCOFxcdUNCRDRcXHVDQkYwXFx1Q0MwQ1xcdUNDMjhcXHVDQzQ0XFx1Q0M2MFxcdUNDN0NcXHVDQzk4XFx1Q0NCNFxcdUNDRDBcXHVDQ0VDXFx1Q0QwOFxcdUNEMjRcXHVDRDQwXFx1Q0Q1Q1xcdUNENzhcXHVDRDk0XFx1Q0RCMFxcdUNEQ0NcXHVDREU4XFx1Q0UwNFxcdUNFMjBcXHVDRTNDXFx1Q0U1OFxcdUNFNzRcXHVDRTkwXFx1Q0VBQ1xcdUNFQzhcXHVDRUU0XFx1Q0YwMFxcdUNGMUNcXHVDRjM4XFx1Q0Y1NFxcdUNGNzBcXHVDRjhDXFx1Q0ZBOFxcdUNGQzRcXHVDRkUwXFx1Q0ZGQ1xcdUQwMThcXHVEMDM0XFx1RDA1MFxcdUQwNkNcXHVEMDg4XFx1RDBBNFxcdUQwQzBcXHVEMERDXFx1RDBGOFxcdUQxMTRcXHVEMTMwXFx1RDE0Q1xcdUQxNjhcXHVEMTg0XFx1RDFBMFxcdUQxQkNcXHVEMUQ4XFx1RDFGNFxcdUQyMTBcXHVEMjJDXFx1RDI0OFxcdUQyNjRcXHVEMjgwXFx1RDI5Q1xcdUQyQjhcXHVEMkQ0XFx1RDJGMFxcdUQzMENcXHVEMzI4XFx1RDM0NFxcdUQzNjBcXHVEMzdDXFx1RDM5OFxcdUQzQjRcXHVEM0QwXFx1RDNFQ1xcdUQ0MDhcXHVENDI0XFx1RDQ0MFxcdUQ0NUNcXHVENDc4XFx1RDQ5NFxcdUQ0QjBcXHVENENDXFx1RDRFOFxcdUQ1MDRcXHVENTIwXFx1RDUzQ1xcdUQ1NThcXHVENTc0XFx1RDU5MFxcdUQ1QUNcXHVENUM4XFx1RDVFNFxcdUQ2MDBcXHVENjFDXFx1RDYzOFxcdUQ2NTRcXHVENjcwXFx1RDY4Q1xcdUQ2QThcXHVENkM0XFx1RDZFMFxcdUQ2RkNcXHVENzE4XFx1RDczNFxcdUQ3NTBcXHVENzZDXFx1RDc4OF0kLztcbnZhciByZUxWVCA9IC9eW1xcdUFDMDEtXFx1QUMxQlxcdUFDMUQtXFx1QUMzN1xcdUFDMzktXFx1QUM1M1xcdUFDNTUtXFx1QUM2RlxcdUFDNzEtXFx1QUM4QlxcdUFDOEQtXFx1QUNBN1xcdUFDQTktXFx1QUNDM1xcdUFDQzUtXFx1QUNERlxcdUFDRTEtXFx1QUNGQlxcdUFDRkQtXFx1QUQxN1xcdUFEMTktXFx1QUQzM1xcdUFEMzUtXFx1QUQ0RlxcdUFENTEtXFx1QUQ2QlxcdUFENkQtXFx1QUQ4N1xcdUFEODktXFx1QURBM1xcdUFEQTUtXFx1QURCRlxcdUFEQzEtXFx1QUREQlxcdUFEREQtXFx1QURGN1xcdUFERjktXFx1QUUxM1xcdUFFMTUtXFx1QUUyRlxcdUFFMzEtXFx1QUU0QlxcdUFFNEQtXFx1QUU2N1xcdUFFNjktXFx1QUU4M1xcdUFFODUtXFx1QUU5RlxcdUFFQTEtXFx1QUVCQlxcdUFFQkQtXFx1QUVEN1xcdUFFRDktXFx1QUVGM1xcdUFFRjUtXFx1QUYwRlxcdUFGMTEtXFx1QUYyQlxcdUFGMkQtXFx1QUY0N1xcdUFGNDktXFx1QUY2M1xcdUFGNjUtXFx1QUY3RlxcdUFGODEtXFx1QUY5QlxcdUFGOUQtXFx1QUZCN1xcdUFGQjktXFx1QUZEM1xcdUFGRDUtXFx1QUZFRlxcdUFGRjEtXFx1QjAwQlxcdUIwMEQtXFx1QjAyN1xcdUIwMjktXFx1QjA0M1xcdUIwNDUtXFx1QjA1RlxcdUIwNjEtXFx1QjA3QlxcdUIwN0QtXFx1QjA5N1xcdUIwOTktXFx1QjBCM1xcdUIwQjUtXFx1QjBDRlxcdUIwRDEtXFx1QjBFQlxcdUIwRUQtXFx1QjEwN1xcdUIxMDktXFx1QjEyM1xcdUIxMjUtXFx1QjEzRlxcdUIxNDEtXFx1QjE1QlxcdUIxNUQtXFx1QjE3N1xcdUIxNzktXFx1QjE5M1xcdUIxOTUtXFx1QjFBRlxcdUIxQjEtXFx1QjFDQlxcdUIxQ0QtXFx1QjFFN1xcdUIxRTktXFx1QjIwM1xcdUIyMDUtXFx1QjIxRlxcdUIyMjEtXFx1QjIzQlxcdUIyM0QtXFx1QjI1N1xcdUIyNTktXFx1QjI3M1xcdUIyNzUtXFx1QjI4RlxcdUIyOTEtXFx1QjJBQlxcdUIyQUQtXFx1QjJDN1xcdUIyQzktXFx1QjJFM1xcdUIyRTUtXFx1QjJGRlxcdUIzMDEtXFx1QjMxQlxcdUIzMUQtXFx1QjMzN1xcdUIzMzktXFx1QjM1M1xcdUIzNTUtXFx1QjM2RlxcdUIzNzEtXFx1QjM4QlxcdUIzOEQtXFx1QjNBN1xcdUIzQTktXFx1QjNDM1xcdUIzQzUtXFx1QjNERlxcdUIzRTEtXFx1QjNGQlxcdUIzRkQtXFx1QjQxN1xcdUI0MTktXFx1QjQzM1xcdUI0MzUtXFx1QjQ0RlxcdUI0NTEtXFx1QjQ2QlxcdUI0NkQtXFx1QjQ4N1xcdUI0ODktXFx1QjRBM1xcdUI0QTUtXFx1QjRCRlxcdUI0QzEtXFx1QjREQlxcdUI0REQtXFx1QjRGN1xcdUI0RjktXFx1QjUxM1xcdUI1MTUtXFx1QjUyRlxcdUI1MzEtXFx1QjU0QlxcdUI1NEQtXFx1QjU2N1xcdUI1NjktXFx1QjU4M1xcdUI1ODUtXFx1QjU5RlxcdUI1QTEtXFx1QjVCQlxcdUI1QkQtXFx1QjVEN1xcdUI1RDktXFx1QjVGM1xcdUI1RjUtXFx1QjYwRlxcdUI2MTEtXFx1QjYyQlxcdUI2MkQtXFx1QjY0N1xcdUI2NDktXFx1QjY2M1xcdUI2NjUtXFx1QjY3RlxcdUI2ODEtXFx1QjY5QlxcdUI2OUQtXFx1QjZCN1xcdUI2QjktXFx1QjZEM1xcdUI2RDUtXFx1QjZFRlxcdUI2RjEtXFx1QjcwQlxcdUI3MEQtXFx1QjcyN1xcdUI3MjktXFx1Qjc0M1xcdUI3NDUtXFx1Qjc1RlxcdUI3NjEtXFx1Qjc3QlxcdUI3N0QtXFx1Qjc5N1xcdUI3OTktXFx1QjdCM1xcdUI3QjUtXFx1QjdDRlxcdUI3RDEtXFx1QjdFQlxcdUI3RUQtXFx1QjgwN1xcdUI4MDktXFx1QjgyM1xcdUI4MjUtXFx1QjgzRlxcdUI4NDEtXFx1Qjg1QlxcdUI4NUQtXFx1Qjg3N1xcdUI4NzktXFx1Qjg5M1xcdUI4OTUtXFx1QjhBRlxcdUI4QjEtXFx1QjhDQlxcdUI4Q0QtXFx1QjhFN1xcdUI4RTktXFx1QjkwM1xcdUI5MDUtXFx1QjkxRlxcdUI5MjEtXFx1QjkzQlxcdUI5M0QtXFx1Qjk1N1xcdUI5NTktXFx1Qjk3M1xcdUI5NzUtXFx1Qjk4RlxcdUI5OTEtXFx1QjlBQlxcdUI5QUQtXFx1QjlDN1xcdUI5QzktXFx1QjlFM1xcdUI5RTUtXFx1QjlGRlxcdUJBMDEtXFx1QkExQlxcdUJBMUQtXFx1QkEzN1xcdUJBMzktXFx1QkE1M1xcdUJBNTUtXFx1QkE2RlxcdUJBNzEtXFx1QkE4QlxcdUJBOEQtXFx1QkFBN1xcdUJBQTktXFx1QkFDM1xcdUJBQzUtXFx1QkFERlxcdUJBRTEtXFx1QkFGQlxcdUJBRkQtXFx1QkIxN1xcdUJCMTktXFx1QkIzM1xcdUJCMzUtXFx1QkI0RlxcdUJCNTEtXFx1QkI2QlxcdUJCNkQtXFx1QkI4N1xcdUJCODktXFx1QkJBM1xcdUJCQTUtXFx1QkJCRlxcdUJCQzEtXFx1QkJEQlxcdUJCREQtXFx1QkJGN1xcdUJCRjktXFx1QkMxM1xcdUJDMTUtXFx1QkMyRlxcdUJDMzEtXFx1QkM0QlxcdUJDNEQtXFx1QkM2N1xcdUJDNjktXFx1QkM4M1xcdUJDODUtXFx1QkM5RlxcdUJDQTEtXFx1QkNCQlxcdUJDQkQtXFx1QkNEN1xcdUJDRDktXFx1QkNGM1xcdUJDRjUtXFx1QkQwRlxcdUJEMTEtXFx1QkQyQlxcdUJEMkQtXFx1QkQ0N1xcdUJENDktXFx1QkQ2M1xcdUJENjUtXFx1QkQ3RlxcdUJEODEtXFx1QkQ5QlxcdUJEOUQtXFx1QkRCN1xcdUJEQjktXFx1QkREM1xcdUJERDUtXFx1QkRFRlxcdUJERjEtXFx1QkUwQlxcdUJFMEQtXFx1QkUyN1xcdUJFMjktXFx1QkU0M1xcdUJFNDUtXFx1QkU1RlxcdUJFNjEtXFx1QkU3QlxcdUJFN0QtXFx1QkU5N1xcdUJFOTktXFx1QkVCM1xcdUJFQjUtXFx1QkVDRlxcdUJFRDEtXFx1QkVFQlxcdUJFRUQtXFx1QkYwN1xcdUJGMDktXFx1QkYyM1xcdUJGMjUtXFx1QkYzRlxcdUJGNDEtXFx1QkY1QlxcdUJGNUQtXFx1QkY3N1xcdUJGNzktXFx1QkY5M1xcdUJGOTUtXFx1QkZBRlxcdUJGQjEtXFx1QkZDQlxcdUJGQ0QtXFx1QkZFN1xcdUJGRTktXFx1QzAwM1xcdUMwMDUtXFx1QzAxRlxcdUMwMjEtXFx1QzAzQlxcdUMwM0QtXFx1QzA1N1xcdUMwNTktXFx1QzA3M1xcdUMwNzUtXFx1QzA4RlxcdUMwOTEtXFx1QzBBQlxcdUMwQUQtXFx1QzBDN1xcdUMwQzktXFx1QzBFM1xcdUMwRTUtXFx1QzBGRlxcdUMxMDEtXFx1QzExQlxcdUMxMUQtXFx1QzEzN1xcdUMxMzktXFx1QzE1M1xcdUMxNTUtXFx1QzE2RlxcdUMxNzEtXFx1QzE4QlxcdUMxOEQtXFx1QzFBN1xcdUMxQTktXFx1QzFDM1xcdUMxQzUtXFx1QzFERlxcdUMxRTEtXFx1QzFGQlxcdUMxRkQtXFx1QzIxN1xcdUMyMTktXFx1QzIzM1xcdUMyMzUtXFx1QzI0RlxcdUMyNTEtXFx1QzI2QlxcdUMyNkQtXFx1QzI4N1xcdUMyODktXFx1QzJBM1xcdUMyQTUtXFx1QzJCRlxcdUMyQzEtXFx1QzJEQlxcdUMyREQtXFx1QzJGN1xcdUMyRjktXFx1QzMxM1xcdUMzMTUtXFx1QzMyRlxcdUMzMzEtXFx1QzM0QlxcdUMzNEQtXFx1QzM2N1xcdUMzNjktXFx1QzM4M1xcdUMzODUtXFx1QzM5RlxcdUMzQTEtXFx1QzNCQlxcdUMzQkQtXFx1QzNEN1xcdUMzRDktXFx1QzNGM1xcdUMzRjUtXFx1QzQwRlxcdUM0MTEtXFx1QzQyQlxcdUM0MkQtXFx1QzQ0N1xcdUM0NDktXFx1QzQ2M1xcdUM0NjUtXFx1QzQ3RlxcdUM0ODEtXFx1QzQ5QlxcdUM0OUQtXFx1QzRCN1xcdUM0QjktXFx1QzREM1xcdUM0RDUtXFx1QzRFRlxcdUM0RjEtXFx1QzUwQlxcdUM1MEQtXFx1QzUyN1xcdUM1MjktXFx1QzU0M1xcdUM1NDUtXFx1QzU1RlxcdUM1NjEtXFx1QzU3QlxcdUM1N0QtXFx1QzU5N1xcdUM1OTktXFx1QzVCM1xcdUM1QjUtXFx1QzVDRlxcdUM1RDEtXFx1QzVFQlxcdUM1RUQtXFx1QzYwN1xcdUM2MDktXFx1QzYyM1xcdUM2MjUtXFx1QzYzRlxcdUM2NDEtXFx1QzY1QlxcdUM2NUQtXFx1QzY3N1xcdUM2NzktXFx1QzY5M1xcdUM2OTUtXFx1QzZBRlxcdUM2QjEtXFx1QzZDQlxcdUM2Q0QtXFx1QzZFN1xcdUM2RTktXFx1QzcwM1xcdUM3MDUtXFx1QzcxRlxcdUM3MjEtXFx1QzczQlxcdUM3M0QtXFx1Qzc1N1xcdUM3NTktXFx1Qzc3M1xcdUM3NzUtXFx1Qzc4RlxcdUM3OTEtXFx1QzdBQlxcdUM3QUQtXFx1QzdDN1xcdUM3QzktXFx1QzdFM1xcdUM3RTUtXFx1QzdGRlxcdUM4MDEtXFx1QzgxQlxcdUM4MUQtXFx1QzgzN1xcdUM4MzktXFx1Qzg1M1xcdUM4NTUtXFx1Qzg2RlxcdUM4NzEtXFx1Qzg4QlxcdUM4OEQtXFx1QzhBN1xcdUM4QTktXFx1QzhDM1xcdUM4QzUtXFx1QzhERlxcdUM4RTEtXFx1QzhGQlxcdUM4RkQtXFx1QzkxN1xcdUM5MTktXFx1QzkzM1xcdUM5MzUtXFx1Qzk0RlxcdUM5NTEtXFx1Qzk2QlxcdUM5NkQtXFx1Qzk4N1xcdUM5ODktXFx1QzlBM1xcdUM5QTUtXFx1QzlCRlxcdUM5QzEtXFx1QzlEQlxcdUM5REQtXFx1QzlGN1xcdUM5RjktXFx1Q0ExM1xcdUNBMTUtXFx1Q0EyRlxcdUNBMzEtXFx1Q0E0QlxcdUNBNEQtXFx1Q0E2N1xcdUNBNjktXFx1Q0E4M1xcdUNBODUtXFx1Q0E5RlxcdUNBQTEtXFx1Q0FCQlxcdUNBQkQtXFx1Q0FEN1xcdUNBRDktXFx1Q0FGM1xcdUNBRjUtXFx1Q0IwRlxcdUNCMTEtXFx1Q0IyQlxcdUNCMkQtXFx1Q0I0N1xcdUNCNDktXFx1Q0I2M1xcdUNCNjUtXFx1Q0I3RlxcdUNCODEtXFx1Q0I5QlxcdUNCOUQtXFx1Q0JCN1xcdUNCQjktXFx1Q0JEM1xcdUNCRDUtXFx1Q0JFRlxcdUNCRjEtXFx1Q0MwQlxcdUNDMEQtXFx1Q0MyN1xcdUNDMjktXFx1Q0M0M1xcdUNDNDUtXFx1Q0M1RlxcdUNDNjEtXFx1Q0M3QlxcdUNDN0QtXFx1Q0M5N1xcdUNDOTktXFx1Q0NCM1xcdUNDQjUtXFx1Q0NDRlxcdUNDRDEtXFx1Q0NFQlxcdUNDRUQtXFx1Q0QwN1xcdUNEMDktXFx1Q0QyM1xcdUNEMjUtXFx1Q0QzRlxcdUNENDEtXFx1Q0Q1QlxcdUNENUQtXFx1Q0Q3N1xcdUNENzktXFx1Q0Q5M1xcdUNEOTUtXFx1Q0RBRlxcdUNEQjEtXFx1Q0RDQlxcdUNEQ0QtXFx1Q0RFN1xcdUNERTktXFx1Q0UwM1xcdUNFMDUtXFx1Q0UxRlxcdUNFMjEtXFx1Q0UzQlxcdUNFM0QtXFx1Q0U1N1xcdUNFNTktXFx1Q0U3M1xcdUNFNzUtXFx1Q0U4RlxcdUNFOTEtXFx1Q0VBQlxcdUNFQUQtXFx1Q0VDN1xcdUNFQzktXFx1Q0VFM1xcdUNFRTUtXFx1Q0VGRlxcdUNGMDEtXFx1Q0YxQlxcdUNGMUQtXFx1Q0YzN1xcdUNGMzktXFx1Q0Y1M1xcdUNGNTUtXFx1Q0Y2RlxcdUNGNzEtXFx1Q0Y4QlxcdUNGOEQtXFx1Q0ZBN1xcdUNGQTktXFx1Q0ZDM1xcdUNGQzUtXFx1Q0ZERlxcdUNGRTEtXFx1Q0ZGQlxcdUNGRkQtXFx1RDAxN1xcdUQwMTktXFx1RDAzM1xcdUQwMzUtXFx1RDA0RlxcdUQwNTEtXFx1RDA2QlxcdUQwNkQtXFx1RDA4N1xcdUQwODktXFx1RDBBM1xcdUQwQTUtXFx1RDBCRlxcdUQwQzEtXFx1RDBEQlxcdUQwREQtXFx1RDBGN1xcdUQwRjktXFx1RDExM1xcdUQxMTUtXFx1RDEyRlxcdUQxMzEtXFx1RDE0QlxcdUQxNEQtXFx1RDE2N1xcdUQxNjktXFx1RDE4M1xcdUQxODUtXFx1RDE5RlxcdUQxQTEtXFx1RDFCQlxcdUQxQkQtXFx1RDFEN1xcdUQxRDktXFx1RDFGM1xcdUQxRjUtXFx1RDIwRlxcdUQyMTEtXFx1RDIyQlxcdUQyMkQtXFx1RDI0N1xcdUQyNDktXFx1RDI2M1xcdUQyNjUtXFx1RDI3RlxcdUQyODEtXFx1RDI5QlxcdUQyOUQtXFx1RDJCN1xcdUQyQjktXFx1RDJEM1xcdUQyRDUtXFx1RDJFRlxcdUQyRjEtXFx1RDMwQlxcdUQzMEQtXFx1RDMyN1xcdUQzMjktXFx1RDM0M1xcdUQzNDUtXFx1RDM1RlxcdUQzNjEtXFx1RDM3QlxcdUQzN0QtXFx1RDM5N1xcdUQzOTktXFx1RDNCM1xcdUQzQjUtXFx1RDNDRlxcdUQzRDEtXFx1RDNFQlxcdUQzRUQtXFx1RDQwN1xcdUQ0MDktXFx1RDQyM1xcdUQ0MjUtXFx1RDQzRlxcdUQ0NDEtXFx1RDQ1QlxcdUQ0NUQtXFx1RDQ3N1xcdUQ0NzktXFx1RDQ5M1xcdUQ0OTUtXFx1RDRBRlxcdUQ0QjEtXFx1RDRDQlxcdUQ0Q0QtXFx1RDRFN1xcdUQ0RTktXFx1RDUwM1xcdUQ1MDUtXFx1RDUxRlxcdUQ1MjEtXFx1RDUzQlxcdUQ1M0QtXFx1RDU1N1xcdUQ1NTktXFx1RDU3M1xcdUQ1NzUtXFx1RDU4RlxcdUQ1OTEtXFx1RDVBQlxcdUQ1QUQtXFx1RDVDN1xcdUQ1QzktXFx1RDVFM1xcdUQ1RTUtXFx1RDVGRlxcdUQ2MDEtXFx1RDYxQlxcdUQ2MUQtXFx1RDYzN1xcdUQ2MzktXFx1RDY1M1xcdUQ2NTUtXFx1RDY2RlxcdUQ2NzEtXFx1RDY4QlxcdUQ2OEQtXFx1RDZBN1xcdUQ2QTktXFx1RDZDM1xcdUQ2QzUtXFx1RDZERlxcdUQ2RTEtXFx1RDZGQlxcdUQ2RkQtXFx1RDcxN1xcdUQ3MTktXFx1RDczM1xcdUQ3MzUtXFx1RDc0RlxcdUQ3NTEtXFx1RDc2QlxcdUQ3NkQtXFx1RDc4N1xcdUQ3ODktXFx1RDdBM10kLztcbnZhciByZUV4dFBpY3QgPSAvXig/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkkLztcblxudmFyIGdldENvZGVwb2ludFR5cGUgPSBmdW5jdGlvbiBnZXRDb2RlcG9pbnRUeXBlKF9jaGFyNCwgY29kZSkge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlRXh0ZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0ZW5kO1xuICB9XG5cbiAgaWYgKGNvZGUgPT09IDB4MjAwZCkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5aV0o7XG4gIH1cblxuICBpZiAoY29kZSA+PSAweDFmMWU2ICYmIGNvZGUgPD0gMHgxZjFmZikge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5SSTtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlUHJlcGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlByZXBlbmQ7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVNwYWNpbmdNYXJrKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuU3BhY2luZ01hcms7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUwpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVjtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlQ7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUxWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFY7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUxWVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWVDtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlRXh0UGljdCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dFBpY3Q7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn07XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoeCwgeSkge1xuICByZXR1cm4gKHggJiB5KSAhPT0gMDtcbn1cblxudmFyIE5vbkJvdW5kYXJ5UGFpcnMgPSBbLy8gR0I2XG5bQ29kZXBvaW50VHlwZS5MLCBDb2RlcG9pbnRUeXBlLkwgfCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5MVlRdLCAvLyBHQjdcbltDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5WLCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I5XG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuRXh0ZW5kIHwgQ29kZXBvaW50VHlwZS5aV0pdLCAvLyBHQjlhXG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuU3BhY2luZ01hcmtdLCAvLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sIC8vIEdCMTFcbltDb2RlcG9pbnRUeXBlLlpXSiwgQ29kZXBvaW50VHlwZS5FeHRQaWN0XSwgLy8gR0IxMiBhbmQgR0IxM1xuW0NvZGVwb2ludFR5cGUuUkksIENvZGVwb2ludFR5cGUuUkldXTtcblxuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHMobGVmdCwgclswXSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgclsxXSk7XG4gIH0pID09PSAtMTtcbn1cblxudmFyIGVuZGluZ0Vtb2ppWldKID0gLyg/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkoPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSpcXHUyMDBEJC87XG5cbnZhciBlbmRzV2l0aEVtb2ppWldKID0gZnVuY3Rpb24gZW5kc1dpdGhFbW9qaVpXSihzdHIpIHtcbiAgcmV0dXJuIHN0ci5zZWFyY2goZW5kaW5nRW1vamlaV0opICE9PSAtMTtcbn07XG5cbnZhciBlbmRpbmdSSXMgPSAvKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERkZdKSskL2c7XG5cbnZhciBlbmRzV2l0aE9kZE51bWJlck9mUklzID0gZnVuY3Rpb24gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIpIHtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKGVuZGluZ1JJcyk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEEgUkkgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdXJyb2dhdGUgcGFpci5cbiAgICB2YXIgbnVtUklzID0gbWF0Y2hbMF0ubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gbnVtUklzICUgMiA9PT0gMTtcbiAgfVxufTtcblxuLyoqXHJcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcclxuICovXG5cbnZhciBpc0VsZW1lbnQgPSBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiAhRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgRWxlbWVudCA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSAnQW5jZXN0b3InIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gaXNBbmNlc3Rvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGFycmF5IG9mIGBFbGVtZW50YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc0VsZW1lbnRMaXN0OiBmdW5jdGlvbiBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudCh2YWwpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgc2V0IG9mIHByb3BzIGlzIGEgcGFydGlhbCBvZiBFbGVtZW50LlxyXG4gICAqL1xuICBpc0VsZW1lbnRQcm9wczogZnVuY3Rpb24gaXNFbGVtZW50UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4gIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBFbGVtZW50YCBpbnRlcmZhY2UgYW5kIGhhcyBlbGVtZW50S2V5IHdpdGggc2VsZWN0ZWQgdmFsdWUuXHJcbiAgICogRGVmYXVsdCBpdCBjaGVjayB0byBgdHlwZWAga2V5IHZhbHVlXHJcbiAgICovXG4gIGlzRWxlbWVudFR5cGU6IGZ1bmN0aW9uIGlzRWxlbWVudFR5cGUodmFsdWUsIGVsZW1lbnRWYWwpIHtcbiAgICB2YXIgZWxlbWVudEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3R5cGUnO1xuICAgIHJldHVybiBpc0VsZW1lbnQodmFsdWUpICYmIHZhbHVlW2VsZW1lbnRLZXldID09PSBlbGVtZW50VmFsO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgY2hlY2tzIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXQgYW55XHJcbiAgICogY2hpbGRyZW4gYXJlIGVxdWl2YWxlbnQuXHJcbiAgICovXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIkMyA9IFtcInRleHRcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkOChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ1KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxudmFyIElTX0VESVRPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIEVkaXRvciA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBhbmNlc3RvciBhYm92ZSBhIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgYWJvdmU6IGZ1bmN0aW9uIGFib3ZlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzLFxuICAgICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG4gICAgdmFyIHJldmVyc2UgPSBtb2RlID09PSAnbG93ZXN0JztcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIHJldmVyc2U6IHJldmVyc2VcbiAgICB9KSksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG4gPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgIHAgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQobikpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IocCwgYXQuYW5jaG9yLnBhdGgpICYmIFBhdGguaXNBbmNlc3RvcihwLCBhdC5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhwYXRoLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFkZCBhIGN1c3RvbSBwcm9wZXJ0eSB0byB0aGUgbGVhZiB0ZXh0IG5vZGVzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCwgdGhlIG1hcmtzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXHJcbiAgICogYGVkaXRvci5tYXJrc2AgcHJvcGVydHkgaW5zdGVhZCwgYW5kIGFwcGxpZWQgd2hlbiB0ZXh0IGlzIGluc2VydGVkIG5leHQuXHJcbiAgICovXG4gIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmsoZWRpdG9yLCBrZXksIHZhbHVlKSB7XG4gICAgZWRpdG9yLmFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwb2ludCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgdmFyIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2UgPSBfb3B0aW9ucyRkaXN0YW5jZSA9PT0gdm9pZCAwID8gMSA6IF9vcHRpb25zJGRpc3RhbmNlO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pKSksXG4gICAgICAgIF9zdGVwMjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgIHRhcmdldCA9IHA7XG4gICAgICAgIH1cblxuICAgICAgICBkKys7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBvaW50IGJlZm9yZSBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgdmFyIF9vcHRpb25zJGRpc3RhbmNlMiA9IG9wdGlvbnMuZGlzdGFuY2UsXG4gICAgICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UyID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2UyO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIHJldmVyc2U6IHRydWVcbiAgICB9KSkpLFxuICAgICAgICBfc3RlcDM7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHAgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgZCsrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvciBiYWNrd2FyZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVsZXRlQmFja3dhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQgPT09IHZvaWQgMCA/ICdjaGFyYWN0ZXInIDogX29wdGlvbnMkdW5pdDtcbiAgICBlZGl0b3IuZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvciBmb3J3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdW5pdDIgPSBvcHRpb25zLnVuaXQsXG4gICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0MiA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0MjtcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudDogZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgZGlyZWN0aW9uID0gX29wdGlvbnMkZGlyZWN0aW9uID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRkaXJlY3Rpb247XG4gICAgZWRpdG9yLmRlbGV0ZUZyYWdtZW50KGRpcmVjdGlvbik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlZGdlczogZnVuY3Rpb24gZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQ6IGZ1bmN0aW9uIGVuZChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnZW5kJ1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZmlyc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGZyYWdtZW50ID0gTm9kZS5mcmFnbWVudChlZGl0b3IsIHJhbmdlKTtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyBibG9jayBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzQmxvY2tzOiBmdW5jdGlvbiBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyBpbmxpbmUgYW5kIHRleHQgY2hpbGRyZW4uXHJcbiAgICovXG4gIGhhc0lubGluZXM6IGZ1bmN0aW9uIGhhc0lubGluZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgdGV4dCBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzVGV4dHM6IGZ1bmN0aW9uIGhhc1RleHRzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gVGV4dC5pc1RleHQobik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgYmxvY2sgYnJlYWsgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0QnJlYWs6IGZ1bmN0aW9uIGluc2VydEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRCcmVhaygpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHNvZnQgYnJlYWsgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0U29mdEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmluc2VydFNvZnRCcmVhaygpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBub2RlIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IHRleHQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYmxvY2sgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgKi9cbiAgaXNCbG9jazogZnVuY3Rpb24gaXNCbG9jayhlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuICFlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYEVkaXRvcmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc0VkaXRvcjogZnVuY3Rpb24gaXNFZGl0b3IodmFsdWUpIHtcbiAgICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChjYWNoZWRJc0VkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdG9yID0gdHlwZW9mIHZhbHVlLmFkZE1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVCYWNrd2FyZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRm9yd2FyZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRTb2Z0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRUZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc0lubGluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNWb2lkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5ub3JtYWxpemVOb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUucmVtb3ZlTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZ2V0RGlydHlQYXRocyA9PT0gJ2Z1bmN0aW9uJyAmJiAodmFsdWUubWFya3MgPT09IG51bGwgfHwgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gICAgcmV0dXJuIGlzRWRpdG9yO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VuZDogZnVuY3Rpb24gaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBlbmQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYW4gZWRnZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGVtcHR5LCBhY2NvdW50aW5nIGZvciB2b2lkIG5vZGVzLlxyXG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG5cbiAgICB2YXIgX2NoaWxkcmVuID0gX3NsaWNlZFRvQXJyYXkoY2hpbGRyZW4sIDEpLFxuICAgICAgICBmaXJzdCA9IF9jaGlsZHJlblswXTtcblxuICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGZpcnN0KSAmJiBmaXJzdC50ZXh0ID09PSAnJyAmJiAhZWRpdG9yLmlzVm9pZChlbGVtZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGlubGluZSBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc0lubGluZTogZnVuY3Rpb24gaXNJbmxpbmUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgY3VycmVudGx5IG5vcm1hbGl6aW5nIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxyXG4gICAqL1xuICBpc05vcm1hbGl6aW5nOiBmdW5jdGlvbiBpc05vcm1hbGl6aW5nKGVkaXRvcikge1xuICAgIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gICAgcmV0dXJuIGlzTm9ybWFsaXppbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc05vcm1hbGl6aW5nO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzU3RhcnQ6IGZ1bmN0aW9uIGlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgICBpZiAocG9pbnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdm9pZCBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1ZvaWQ6IGZ1bmN0aW9uIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1ZvaWQodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGFzdCBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlYWYgdGV4dCBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGxlYWY6IGZ1bmN0aW9uIGxlYWYoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBsZXZlbHMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbGV2ZWxzOiBmdW5jdGlvbiogbGV2ZWxzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYXQyID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDIgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDIsXG4gICAgICAgIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UsXG4gICAgICAgIF9vcHRpb25zJHZvaWRzMiA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMjtcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVscyA9IFtdO1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG5cbiAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoTm9kZS5sZXZlbHMoZWRpdG9yLCBwYXRoKSksXG4gICAgICAgIF9zdGVwNDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG4gPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgICBwID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgIGlmICghbWF0Y2gobiwgcCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVscy5wdXNoKFtuLCBwXSk7XG5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsZXZlbHMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHlpZWxkKiBsZXZlbHM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXJrcyB0aGF0IHdvdWxkIGJlIGFkZGVkIHRvIHRleHQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBtYXJrczogZnVuY3Rpb24gbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIG1hcmtzID0gZWRpdG9yLm1hcmtzLFxuICAgICAgICBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChtYXJrcykge1xuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICAgIH0pLFxuICAgICAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICAgICAgbWF0Y2ggPSBfRWRpdG9yJG5vZGVzMlswXTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBfbWF0Y2ggPSBfc2xpY2VkVG9BcnJheShtYXRjaCwgMSksXG4gICAgICAgICAgICBfbm9kZSA9IF9tYXRjaFswXTtcblxuICAgICAgICBfbm9kZS50ZXh0O1xuICAgICAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIHZhciBwYXRoID0gYW5jaG9yLnBhdGg7XG5cbiAgICB2YXIgX0VkaXRvciRsZWFmID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgX0VkaXRvciRsZWFmMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZiwgMSksXG4gICAgICAgIG5vZGUgPSBfRWRpdG9yJGxlYWYyWzBdO1xuXG4gICAgaWYgKGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcbiAgICAgIHZhciBtYXJrZWRWb2lkID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghbWFya2VkVm9pZCkge1xuICAgICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByZXYgJiYgYmxvY2spIHtcbiAgICAgICAgICB2YXIgX3ByZXYgPSBfc2xpY2VkVG9BcnJheShwcmV2LCAyKSxcbiAgICAgICAgICAgICAgcHJldk5vZGUgPSBfcHJldlswXSxcbiAgICAgICAgICAgICAgcHJldlBhdGggPSBfcHJldlsxXTtcblxuICAgICAgICAgIHZhciBfYmxvY2sgPSBfc2xpY2VkVG9BcnJheShibG9jaywgMiksXG4gICAgICAgICAgICAgIGJsb2NrUGF0aCA9IF9ibG9ja1sxXTtcblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoYmxvY2tQYXRoLCBwcmV2UGF0aCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX25vZGUyID0gbm9kZTtcbiAgICAgICAgX25vZGUyLnRleHQ7XG4gICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlMiwgX2V4Y2x1ZGVkMiQzKTtcblxuICAgIHJldHVybiByZXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkbW9kZTIgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlMiA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlMixcbiAgICAgICAgX29wdGlvbnMkdm9pZHMzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMzO1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgIF9vcHRpb25zJGF0MyA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQzID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQzO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgaWYgKCFwb2ludEFmdGVyTG9jYXRpb24pIHJldHVybjtcblxuICAgIHZhciBfRWRpdG9yJGxhc3QgPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKSxcbiAgICAgICAgX0VkaXRvciRsYXN0MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGFzdCwgMiksXG4gICAgICAgIHRvID0gX0VkaXRvciRsYXN0MlsxXTtcblxuICAgIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50LCAxKSxcbiAgICAgICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50MlswXTtcblxuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX0VkaXRvciRub2RlczMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSxcbiAgICAgICAgX0VkaXRvciRub2RlczQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzMywgMSksXG4gICAgICAgIG5leHQgPSBfRWRpdG9yJG5vZGVzNFswXTtcblxuICAgIHJldHVybiBuZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBub2RlOiBmdW5jdGlvbiBub2RlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBub2RlczogZnVuY3Rpb24qIG5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYXQ0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDQsXG4gICAgICAgIF9vcHRpb25zJG1vZGUzID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTMgPT09IHZvaWQgMCA/ICdhbGwnIDogX29wdGlvbnMkbW9kZTMsXG4gICAgICAgIF9vcHRpb25zJHVuaXZlcnNhbCA9IG9wdGlvbnMudW5pdmVyc2FsLFxuICAgICAgICB1bml2ZXJzYWwgPSBfb3B0aW9ucyR1bml2ZXJzYWwgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdW5pdmVyc2FsLFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlMiA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UyLFxuICAgICAgICBfb3B0aW9ucyR2b2lkczQgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczQ7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuXG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgIGZyb206IGZyb20sXG4gICAgICB0bzogdG8sXG4gICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgICBuID0gX3JlZjJbMF07XG5cbiAgICAgICAgcmV0dXJuIHZvaWRzID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgaGl0O1xuXG4gICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KG5vZGVFbnRyaWVzKSxcbiAgICAgICAgX3N0ZXA1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDUudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDUkdmFsdWVbMV07XG5cbiAgICAgICAgdmFyIGlzTG93ZXIgPSBoaXQgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGhpdFsxXSkgPT09IDA7IC8vIEluIGhpZ2hlc3QgbW9kZSBhbnkgbm9kZSBsb3dlciB0aGFuIHRoZSBsYXN0IGhpdCBpcyBub3QgYSBtYXRjaC5cblxuICAgICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgICAgICAvLyBJZiB3ZSd2ZSBhcnJpdmVkIGF0IGEgbGVhZiB0ZXh0IG5vZGUgdGhhdCBpcyBub3QgbG93ZXIgdGhhbiB0aGUgbGFzdFxuICAgICAgICAgIC8vIGhpdCwgdGhlbiB3ZSd2ZSBmb3VuZCBhIGJyYW5jaCB0aGF0IGRvZXNuJ3QgaW5jbHVkZSBhIG1hdGNoLCB3aGljaFxuICAgICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICAgIGlmICh1bml2ZXJzYWwgJiYgIWlzTG93ZXIgJiYgVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cblxuXG4gICAgICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIEluIGxvd2VzdCBtb2RlIHdlIGVtaXQgdGhlIGxhc3QgaGl0LCBvbmNlIGl0J3MgZ3VhcmFudGVlZCBsb3dlc3QuXG5cblxuICAgICAgICB2YXIgZW1pdCA9IG1vZGUgPT09ICdsb3dlc3QnID8gaGl0IDogW25vZGUsIHBhdGhdO1xuXG4gICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVtaXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBlbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgIH0gLy8gU2luY2UgbG93ZXN0IGlzIGFsd2F5cyBlbWl0dGluZyBvbmUgYmVoaW5kLCBjYXRjaCB1cCBhdCB0aGUgZW5kLlxuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGhpdDtcbiAgICAgIH1cbiAgICB9IC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gICAgLy8geWllbGQgYWxsIG9mIHRoZSBtYXRjaGVzIGFmdGVyIGl0ZXJhdGluZy5cblxuXG4gICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgeWllbGQqIG1hdGNoZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBhbnkgZGlydHkgb2JqZWN0cyBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGZvcmNlID0gb3B0aW9ucy5mb3JjZSxcbiAgICAgICAgZm9yY2UgPSBfb3B0aW9ucyRmb3JjZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRmb3JjZSxcbiAgICAgICAgb3BlcmF0aW9uID0gb3B0aW9ucy5vcGVyYXRpb247XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRocyA9IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMoZWRpdG9yKSB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gICAgfTtcblxuICAgIHZhciBnZXREaXJ0eVBhdGhLZXlzID0gZnVuY3Rpb24gZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpIHtcbiAgICAgIHJldHVybiBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgIH07XG5cbiAgICB2YXIgcG9wRGlydHlQYXRoID0gZnVuY3Rpb24gcG9wRGlydHlQYXRoKGVkaXRvcikge1xuICAgICAgdmFyIHBhdGggPSBnZXREaXJ0eVBhdGhzKGVkaXRvcikucG9wKCk7XG4gICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG4gICAgICBnZXREaXJ0eVBhdGhLZXlzKGVkaXRvcilbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWY0WzFdO1xuXG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWxsUGF0aEtleXMgPSBuZXcgU2V0KGFsbFBhdGhzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC5qb2luKCcsJyk7XG4gICAgICB9KSk7XG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgYWxsUGF0aEtleXMpO1xuICAgIH1cblxuICAgIGlmIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qXHJcbiAgICAgICAgRml4IGRpcnR5IGVsZW1lbnRzIHdpdGggbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoKSBkb2VzIGZpeCB0aGlzLCBidXQgc29tZSBub3JtYWxpemF0aW9uIGZpeGVzIGFsc28gcmVxdWlyZSBpdCB0byB3b3JrLlxyXG4gICAgICAgIFJ1bm5pbmcgYW4gaW5pdGlhbCBwYXNzIGF2b2lkcyB0aGUgY2F0Y2gtMjIgcmFjZSBjb25kaXRpb24uXHJcbiAgICAgICovXG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoZ2V0RGlydHlQYXRocyhlZGl0b3IpKSxcbiAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9kaXJ0eVBhdGggPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBfZGlydHlQYXRoKSkge1xuICAgICAgICAgICAgdmFyIF9lbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgX2RpcnR5UGF0aCk7XG5cbiAgICAgICAgICAgIHZhciBfZW50cnkyID0gX3NsaWNlZFRvQXJyYXkoX2VudHJ5LCAyKSxcbiAgICAgICAgICAgICAgICBub2RlID0gX2VudHJ5MlswXSxcbiAgICAgICAgICAgICAgICBfID0gX2VudHJ5MlsxXTtcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgbm9ybWFsaXplciBpbnNlcnRzIGFuIGVtcHR5IHRleHQgbm9kZSBpbiB0aGlzIHNjZW5hcmlvLCBidXQgaXQgY2FuIGJlIGN1c3RvbWlzZWQuXHJcbiAgICAgICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBBcyBsb25nIGFzIHRoZSBub3JtYWxpemVyIG9ubHkgaW5zZXJ0cyBjaGlsZCBub2RlcyBmb3IgdGhpcyBjYXNlIGl0IGlzIHNhZmUgdG8gZG8gaW4gYW55IG9yZGVyO1xyXG4gICAgICAgICAgICAgIGJ5IGRlZmluaXRpb24gYWRkaW5nIGNoaWxkcmVuIHRvIGFuIGVtcHR5IG5vZGUgY2FuJ3QgY2F1c2Ugb3RoZXIgcGF0aHMgdG8gY2hhbmdlLlxyXG4gICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShfZW50cnksIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAoIWVkaXRvci5zaG91bGROb3JtYWxpemUoe1xuICAgICAgICAgIGRpcnR5UGF0aHM6IGRpcnR5UGF0aHMsXG4gICAgICAgICAgaXRlcmF0aW9uOiBpdGVyYXRpb24sXG4gICAgICAgICAgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGg6IGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoLFxuICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpcnR5UGF0aCA9IHBvcERpcnR5UGF0aChlZGl0b3IpOyAvLyBJZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQuXG5cbiAgICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgZGlydHlQYXRoKSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZGlydHlQYXRoKTtcbiAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgICBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGFyZW50IG5vZGUgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRoIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgZGVwdGggPSBvcHRpb25zLmRlcHRoLFxuICAgICAgICBlZGdlID0gb3B0aW9ucy5lZGdlO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgdmFyIF9Ob2RlJGZpcnN0ID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9Ob2RlJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0LCAyKSxcbiAgICAgICAgICAgIGZpcnN0UGF0aCA9IF9Ob2RlJGZpcnN0MlsxXTtcblxuICAgICAgICBhdCA9IGZpcnN0UGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFyIF9Ob2RlJGxhc3QgPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICBfTm9kZSRsYXN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGxhc3QsIDIpLFxuICAgICAgICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0MlsxXTtcblxuICAgICAgICBhdCA9IGxhc3RQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgYXQgPSBhdC5wYXRoO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG4gIGhhc1BhdGg6IGZ1bmN0aW9uIGhhc1BhdGgoZWRpdG9yLCBwYXRoKSB7XG4gICAgcmV0dXJuIE5vZGUuaGFzKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBhdGhgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwYXRoUmVmOiBmdW5jdGlvbiBwYXRoUmVmKGVkaXRvciwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcGF0aCxcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eSxcbiAgICAgIHVucmVmOiBmdW5jdGlvbiB1bnJlZigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICAgIHBhdGhSZWZzW1wiZGVsZXRlXCJdKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwYXRoIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZnM6IGZ1bmN0aW9uIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUEFUSF9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUEFUSF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgb3IgZW5kIHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBvaW50OiBmdW5jdGlvbiBwb2ludChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRlZGdlID0gb3B0aW9ucy5lZGdlLFxuICAgICAgICBlZGdlID0gX29wdGlvbnMkZWRnZSA9PT0gdm9pZCAwID8gJ3N0YXJ0JyA6IF9vcHRpb25zJGVkZ2U7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgcGF0aDtcblxuICAgICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhciBfTm9kZSRsYXN0MyA9IE5vZGUubGFzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9Ob2RlJGxhc3Q0ID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkbGFzdDMsIDIpLFxuICAgICAgICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0NFsxXTtcblxuICAgICAgICBwYXRoID0gbGFzdFBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX05vZGUkZmlyc3QzID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9Ob2RlJGZpcnN0NCA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0MywgMiksXG4gICAgICAgICAgICBmaXJzdFBhdGggPSBfTm9kZSRmaXJzdDRbMV07XG5cbiAgICAgICAgcGF0aCA9IGZpcnN0UGF0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIFwiLmNvbmNhdChlZGdlLCBcIiBwb2ludCBpbiB0aGUgbm9kZSBhdCBwYXRoIFtcIikuY29uY2F0KGF0LCBcIl0gYmVjYXVzZSBpdCBoYXMgbm8gXCIpLmNvbmNhdChlZGdlLCBcIiB0ZXh0IG5vZGUuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBlZGdlID09PSAnZW5kJyA/IG5vZGUudGV4dC5sZW5ndGggOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBvaW50YCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWY6IGZ1bmN0aW9uIHBvaW50UmVmKGVkaXRvciwgcG9pbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGFmZmluaXR5MiA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkyID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTI7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHBvaW50LFxuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5LFxuICAgICAgdW5yZWY6IGZ1bmN0aW9uIHVucmVmKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgICBwb2ludFJlZnNbXCJkZWxldGVcIl0ocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwb2ludCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmczogZnVuY3Rpb24gcG9pbnRSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUE9JTlRfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFBPSU5UX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFsbCB0aGUgcG9zaXRpb25zIGluIGBhdGAgcmFuZ2Ugd2hlcmUgYSBgUG9pbnRgIGNhbiBiZSBwbGFjZWQuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBtb3ZlcyBmb3J3YXJkIGJ5IGluZGl2aWR1YWwgb2Zmc2V0cyBhdCBhIHRpbWUsIGJ1dFxyXG4gICAqIHRoZSBgdW5pdGAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHRvIG1vdmUgYnkgY2hhcmFjdGVyLCB3b3JkLCBsaW5lLCBvciBibG9jay5cclxuICAgKlxyXG4gICAqIFRoZSBgcmV2ZXJzZWAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSBpdGVyYXRpb24gZGlyZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogQnkgZGVmYXVsdCB2b2lkIG5vZGVzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIHBvaW50IGFuZCBpdGVyYXRpb25cclxuICAgKiB3aWxsIG5vdCBoYXBwZW4gaW5zaWRlIHRoZWlyIGNvbnRlbnQgdW5sZXNzIHlvdSBwYXNzIGluIHRydWUgZm9yIHRoZVxyXG4gICAqIGB2b2lkc2Agb3B0aW9uLCB0aGVuIGl0ZXJhdGlvbiB3aWxsIG9jY3VyLlxyXG4gICAqL1xuICBwb3NpdGlvbnM6IGZ1bmN0aW9uKiBwb3NpdGlvbnMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRhdDUgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0NSA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NSxcbiAgICAgICAgX29wdGlvbnMkdW5pdDMgPSBvcHRpb25zLnVuaXQsXG4gICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0MyA9PT0gdm9pZCAwID8gJ29mZnNldCcgOiBfb3B0aW9ucyR1bml0MyxcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZTMgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlMyxcbiAgICAgICAgX29wdGlvbnMkdm9pZHM1ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM1O1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFsZ29yaXRobSBub3RlczpcclxuICAgICAqXHJcbiAgICAgKiBFYWNoIHN0ZXAgYGRpc3RhbmNlYCBpcyBkeW5hbWljIGRlcGVuZGluZyBvbiB0aGUgdW5kZXJseWluZyB0ZXh0XHJcbiAgICAgKiBhbmQgdGhlIGB1bml0YCBzcGVjaWZpZWQuICBFYWNoIHN0ZXAsIGUuZy4sIGEgbGluZSBvciB3b3JkLCBtYXlcclxuICAgICAqIHNwYW4gbXVsdGlwbGUgdGV4dCBub2Rlcywgc28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSB0ZXh0IGJvdGggb25cclxuICAgICAqIHR3byBsZXZlbHMgaW4gc3RlcC1zeW5jOlxyXG4gICAgICpcclxuICAgICAqIGBsZWFmVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgdGV4dCBsZWFmIGxldmVsLCBhbmQgaXMgYWR2YW5jZWRcclxuICAgICAqIHRocm91Z2ggdXNpbmcgdGhlIGNvdW50ZXJzIGBsZWFmVGV4dE9mZnNldGAgYW5kIGBsZWFmVGV4dFJlbWFpbmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogYGJsb2NrVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgYmxvY2sgbGV2ZWwsIGFuZCBpcyBzaG9ydGVuZWRcclxuICAgICAqIGJ5IGBkaXN0YW5jZWAgZXZlcnkgdGltZSBpdCBpcyBhZHZhbmNlZC5cclxuICAgICAqXHJcbiAgICAgKiBXZSBvbmx5IG1haW50YWluIGEgd2luZG93IG9mIG9uZSBibG9ja1RleHQgYW5kIG9uZSBsZWFmVGV4dCBiZWNhdXNlXHJcbiAgICAgKiBhIGJsb2NrIG5vZGUgYWx3YXlzIGFwcGVhcnMgYmVmb3JlIGFsbCBvZiBpdHMgbGVhZiBub2Rlcy5cclxuICAgICAqL1xuXG5cbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczRbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczRbMV07XG5cbiAgICB2YXIgZmlyc3QgPSByZXZlcnNlID8gZW5kIDogc3RhcnQ7XG4gICAgdmFyIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICB2YXIgYmxvY2tUZXh0ID0gJyc7XG4gICAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRGlzdGFuY2UgZm9yIGxlYWZUZXh0IHRvIGNhdGNoIHVwIHRvIGJsb2NrVGV4dC5cblxuICAgIHZhciBsZWFmVGV4dFJlbWFpbmluZyA9IDA7XG4gICAgdmFyIGxlYWZUZXh0T2Zmc2V0ID0gMDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBub2RlcyBpbiByYW5nZSwgZ3JhYmJpbmcgZW50aXJlIHRleHR1YWwgY29udGVudFxuICAgIC8vIG9mIGJsb2NrIG5vZGVzIGluIGJsb2NrVGV4dCwgYW5kIHRleHQgbm9kZXMgaW4gbGVhZlRleHQuXG4gICAgLy8gRXhwbG9pdHMgdGhlIGZhY3QgdGhhdCBub2RlcyBhcmUgc2VxdWVuY2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBmaXJzdFxuICAgIC8vIGVuY291bnRlciB0aGUgYmxvY2sgbm9kZSwgdGhlbiBhbGwgb2YgaXRzIHRleHQgbm9kZXMsIHNvIHdoZW4gaXRlcmF0aW5nXG4gICAgLy8gdGhyb3VnaCB0aGUgYmxvY2tUZXh0IGFuZCBsZWFmVGV4dCB3ZSBqdXN0IG5lZWQgdG8gcmVtZW1iZXIgYSB3aW5kb3cgb2ZcbiAgICAvLyBvbmUgYmxvY2sgbm9kZSBhbmQgbGVhZiBub2RlLCByZXNwZWN0aXZlbHkuXG5cbiAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGF0LFxuICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pKSxcbiAgICAgICAgX3N0ZXA3O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDckdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDcudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwNyR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDckdmFsdWVbMV07XG5cbiAgICAgICAgLypcclxuICAgICAgICAgKiBFTEVNRU5UIE5PREUgLSBZaWVsZCBwb3NpdGlvbihzKSBmb3Igdm9pZHMsIGNvbGxlY3QgYmxvY2tUZXh0IGZvciBibG9ja3NcclxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgLy8gVm9pZCBub2RlcyBhcmUgYSBzcGVjaWFsIGNhc2UsIHNvIGJ5IGRlZmF1bHQgd2Ugd2lsbCBhbHdheXNcbiAgICAgICAgICAvLyB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC4gSWYgdGhlIGB2b2lkc2Agb3B0aW9uIGlzIHNldCB0byB0cnVlLFxuICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBpdGVyYXRlIG92ZXIgdGhlaXIgY29udGVudC5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIGVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBJbmxpbmUgZWxlbWVudCBub2RlcyBhcmUgaWdub3JlZCBhcyB0aGV5IGRvbid0IHRoZW1zZWx2ZXNcbiAgICAgICAgICAvLyBjb250cmlidXRlIHRvIGBibG9ja1RleHRgIG9yIGBsZWFmVGV4dGAgLSB0aGVpciBwYXJlbnQgYW5kXG4gICAgICAgICAgLy8gY2hpbGRyZW4gZG8uXG5cblxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIGNvbnRpbnVlOyAvLyBCbG9jayBlbGVtZW50IG5vZGUgLSBzZXQgYGJsb2NrVGV4dGAgdG8gaXRzIHRleHQgY29udGVudC5cblxuICAgICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJyxcbiAgICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAgICAgLy8gRW5zdXJlIHJhbmdlIGNvbnNpZGVyZWQgaXMgY2FwcGVkIHRvIGByYW5nZWAsIGluIHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIC4uLkVkaXRvci5lZGdlcyhlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgICAgIHZhciBlID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGVuZC5wYXRoKSA/IGVuZCA6IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGFuY2hvcjogcyxcbiAgICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRFWFQgTEVBRiBOT0RFIC0gSXRlcmF0ZSB0aHJvdWdoIHRleHQgY29udGVudCwgeWllbGRpbmdcclxuICAgICAgICAgKiBwb3NpdGlvbnMgZXZlcnkgYGRpc3RhbmNlYCBvZmZzZXQgYWNjb3JkaW5nIHRvIGB1bml0YC5cclxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgIHZhciBpc0ZpcnN0ID0gUGF0aC5lcXVhbHMocGF0aCwgZmlyc3QucGF0aCk7IC8vIFByb29mIHRoYXQgd2UgYWx3YXlzIGV4aGF1c3QgdGV4dCBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAgICAgLy8gICAgIGBsZWFmVGV4dFJlbWFpbmluZz0ke2xlYWZUZXh0UmVtYWluaW5nfSAtIGArXG4gICAgICAgICAgLy8gICAgIGBub3QgZXhoYXVzdGVkIGJlZm9yZSBuZXcgbGVhZiB0ZXh0IG5vZGVgLCBwYXRoKVxuICAgICAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG5cbiAgICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSByZXZlcnNlID8gZmlyc3Qub2Zmc2V0IDogbm9kZS50ZXh0Lmxlbmd0aCAtIGZpcnN0Lm9mZnNldDtcbiAgICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgICAgICB9IC8vIFlpZWxkIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiBub2RlIChwb3RlbnRpYWxseSkuXG5cblxuICAgICAgICAgIGlmIChpc0ZpcnN0IHx8IGlzTmV3QmxvY2sgfHwgdW5pdCA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICB9IC8vIFlpZWxkIHBvc2l0aW9ucyBldmVyeSAoZHluYW1pY2FsbHkgY2FsY3VsYXRlZCkgYGRpc3RhbmNlYCBvZmZzZXQuXG5cblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBJZiBgbGVhZlRleHRgIGhhcyBjYXVnaHQgdXAgd2l0aCBgYmxvY2tUZXh0YCAoZGlzdGFuY2U9MCksXG4gICAgICAgICAgICAvLyBhbmQgaWYgYmxvY2tUZXh0IGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGFub3RoZXIgYmxvY2sgbm9kZSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhZHZhbmNlIGJsb2NrVGV4dCBmb3J3YXJkIGJ5IHRoZSBuZXcgYGRpc3RhbmNlYC5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAoYmxvY2tUZXh0ID09PSAnJykgYnJlYWs7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKGJsb2NrVGV4dCwgdW5pdCwgcmV2ZXJzZSk7IC8vIFNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIHByZXZpb3VzbHkgZm91bmQgZGlzdGFuY2UgYW5kIHVzZSB0aGVcbiAgICAgICAgICAgICAgLy8gcmVtYWluaW5nIHN0cmluZyBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxuXG4gICAgICAgICAgICAgIGJsb2NrVGV4dCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShibG9ja1RleHQsIGRpc3RhbmNlLCByZXZlcnNlKVsxXTtcbiAgICAgICAgICAgIH0gLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG5cblxuICAgICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRPZmZzZXQgLSBkaXN0YW5jZSA6IGxlYWZUZXh0T2Zmc2V0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IGxlYWZUZXh0UmVtYWluaW5nIC0gZGlzdGFuY2U7IC8vIElmIGBsZWFmVGV4dGAgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYSBuZXcgbGVhZiBub2RlXG4gICAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAgIC8vIGNhdGNoIHVwIHRvIGJsb2NrVGV4dCBpbiB0aGUgbmV4dCBsZWFmIHRleHQgbm9kZS5cblxuICAgICAgICAgICAgaWYgKGxlYWZUZXh0UmVtYWluaW5nIDwgMCkge1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IC1sZWFmVGV4dFJlbWFpbmluZztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFN1Y2Nlc3NmdWxseSB3YWxrZWQgYGRpc3RhbmNlYCBvZmZzZXRzIHRocm91Z2ggYGxlYWZUZXh0YFxuICAgICAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgICAgIC8vIGFuZCB5aWVsZCB0aGlzIHBvc2l0aW9uIGluIHRoaXMgbm9kZS5cblxuXG4gICAgICAgICAgICBkaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAgICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLCBcImxlYWZUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJywgXCJibG9ja1RleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgICAgLy8gSGVscGVyOlxuICAgICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBvZmZzZXRzIGZvciBhIHN0ZXAgb2Ygc2l6ZSBgdW5pdGAgb24gZ2l2ZW4gc3RyaW5nLlxuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGJyYW5jaCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJG1vZGU0ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTQgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTQsXG4gICAgICAgIF9vcHRpb25zJHZvaWRzNiA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM2ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNjtcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICBfb3B0aW9ucyRhdDYgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0NiA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NjtcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRCZWZvcmVMb2NhdGlvbiA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwge1xuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG5cbiAgICBpZiAoIXBvaW50QmVmb3JlTG9jYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX0VkaXRvciRmaXJzdCA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKSxcbiAgICAgICAgX0VkaXRvciRmaXJzdDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGZpcnN0LCAyKSxcbiAgICAgICAgdG8gPSBfRWRpdG9yJGZpcnN0MlsxXTsgLy8gVGhlIHNlYXJjaCBsb2NhdGlvbiBpcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgdG8gdGhlIHBhdGggb2ZcbiAgICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cblxuXG4gICAgdmFyIHNwYW4gPSBbcG9pbnRCZWZvcmVMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBfRWRpdG9yJHBhcmVudDMgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQzLCAxKSxcbiAgICAgICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50NFswXTtcblxuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX0VkaXRvciRub2RlczUgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSksXG4gICAgICAgIF9FZGl0b3Ikbm9kZXM2ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlczUsIDEpLFxuICAgICAgICBwcmV2aW91cyA9IF9FZGl0b3Ikbm9kZXM2WzBdO1xuXG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHJhbmdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHJhbmdlOiBmdW5jdGlvbiByYW5nZShlZGl0b3IsIGF0LCB0bykge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCB0byB8fCBhdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUmFuZ2VgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZjogZnVuY3Rpb24gcmFuZ2VSZWYoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkzID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eTMgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5MztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcmFuZ2UsXG4gICAgICBhZmZpbml0eTogYWZmaW5pdHksXG4gICAgICB1bnJlZjogZnVuY3Rpb24gdW5yZWYoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICAgIHJhbmdlUmVmc1tcImRlbGV0ZVwiXShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHJhbmdlIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcmFuZ2VSZWZzOiBmdW5jdGlvbiByYW5nZVJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBSQU5HRV9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgYSBjdXN0b20gcHJvcGVydHkgZnJvbSBhbGwgb2YgdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudFxyXG4gICAqIHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCwgdGhlIHJlbW92YWwgd2lsbCBiZSBzdG9yZWQgb25cclxuICAgKiBgZWRpdG9yLm1hcmtzYCBhbmQgYXBwbGllZCB0byB0aGUgdGV4dCBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICByZW1vdmVNYXJrOiBmdW5jdGlvbiByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYW51YWxseSBzZXQgaWYgdGhlIGVkaXRvciBzaG91bGQgY3VycmVudGx5IGJlIG5vcm1hbGl6aW5nLlxyXG4gICAqXHJcbiAgICogTm90ZTogVXNpbmcgdGhpcyBpbmNvcnJlY3RseSBjYW4gbGVhdmUgdGhlIGVkaXRvciBpbiBhbiBpbnZhbGlkIHN0YXRlLlxyXG4gICAqXHJcbiAgICovXG4gIHNldE5vcm1hbGl6aW5nOiBmdW5jdGlvbiBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBOT1JNQUxJWklORy5zZXQoZWRpdG9yLCBpc05vcm1hbGl6aW5nKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnc3RhcnQnXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSB0ZXh0IHN0cmluZyBjb250ZW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICpcclxuICAgKiBOb3RlOiBieSBkZWZhdWx0IHRoZSB0ZXh0IG9mIHZvaWQgbm9kZXMgaXMgY29uc2lkZXJlZCB0byBiZSBhbiBlbXB0eVxyXG4gICAqIHN0cmluZywgcmVnYXJkbGVzcyBvZiBjb250ZW50LCB1bmxlc3MgeW91IHBhc3MgaW4gdHJ1ZSBmb3IgdGhlIHZvaWRzIG9wdGlvblxyXG4gICAqL1xuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR2b2lkczcgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczc7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuXG4gICAgdmFyIF9SYW5nZSRlZGdlczUgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM2WzBdLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM2WzFdO1xuXG4gICAgdmFyIHRleHQgPSAnJztcblxuICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSksXG4gICAgICAgIF9zdGVwODtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA4JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA4LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDgkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXA4JHZhbHVlWzFdO1xuXG4gICAgICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBzdGFydC5wYXRoKSkge1xuICAgICAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ICs9IHQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29udmVydCBhIHJhbmdlIGludG8gYSBub24taGFuZ2luZyBvbmUuXHJcbiAgICovXG4gIHVuaGFuZ1JhbmdlOiBmdW5jdGlvbiB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR2b2lkczggPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzOCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczg7XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzNyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzOCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczcsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczhbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczhbMV07IC8vIFBFUkY6IGV4aXQgZWFybHkgaWYgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZSBpc24ndCBoYW5naW5nLlxuXG5cbiAgICBpZiAoc3RhcnQub2Zmc2V0ICE9PSAwIHx8IGVuZC5vZmZzZXQgIT09IDAgfHwgUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpIHx8IFBhdGguaGFzUHJldmlvdXMoZW5kLnBhdGgpKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBibG9ja1BhdGggPSBlbmRCbG9jayA/IGVuZEJsb2NrWzFdIDogW107XG4gICAgdmFyIGZpcnN0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgc3RhcnQpO1xuICAgIHZhciBiZWZvcmUgPSB7XG4gICAgICBhbmNob3I6IGZpcnN0LFxuICAgICAgZm9jdXM6IGVuZFxuICAgIH07XG4gICAgdmFyIHNraXAgPSB0cnVlO1xuXG4gICAgdmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBiZWZvcmUsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSkpLFxuICAgICAgICBfc3RlcDk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I5LnMoKTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwOSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOS52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXA5JHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwOSR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICAgIGVuZCA9IHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I5LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yOS5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgXCJ2b2lkXCI6IGZ1bmN0aW9uIF92b2lkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDYWxsIGEgZnVuY3Rpb24sIGRlZmVycmluZyBub3JtYWxpemF0aW9uIHVudGlsIGFmdGVyIGl0IGNvbXBsZXRlcy5cclxuICAgKi9cbiAgd2l0aG91dE5vcm1hbGl6aW5nOiBmdW5jdGlvbiB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cbn07XG5cbnZhciBMb2NhdGlvbiA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgTG9jYXRpb25gIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNMb2NhdGlvbjogZnVuY3Rpb24gaXNMb2NhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZSkgfHwgUG9pbnQuaXNQb2ludCh2YWx1ZSkgfHwgUmFuZ2UuaXNSYW5nZSh2YWx1ZSk7XG4gIH1cbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIFNwYW4gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFNwYW5gIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNTcGFuOiBmdW5jdGlvbiBpc1NwYW4odmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyICYmIHZhbHVlLmV2ZXJ5KFBhdGguaXNQYXRoKTtcbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiY2hpbGRyZW5cIl0sXG4gICAgX2V4Y2x1ZGVkMiQyID0gW1widGV4dFwiXTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbnZhciBJU19OT0RFX0xJU1RfQ0FDSEUgPSBuZXcgV2Vha01hcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBOb2RlID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGFuIGFuY2VzdG9yIG5vZGUuXHJcbiAgICovXG4gIGFuY2VzdG9yOiBmdW5jdGlvbiBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYWJvdmUgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gIGFuY2VzdG9yczogZnVuY3Rpb24qIGFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQoUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgbiA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcCk7XG4gICAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgICAgeWllbGQgZW50cnk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNoaWxkIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG4gICAqL1xuICBjaGlsZDogZnVuY3Rpb24gY2hpbGQocm9vdCwgaW5kZXgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGNoaWxkIG9mIGEgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSByb290LmNoaWxkcmVuW2luZGV4XTtcblxuICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgY2hpbGQgYXQgaW5kZXggYFwiLmNvbmNhdChpbmRleCwgXCJgIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSBvdmVyIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBjaGlsZHJlbjogZnVuY3Rpb24qIGNoaWxkcmVuKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2U7XG4gICAgdmFyIGFuY2VzdG9yID0gTm9kZS5hbmNlc3Rvcihyb290LCBwYXRoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBhbmNlc3Rvci5jaGlsZHJlbjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uOiBmdW5jdGlvbiBjb21tb24ocm9vdCwgcGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBwID0gUGF0aC5jb21tb24ocGF0aCwgYW5vdGhlcik7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGFzc2VydGluZyB0aGF0IGl0J3MgYSBkZXNjZW5kYW50IG5vZGUuXHJcbiAgICovXG4gIGRlc2NlbmRhbnQ6IGZ1bmN0aW9uIGRlc2NlbmRhbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBkZXNjZW5kYW50IG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byB0aGUgcm9vdCBlZGl0b3Igbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGdlbmVyYXRvciBvZiBhbGwgdGhlIGRlc2NlbmRhbnQgbm9kZSBlbnRyaWVzIGluc2lkZSBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKiBkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDI7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAgIC8vIGd1YXJhbnRlZSB0aGF0IGBub2RlYCBpcyBub3QgYSBgRWRpdG9yYCwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93LlxuICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgZWxlbWVudHM6IGZ1bmN0aW9uKiBlbGVtZW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDM7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXh0cmFjdCBwcm9wcyBmcm9tIGEgTm9kZS5cclxuICAgKi9cbiAgZXh0cmFjdFByb3BzOiBmdW5jdGlvbiBleHRyYWN0UHJvcHMobm9kZSkge1xuICAgIGlmIChFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkJDMpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50ZXh0O1xuICAgICAgICAgIHZhciBfcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICByZXR1cm4gX3Byb3BlcnRpZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZmlyc3Qgbm9kZSBlbnRyeSBpbiBhIHJvb3Qgbm9kZSBmcm9tIGEgcGF0aC5cclxuICAgKi9cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuXG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuWzBdO1xuICAgICAgICBwLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNsaWNlZCBmcmFnbWVudCByZXByZXNlbnRlZCBieSBhIHJhbmdlIGluc2lkZSBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBpbW1lci5wcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMociwge1xuICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgICAgcGF0aCA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobm9kZUVudHJpZXMpLFxuICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgcGF0aCA9IF9zdGVwNCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmICghUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gTm9kZS5wYXJlbnQociwgcGF0aCk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcbiAgICAgICAgICAgIGxlYWYudGV4dCA9IGxlYWYudGV4dC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBfbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcblxuICAgICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiBnZXQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkZXNjZW5kYW50IGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBkZXNjZW5kYW50IG5vZGUgZXhpc3RzIGF0IGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKi9cbiAgaGFzOiBmdW5jdGlvbiBoYXMocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBOb2RlYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzTm9kZTogZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdDogZnVuY3Rpb24gaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gTm9kZS5pc05vZGUodmFsKTtcbiAgICB9KTtcbiAgICBJU19OT0RFX0xJU1RfQ0FDSEUuc2V0KHZhbHVlLCBpc05vZGVMaXN0KTtcbiAgICByZXR1cm4gaXNOb2RlTGlzdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBlbnRyeSBpbiBhIHJvb3Qgbm9kZSBmcm9tIGEgcGF0aC5cclxuICAgKi9cbiAgbGFzdDogZnVuY3Rpb24gbGFzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5baV07XG4gICAgICAgIHAucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGVuc3VyaW5nIGl0J3MgYSBsZWFmIHRleHQgbm9kZS5cclxuICAgKi9cbiAgbGVhZjogZnVuY3Rpb24gbGVhZihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgdGhlIGluIGEgYnJhbmNoIG9mIHRoZSB0cmVlLCBmcm9tIGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQgdGhlIG9yZGVyIGlzIHRvcC1kb3duLCBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IG5vZGUgaW4gdGhlIHRyZWUsXHJcbiAgICogYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gIGxldmVsczogZnVuY3Rpb24qIGxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXA1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB5aWVsZCBbbiwgcF07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBtYXRjaGVzIGEgc2V0IG9mIHByb3BzLlxyXG4gICAqL1xuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKG5vZGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50UHJvcHMocHJvcHMpICYmIEVsZW1lbnQubWF0Y2hlcyhub2RlLCBwcm9wcykgfHwgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHRQcm9wcyhwcm9wcykgJiYgVGV4dC5tYXRjaGVzKG5vZGUsIHByb3BzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBub2RlIGVudHJpZXMgb2YgYSByb290IG5vZGUuIEVhY2ggZW50cnkgaXNcclxuICAgKiByZXR1cm5lZCBhcyBhIGBbTm9kZSwgUGF0aF1gIHR1cGxlLCB3aXRoIHRoZSBwYXRoIHJlZmVycmluZyB0byB0aGUgbm9kZSdzXHJcbiAgICogcG9zaXRpb24gaW5zaWRlIHRoZSByb290IG5vZGUuXHJcbiAgICovXG4gIG5vZGVzOiBmdW5jdGlvbiogbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgcGFzcyA9IG9wdGlvbnMucGFzcyxcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZTIgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlMjtcbiAgICB2YXIgX29wdGlvbnMkZnJvbSA9IG9wdGlvbnMuZnJvbSxcbiAgICAgICAgZnJvbSA9IF9vcHRpb25zJGZyb20gPT09IHZvaWQgMCA/IFtdIDogX29wdGlvbnMkZnJvbSxcbiAgICAgICAgdG8gPSBvcHRpb25zLnRvO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChyb290LCBwYXRoKSB7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgcCA9IE5vZGUuZ2V0KHJvb3QsIHBhcmVudFBhdGgpO1xuXG4gICAgaWYgKFRleHQuaXNUZXh0KHApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgb2YgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSByb290LlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjb25jYXRlbmF0ZWQgdGV4dCBzdHJpbmcgb2YgYSBub2RlJ3MgY29udGVudC5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGluY2x1ZGUgc3BhY2VzIG9yIGxpbmUgYnJlYWtzIGJldHdlZW4gYmxvY2sgbm9kZXMuXHJcbiAgICogSXQgaXMgbm90IGEgdXNlci1mYWNpbmcgc3RyaW5nLCBidXQgYSBzdHJpbmcgZm9yIHBlcmZvcm1pbmcgb2Zmc2V0LXJlbGF0ZWRcclxuICAgKiBjb21wdXRhdGlvbnMgZm9yIGEgbm9kZS5cclxuICAgKi9cbiAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcobm9kZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKE5vZGUuc3RyaW5nKS5qb2luKCcnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCBsZWFmIHRleHQgbm9kZXMgaW4gYSByb290IG5vZGUuXHJcbiAgICovXG4gIHRleHRzOiBmdW5jdGlvbiogdGV4dHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXA2O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDYkdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDcob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDcodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ3KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIE9wZXJhdGlvbiA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBOb2RlT3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzTm9kZU9wZXJhdGlvbjogZnVuY3Rpb24gaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGBPcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNPcGVyYXRpb246IGZ1bmN0aW9uIGlzT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gdmFsdWUucHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLm5ld1Byb3BlcnRpZXMpIHx8IHZhbHVlLm5ld1Byb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5wcm9wZXJ0aWVzKSB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm5ld1Byb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBPcGVyYXRpb25gIG9iamVjdHMuXHJcbiAgICovXG4gIGlzT3BlcmF0aW9uTGlzdDogZnVuY3Rpb24gaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFNlbGVjdGlvbk9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1NlbGVjdGlvbk9wZXJhdGlvbjogZnVuY3Rpb24gaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbjogZnVuY3Rpb24gaXNUZXh0T3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3RleHQnKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnZlcnQgYW4gb3BlcmF0aW9uLCByZXR1cm5pbmcgYSBuZXcgb3BlcmF0aW9uIHRoYXQgd2lsbCBleGFjdGx5IHVuZG8gdGhlXHJcbiAgICogb3JpZ2luYWwgd2hlbiBhcHBsaWVkLlxyXG4gICAqL1xuICBpbnZlcnNlOiBmdW5jdGlvbiBpbnZlcnNlKG9wKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5wcmV2aW91cyhvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IG9wLm5ld1BhdGgsXG4gICAgICAgICAgICAgIHBhdGggPSBvcC5wYXRoOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcHJvcGVydGllczogbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIF9uZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcblxuICAgICAgICAgIGlmIChfcHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgubmV4dChvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzOiBmdW5jdGlvbiBhbmNlc3RvcnMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgICB2YXIgcGF0aHMgPSBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKTtcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aHM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBvZiB0d28gcGF0aHMuXHJcbiAgICovXG4gIGNvbW1vbjogZnVuY3Rpb24gY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXI6IGZ1bmN0aW9uIGVuZHNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA+IGJ2O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGF0IG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQXQ6IGZ1bmN0aW9uIGVuZHNBdChwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGVuZHMgYmVmb3JlIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQmVmb3JlOiBmdW5jdGlvbiBlbmRzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2IDwgYnY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeShmdW5jdGlvbiAobiwgaSkge1xuICAgICAgcmV0dXJuIG4gPT09IGFub3RoZXJbaV07XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHBhdGggb2YgcHJldmlvdXMgc2libGluZyBub2RlIGV4aXN0c1xyXG4gICAqL1xuICBoYXNQcmV2aW91czogZnVuY3Rpb24gaGFzUHJldmlvdXMocGF0aCkge1xuICAgIHJldHVybiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyOiBmdW5jdGlvbiBpc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhbiBhbmNlc3RvciBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiBpc0FuY2VzdG9yKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPCBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGJlZm9yZSBhbm90aGVyLlxyXG4gICAqL1xuICBpc0JlZm9yZTogZnVuY3Rpb24gaXNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGNoaWxkIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggKyAxICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXF1YWwgdG8gb3IgYW4gYW5jZXN0b3Igb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNDb21tb246IGZ1bmN0aW9uIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50OiBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgdGhlIHBhcmVudCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc1BhcmVudDogZnVuY3Rpb24gaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aDogZnVuY3Rpb24gaXNQYXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGEgc2libGluZyBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc1NpYmxpbmc6IGZ1bmN0aW9uIGlzU2libGluZyhwYXRoLCBhbm90aGVyKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgLTEpO1xuICAgIHZhciBhbCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmwgPSBhbm90aGVyW2Fub3RoZXIubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGFsICE9PSBibCAmJiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIGxpc3Qgb2YgcGF0aHMgYXQgZXZlcnkgbGV2ZWwgZG93biB0byBhIHBhdGguIE5vdGU6IHRoaXMgaXMgdGhlIHNhbWVcclxuICAgKiBhcyBgUGF0aC5hbmNlc3RvcnNgLCBidXQgaW5jbHVkaW5nIHRoZSBwYXRoIGl0c2VsZi5cclxuICAgKlxyXG4gICAqIFRoZSBwYXRocyBhcmUgc29ydGVkIGZyb20gc2hhbGxvd2VzdCB0byBkZWVwZXN0LiBIb3dldmVyLCBpZiB0aGUgYHJldmVyc2U6XHJcbiAgICogdHJ1ZWAgb3B0aW9uIGlzIHBhc3NlZCwgdGhleSBhcmUgcmV2ZXJzZWQuXHJcbiAgICovXG4gIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UyID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZTIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTI7XG4gICAgdmFyIGxpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QucHVzaChwYXRoLnNsaWNlKDAsIGkpKTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGlzdC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCBnZXQgdGhlIHBhdGggdG8gdGhlIG5leHQgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gbmV4dCBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCArIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIG9wZXJhdGlvbiBjYW4gYWZmZWN0IHBhdGhzIG9yIG5vdC4gVXNlZCBhcyBhblxyXG4gICAqIG9wdGltaXphdGlvbiB3aGVuIHVwZGF0aW5nIGRpcnR5IHBhdGhzIGR1cmluZyBub3JtYWxpemF0aW9uXHJcbiAgICpcclxuICAgKiBOT1RFOiBUaGlzICptdXN0KiBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgaW1wbGVtZW50YXRpb24gb2YgJ3RyYW5zZm9ybSdcclxuICAgKiBiZWxvd1xyXG4gICAqL1xuICBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoOiBmdW5jdGlvbiBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wZXJhdGlvbikge1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIHJldHVybiBhIG5ldyBwYXRoIHJlZmVycmluZyB0byB0aGUgcGFyZW50IG5vZGUgYWJvdmUgaXQuXHJcbiAgICovXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBwYXRoIG9mIHRoZSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0uXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCBnZXQgdGhlIHBhdGggdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIHByZXZpb3VzIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgZmlyc3QgY2hpbGQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHdvdWxkIHJlc3VsdCBpbiBhIG5lZ2F0aXZlIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0IC0gMSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgcGF0aCByZWxhdGl2ZSB0byBhbiBhbmNlc3Rvci5cclxuICAgKi9cbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocGF0aCwgb3BlcmF0aW9uKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7IC8vIFBFUkY6IHVzZSBkZXN0cnVjdGluZyBpbnN0ZWFkIG9mIGltbWVyXG5cbiAgICB2YXIgcCA9IF90b0NvbnN1bWFibGVBcnJheShwYXRoKTtcblxuICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5OyAvLyBQRVJGOiBFeGl0IGVhcmx5IGlmIHRoZSBvcGVyYXRpb24gaXMgZ3VhcmFudGVlZCBub3QgdG8gaGF2ZSBhbiBlZmZlY3QuXG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBvcCA9IG9wZXJhdGlvbi5wYXRoO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUob3AsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvcCwgcCkpIHtcbiAgICAgICAgICAgIHBbb3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wID0gb3BlcmF0aW9uLnBhdGg7XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3AyID0gb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gb3BlcmF0aW9uLnBvc2l0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wMyA9IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgICBfcG9zaXRpb24gPSBvcGVyYXRpb24ucG9zaXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMywgcCkpIHtcbiAgICAgICAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgIHBbcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ2JhY2t3YXJkJykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wMywgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDMsIHApICYmIHBhdGhbX29wMy5sZW5ndGhdID49IF9wb3NpdGlvbikge1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoXSAtPSBfcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3A0ID0gb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgICAgICAgIG9ucCA9IG9wZXJhdGlvbi5uZXdQYXRoOyAvLyBJZiB0aGUgb2xkIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWUsIGl0J3MgYSBuby1vcC5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDQsIHApIHx8IFBhdGguZXF1YWxzKF9vcDQsIHApKSB7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ucC5zbGljZSgpO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIG9ucCkgJiYgX29wNC5sZW5ndGggPCBvbnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvcHlbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29weS5jb25jYXQocC5zbGljZShfb3A0Lmxlbmd0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1NpYmxpbmcoX29wNCwgb25wKSAmJiAoUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvbnAsIHApKSB7XG4gICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH1cbn07XG5cbnZhciBQYXRoUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHBhdGggcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgICBhZmZpbml0eSA9IHJlZi5hZmZpbml0eTtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IFBhdGgudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUG9pbnQgPSB7XG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwb2ludCB0byBhbm90aGVyLCByZXR1cm5pbmcgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlXHJcbiAgICogcG9pbnQgd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKi9cbiAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShwb2ludCwgYW5vdGhlcikge1xuICAgIHZhciByZXN1bHQgPSBQYXRoLmNvbXBhcmUocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcblxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyOiBmdW5jdGlvbiBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlOiBmdW5jdGlvbiBpc0JlZm9yZShwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBleGFjdGx5IGVxdWFsIHRvIGFub3RoZXIuXHJcbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUG9pbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNQb2ludDogZnVuY3Rpb24gaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHBvaW50IGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9pbnQsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBpbW1lci5wcm9kdWNlKHBvaW50LCBmdW5jdGlvbiAocCkge1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7XG4gICAgICB2YXIgcGF0aCA9IHAucGF0aCxcbiAgICAgICAgICBvZmZzZXQgPSBwLm9mZnNldDtcblxuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiAob3Aub2Zmc2V0IDwgb2Zmc2V0IHx8IG9wLm9mZnNldCA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wLnBvc2l0aW9uIDwgb2Zmc2V0IHx8IG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICAgIHAub2Zmc2V0IC09IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgUG9pbnRSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcG9pbnQgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgICBhZmZpbml0eSA9IHJlZi5hZmZpbml0eTtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSBQb2ludC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG5cbiAgICBpZiAocG9pbnQgPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ1KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBSYW5nZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIHJhbmdlLCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcHBlYXJcclxuICAgKiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhyYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKSA9PT0gcmV2ZXJzZSA/IFthbmNob3IsIGZvY3VzXSA6IFtmb2N1cywgYW5jaG9yXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIHJhbmdlLlxyXG4gICAqL1xuICBlbmQ6IGZ1bmN0aW9uIGVuZChyYW5nZSkge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgcmV0dXJuIGVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHJhbmdlLmFuY2hvciwgYW5vdGhlci5hbmNob3IpICYmIFBvaW50LmVxdWFscyhyYW5nZS5mb2N1cywgYW5vdGhlci5mb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpbmNsdWRlcyBhIHBhdGgsIGEgcG9pbnQgb3IgcGFydCBvZiBhbm90aGVyIHJhbmdlLlxyXG4gICAqL1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMocmFuZ2UsIHRhcmdldCkge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIGlmIChSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmFuY2hvcikgfHwgUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5mb2N1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgICBycyA9IF9SYW5nZSRlZGdlczRbMF0sXG4gICAgICAgICAgcmUgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzNSA9IFJhbmdlLmVkZ2VzKHRhcmdldCksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzNiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczUsIDIpLFxuICAgICAgICAgIHRzID0gX1JhbmdlJGVkZ2VzNlswXSxcbiAgICAgICAgICB0ZSA9IF9SYW5nZSRlZGdlczZbMV07XG5cbiAgICAgIHJldHVybiBQb2ludC5pc0JlZm9yZShycywgdHMpICYmIFBvaW50LmlzQWZ0ZXIocmUsIHRlKTtcbiAgICB9XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzNyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzOCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczcsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczhbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczhbMV07XG5cbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludCh0YXJnZXQpKSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgc3RhcnQpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBlbmQpIDw9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIHN0YXJ0LnBhdGgpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIGVuZC5wYXRoKSA8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgYSByYW5nZSB3aXRoIGFub3RoZXIuXHJcbiAgICovXG4gIGludGVyc2VjdGlvbjogZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmFuZ2UuYW5jaG9yO1xuICAgICAgICByYW5nZS5mb2N1cztcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQyKTtcblxuICAgIHZhciBfUmFuZ2UkZWRnZXM5ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMxMCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczksIDIpLFxuICAgICAgICBzMSA9IF9SYW5nZSRlZGdlczEwWzBdLFxuICAgICAgICBlMSA9IF9SYW5nZSRlZGdlczEwWzFdO1xuXG4gICAgdmFyIF9SYW5nZSRlZGdlczExID0gUmFuZ2UuZWRnZXMoYW5vdGhlciksXG4gICAgICAgIF9SYW5nZSRlZGdlczEyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMTEsIDIpLFxuICAgICAgICBzMiA9IF9SYW5nZSRlZGdlczEyWzBdLFxuICAgICAgICBlMiA9IF9SYW5nZSRlZGdlczEyWzFdO1xuXG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuXG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNSh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGJhY2t3YXJkLCBtZWFuaW5nIHRoYXQgaXRzIGFuY2hvciBwb2ludCBhcHBlYXJzIGluIHRoZVxyXG4gICAqIGRvY3VtZW50IF9hZnRlcl8gaXRzIGZvY3VzIHBvaW50LlxyXG4gICAqL1xuICBpc0JhY2t3YXJkOiBmdW5jdGlvbiBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcixcbiAgICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICByZXR1cm4gUG9pbnQuaXNBZnRlcihhbmNob3IsIGZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGNvbGxhcHNlZCwgbWVhbmluZyB0aGF0IGJvdGggaXRzIGFuY2hvciBhbmQgZm9jdXNcclxuICAgKiBwb2ludHMgcmVmZXIgdG8gdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBpc0NvbGxhcHNlZDogZnVuY3Rpb24gaXNDb2xsYXBzZWQocmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleHBhbmRlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNDb2xsYXBzZWRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRXhwYW5kZWQ6IGZ1bmN0aW9uIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGZvcndhcmQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQmFja3dhcmRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRm9yd2FyZDogZnVuY3Rpb24gaXNGb3J3YXJkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIFtbUmFuZ2VdXSBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUmFuZ2U6IGZ1bmN0aW9uIGlzUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmFuY2hvcikgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5mb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgcG9pbnQgZW50cmllcyBpbiBhIHJhbmdlLlxyXG4gICAqL1xuICBwb2ludHM6IGZ1bmN0aW9uKiBwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChyYW5nZSkge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMxMyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMTQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMxMywgMSksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMTRbMF07XG5cbiAgICByZXR1cm4gc3RhcnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIGEgcmFuZ2UgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyYW5nZSwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIGltbWVyLnByb2R1Y2UocmFuZ2UsIGZ1bmN0aW9uIChyKSB7XG4gICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnaW53YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICAgICAgdmFyIGFmZmluaXR5QW5jaG9yO1xuICAgICAgdmFyIGFmZmluaXR5Rm9jdXM7XG5cbiAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2lud2FyZCcpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgbWFrZSBzdXJlIHRvIHVzZSB0aGUgc2FtZSBhZmZpbml0eSB0b1xuICAgICAgICAvLyBhdm9pZCB0aGUgdHdvIHBvaW50cyBwYXNzaW5nIGVhY2ggb3RoZXIgYW5kIGV4cGFuZGluZyBpbiB0aGUgb3Bwb3NpdGVcbiAgICAgICAgLy8gZGlyZWN0aW9uXG4gICAgICAgIHZhciBpc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHIpO1xuXG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdiYWNrd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2ZvcndhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnb3V0d2FyZCcpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2ZvcndhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnYmFja3dhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9IGFmZmluaXR5O1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gYWZmaW5pdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNob3IgPSBQb2ludC50cmFuc2Zvcm0oci5hbmNob3IsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUFuY2hvclxuICAgICAgfSk7XG4gICAgICB2YXIgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0oci5mb2N1cywgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5Rm9jdXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHIuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgci5mb2N1cyA9IGZvY3VzO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgUmFuZ2VSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcmFuZ2UgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgICBhZmZpbml0eSA9IHJlZi5hZmZpbml0eTtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IFJhbmdlLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxyXG4gKiBpbnRlcm5hbGx5IHdoZW4gZ2VuZXJhdGluZyBleGNlcHRpb25zIGNvbnRhaW5pbmcgZW5kIHVzZXIgZGF0YS4gRGV2ZWxvcGVyc1xyXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXHJcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XHJcbiAqXHJcbiAqICAgIGltcG9ydCB7IFNjcnViYmVyIH0gZnJvbSAnc2xhdGUnO1xyXG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcclxuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXHJcbiAqICAgICAgcmV0dXJuIHZhbFxyXG4gKiAgICB9KTtcclxuICpcclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXI6IGZ1bmN0aW9uIHNldFNjcnViYmVyKHNjcnViYmVyKSB7XG4gICAgX3NjcnViYmVyID0gc2NydWJiZXI7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBfc2NydWJiZXIpO1xuICB9XG59O1xuXG4vKlxyXG4gIEN1c3RvbSBkZWVwIGVxdWFsIGNvbXBhcmlzb24gZm9yIFNsYXRlIG5vZGVzLlxyXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcclxuICBTbGF0ZSBvbmx5IHN1cHBvcnRzIHBsYWluIHZhbHVlcywgQXJyYXlzLCBhbmQgbmVzdGVkIG9iamVjdHMuXHJcbiAgQ29tcGxleCB2YWx1ZXMgbmVzdGVkIGluc2lkZSBBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xyXG4gIG1pc3Npbmcga2V5cyBhcmUgZGVsaWJlcmF0ZWx5IG5vcm1hbGlzZWQgdG8gdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIGlzRGVlcEVxdWFsID0gZnVuY3Rpb24gaXNEZWVwRXF1YWwobm9kZSwgYW5vdGhlcikge1xuICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgIHZhciBhID0gbm9kZVtrZXldO1xuICAgIHZhciBiID0gYW5vdGhlcltrZXldO1xuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWwoYSwgYikpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEgIT09IGIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLypcclxuICAgIERlZXAgb2JqZWN0IGVxdWFsaXR5IGlzIG9ubHkgbmVjZXNzYXJ5IGluIG9uZSBkaXJlY3Rpb247IGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxyXG4gICAgQXMgYWJvdmUsIHVuZGVmaW5lZCBrZXlzIGFyZSBub3JtYWxpc2VkIHRvIG1pc3NpbmcuXHJcbiAgKi9cblxuXG4gIGZvciAodmFyIF9rZXkgaW4gYW5vdGhlcikge1xuICAgIGlmIChub2RlW19rZXldID09PSB1bmRlZmluZWQgJiYgYW5vdGhlcltfa2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIkMSA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQzKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBvd25LZXlzJDQob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFRleHQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHR3byB0ZXh0IG5vZGVzIGFyZSBlcXVhbC5cclxuICAgKlxyXG4gICAqIFdoZW4gbG9vc2UgaXMgc2V0LCB0aGUgdGV4dCBpcyBub3QgY29tcGFyZWQuIFRoaXMgaXNcclxuICAgKiB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgc2libGluZyB0ZXh0IG5vZGVzIGNhbiBiZSBtZXJnZWQuXHJcbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHRleHQsIGFub3RoZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGxvb3NlID0gb3B0aW9ucy5sb29zZSxcbiAgICAgICAgbG9vc2UgPSBfb3B0aW9ucyRsb29zZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRsb29zZTtcblxuICAgIGZ1bmN0aW9uIG9taXRUZXh0KG9iaikge1xuICAgICAgb2JqLnRleHQ7XG4gICAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBfZXhjbHVkZWQkMSk7XG5cbiAgICAgIHJldHVybiByZXN0O1xuICAgIH1cblxuICAgIHJldHVybiBpc0RlZXBFcXVhbChsb29zZSA/IG9taXRUZXh0KHRleHQpIDogdGV4dCwgbG9vc2UgPyBvbWl0VGV4dChhbm90aGVyKSA6IGFub3RoZXIpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFRleHRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNUZXh0OiBmdW5jdGlvbiBpc1RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYFRleHRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzVGV4dExpc3Q6IGZ1bmN0aW9uIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgc29tZSBwcm9wcyBhcmUgYSBwYXJ0aWFsIG9mIFRleHQuXHJcbiAgICovXG4gIGlzVGV4dFByb3BzOiBmdW5jdGlvbiBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gdGV4dCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBpcyBmb3IgbWF0Y2hpbmcgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdFxyXG4gICAqIHRoZSBgdGV4dGAgcHJvcGVydHkgYXJlIHR3byBub2RlcyBlcXVhbC5cclxuICAgKi9cbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyh0ZXh0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRleHQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0ZXh0W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGVhdmVzIGZvciBhIHRleHQgbm9kZSBnaXZlbiBkZWNvcmF0aW9ucy5cclxuICAgKi9cbiAgZGVjb3JhdGlvbnM6IGZ1bmN0aW9uIGRlY29yYXRpb25zKG5vZGUsIF9kZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbX29iamVjdFNwcmVhZCQ0KHt9LCBub2RlKV07XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhfZGVjb3JhdGlvbnMpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgZGVjID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgdmFyIGFuY2hvciA9IGRlYy5hbmNob3IsXG4gICAgICAgICAgICBmb2N1cyA9IGRlYy5mb2N1cyxcbiAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBfZXhjbHVkZWQyJDEpO1xuXG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhkZWMpLFxuICAgICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICAgIHZhciBsZWFmRW5kID0gMDtcbiAgICAgICAgdmFyIGRlY29yYXRpb25TdGFydCA9IHN0YXJ0Lm9mZnNldDtcbiAgICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhsZWF2ZXMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsZWFmID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxlYWYudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgICAgIGxlYWZFbmQgKz0gbGVuZ3RoOyAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuXG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0IDw9IGxlYWZTdGFydCAmJiBsZWFmRW5kIDw9IGRlY29yYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWFmLCByZXN0KTtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG5cblxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCAhPT0gZGVjb3JhdGlvbkVuZCAmJiAoZGVjb3JhdGlvblN0YXJ0ID09PSBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCkgfHwgZGVjb3JhdGlvblN0YXJ0ID4gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kIDwgbGVhZlN0YXJ0IHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCAmJiBsZWFmU3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmFuZ2UgdG8gdGhlIG1pZGRsZSBpbnRlcnNlY3Rpbmcgc2VjdGlvbi4gRG8gdGhlIGVuZFxuICAgICAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cblxuXG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gbGVhZjtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uRW5kIDwgbGVhZkVuZCkge1xuICAgICAgICAgICAgICB2YXIgb2ZmID0gZGVjb3JhdGlvbkVuZCAtIGxlYWZTdGFydDtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKG9mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgb2ZmKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA+IGxlYWZTdGFydCkge1xuICAgICAgICAgICAgICB2YXIgX29mZiA9IGRlY29yYXRpb25TdGFydCAtIGxlYWZTdGFydDtcblxuICAgICAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIF9vZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKF9vZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1pZGRsZSwgcmVzdCk7XG5cbiAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDIoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBhcHBseVRvRHJhZnQgPSBmdW5jdGlvbiBhcHBseVRvRHJhZnQoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBhdGggPSBvcC5wYXRoLFxuICAgICAgICAgICAgbm9kZSA9IG9wLm5vZGU7XG4gICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBcXFwiaW5zZXJ0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgbm9kZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgbm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgcG9pbnQgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGggPSBvcC5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0ID0gb3Aub2Zmc2V0LFxuICAgICAgICAgICAgdGV4dCA9IG9wLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGgpO1xuXG4gICAgICAgIHZhciBiZWZvcmUgPSBfbm9kZS50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIF9ub2RlLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludCA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXkgPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDIgPSBvcC5wYXRoO1xuXG4gICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldiA9IE5vZGUuZ2V0KGVkaXRvciwgcHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTIpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi50ZXh0ICs9IF9ub2RlMi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTIpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHZhciBfcHJldiRjaGlsZHJlbjtcblxuICAgICAgICAgIChfcHJldiRjaGlsZHJlbiA9IHByZXYuY2hpbGRyZW4pLnB1c2guYXBwbHkoX3ByZXYkY2hpbGRyZW4sIF90b0NvbnN1bWFibGVBcnJheShfbm9kZTIuY2hpbGRyZW4pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwibWVyZ2Vfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDIsIFwiXSB0byBub2RlcyBvZiBkaWZmZXJlbnQgaW50ZXJmYWNlczogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25vZGUyKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldikpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleCwgMSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludDIgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5MiA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDMgPSBvcC5wYXRoLFxuICAgICAgICAgICAgbmV3UGF0aCA9IG9wLm5ld1BhdGg7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihfcGF0aDMsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vdmUgYSBwYXRoIFtcIi5jb25jYXQoX3BhdGgzLCBcIl0gdG8gbmV3IHBhdGggW1wiKS5jb25jYXQobmV3UGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIGluc2lkZSBpdHNlbGYuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTMgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQyID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgIHZhciBfaW5kZXgyID0gX3BhdGgzW19wYXRoMy5sZW5ndGggLSAxXTsgLy8gVGhpcyBpcyB0cmlja3ksIGJ1dCBzaW5jZSB0aGUgYHBhdGhgIGFuZCBgbmV3UGF0aGAgYm90aCByZWZlciB0b1xuICAgICAgICAvLyB0aGUgc2FtZSBzbmFwc2hvdCBpbiB0aW1lLCB0aGVyZSdzIGEgbWlzbWF0Y2guIEFmdGVyIGVpdGhlclxuICAgICAgICAvLyByZW1vdmluZyB0aGUgb3JpZ2luYWwgcG9zaXRpb24sIHRoZSBzZWNvbmQgc3RlcCdzIHBhdGggY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBkYXRlLiBTbyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgb3AubmV3UGF0aGAgZGlyZWN0bHksIHdlXG4gICAgICAgIC8vIHRyYW5zZm9ybSBgb3AucGF0aGAgdG8gYXNjZXJ0YWluIHdoYXQgdGhlIGBuZXdQYXRoYCB3b3VsZCBiZSBhZnRlclxuICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIHdhcyBhcHBsaWVkLlxuXG4gICAgICAgIF9wYXJlbnQyLmNoaWxkcmVuLnNwbGljZShfaW5kZXgyLCAxKTtcblxuICAgICAgICB2YXIgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShfcGF0aDMsIG9wKTtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQodHJ1ZVBhdGgpKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIG5ld1BhcmVudC5jaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIF9ub2RlMyk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludDMgPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5MyA9IF9zdGVwNCR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNCA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBfaW5kZXgzID0gX3BhdGg0W19wYXRoNC5sZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgX3BhcmVudDMgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNCk7XG5cbiAgICAgICAgX3BhcmVudDMuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDMsIDEpOyAvLyBUcmFuc2Zvcm0gYWxsIG9mIHRoZSBwb2ludHMgaW4gdGhlIHZhbHVlLCBidXQgaWYgdGhlIHBvaW50IHdhcyBpbiB0aGVcbiAgICAgICAgLy8gbm9kZSB0aGF0IHdhcyByZW1vdmVkIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByYW5nZSBvciByZW1vdmUgaXQuXG5cblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDUudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgX3BvaW50NCA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXk0ID0gX3N0ZXA1JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcmV2ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoTm9kZS50ZXh0cyhlZGl0b3IpKSxcbiAgICAgICAgICAgICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBfc3RlcDYkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFBhdGguY29tcGFyZShwLCBfcGF0aDQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJlZmVyTmV4dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXh0WzFdLCBfcGF0aDQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSBQYXRoLmNvbW1vbihfcHJldlsxXSwgX3BhdGg0KS5sZW5ndGggPCBQYXRoLmNvbW1vbihuZXh0WzFdLCBfcGF0aDQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgIXByZWZlck5leHQpIHtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSBfcHJldlswXS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IG5leHRbMV07XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDUgPSBvcC5wYXRoLFxuICAgICAgICAgICAgX29mZnNldCA9IG9wLm9mZnNldCxcbiAgICAgICAgICAgIF90ZXh0ID0gb3AudGV4dDtcbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG5cbiAgICAgICAgdmFyIF9iZWZvcmUgPSBfbm9kZTQudGV4dC5zbGljZSgwLCBfb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU0LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwNyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQ1ID0gX3N0ZXA3JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleTUgPSBfc3RlcDckdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDYgPSBvcC5wYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcblxuICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG5cbiAgICAgICAgZm9yICh2YXIgX2tleTYgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk2XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2tleTcgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGlmICghbmV3UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfa2V5NykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICB7XG4gICAgICAgIHZhciBfbmV3UHJvcGVydGllcyA9IG9wLm5ld1Byb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3Rpb24gPSBfbmV3UHJvcGVydGllcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25ld1Byb3BlcnRpZXMpLCBcIiB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2VsZWN0aW9uLlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQkMyh7fSwgX25ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9rZXk4IGluIF9uZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgX3ZhbHVlID0gX25ld1Byb3BlcnRpZXNbX2tleThdO1xuXG4gICAgICAgICAgICBpZiAoX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKF9rZXk4ID09PSAnYW5jaG9yJyB8fCBfa2V5OCA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIFxcXCJcIi5jb25jYXQoX2tleTgsIFwiXFxcIiBzZWxlY3Rpb24gcHJvcGVydHlcIikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGlvbltfa2V5OF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleThdID0gX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDcgPSBvcC5wYXRoLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIF9wcm9wZXJ0aWVzID0gb3AucHJvcGVydGllcztcblxuICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJzcGxpdF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoNywgXCJdIGJlY2F1c2UgdGhlIHJvb3Qgbm9kZSBjYW5ub3QgYmUgc3BsaXQuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTYgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQ0ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgIHZhciBfaW5kZXg0ID0gX3BhdGg3W19wYXRoNy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld05vZGU7XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlNikpIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTIgPSBfbm9kZTYudGV4dC5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyMiA9IF9ub2RlNi50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgIF9ub2RlNi50ZXh0ID0gX2JlZm9yZTI7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IF9hZnRlcjJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgdmFyIF9hZnRlcjMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgX25vZGU2LmNoaWxkcmVuID0gX2JlZm9yZTM7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfYWZ0ZXIzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFyZW50NC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4NCArIDEsIDAsIG5ld05vZGUpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDg7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQ2ID0gX3N0ZXA4JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleTkgPSBfc3RlcDgkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBHZW5lcmFsVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBlZGl0b3IgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShlZGl0b3IsIG9wKSB7XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gaW1tZXIuY3JlYXRlRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBpbW1lci5jcmVhdGVEcmFmdChlZGl0b3Iuc2VsZWN0aW9uKTtcblxuICAgIHRyeSB7XG4gICAgICBzZWxlY3Rpb24gPSBhcHBseVRvRHJhZnQoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZWRpdG9yLmNoaWxkcmVuID0gaW1tZXIuZmluaXNoRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gaW1tZXIuaXNEcmFmdChzZWxlY3Rpb24pID8gaW1tZXIuZmluaXNoRHJhZnQoc2VsZWN0aW9uKSA6IHNlbGVjdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIE5vZGVUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBJbnNlcnQgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnROb2RlczogZnVuY3Rpb24gaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmcgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZyxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcyxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU7XG4gICAgICB2YXIgYXQgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBzZWxlY3QgPSBvcHRpb25zLnNlbGVjdDtcblxuICAgICAgaWYgKE5vZGUuaXNOb2RlKG5vZGVzKSkge1xuICAgICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX25vZGVzID0gbm9kZXMsXG4gICAgICAgICAgX25vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9ub2RlcywgMSksXG4gICAgICAgICAgbm9kZSA9IF9ub2RlczJbMF07IC8vIEJ5IGRlZmF1bHQsIHVzZSB0aGUgc2VsZWN0aW9uIGFzIHRoZSB0YXJnZXQgbG9jYXRpb24uIEJ1dCBpZiB0aGVyZSBpc1xuICAgICAgLy8gbm8gc2VsZWN0aW9uLCBpbnNlcnQgYXQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQgc2luY2UgdGhhdCBpcyBzdWNoIGFcbiAgICAgIC8vIGNvbW1vbiB1c2UgY2FzZSB3aGVuIGluc2VydGluZyBmcm9tIGEgbm9uLXNlbGVjdGVkIHN0YXRlLlxuXG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXQgPSBbMF07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSksXG4gICAgICAgICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgICAgICAgZW50cnkgPSBfRWRpdG9yJG5vZGVzMlswXTtcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgX2VudHJ5ID0gX3NsaWNlZFRvQXJyYXkoZW50cnksIDIpLFxuICAgICAgICAgICAgICBfbWF0Y2hQYXRoID0gX2VudHJ5WzFdO1xuXG4gICAgICAgICAgdmFyIHBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIF9tYXRjaFBhdGgpO1xuICAgICAgICAgIHZhciBpc0F0RW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIF9tYXRjaFBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgICBhdCA9IGlzQXRFbmQgPyBQYXRoLm5leHQocGF0aCkgOiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KGF0KTtcbiAgICAgIHZhciBpbmRleCA9IGF0W2F0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXJlbnRQYXRoXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG5vZGVzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX25vZGUgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcGF0aCA9IHBhcmVudFBhdGguY29uY2F0KGluZGV4KTtcblxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgIG5vZGU6IF9ub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGF0ID0gUGF0aC5wcmV2aW91cyhhdCk7XG5cbiAgICAgIGlmIChzZWxlY3QpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcblxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIExpZnQgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiB1cHdhcmRzIGluIHRoZSBkb2N1bWVudCB0cmVlLCBzcGxpdHRpbmdcclxuICAgKiB0aGVpciBwYXJlbnQgaW4gdHdvIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbGlmdE5vZGVzOiBmdW5jdGlvbiBsaWZ0Tm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlMiA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTIgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTIsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHMyID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczI7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWYyWzFdO1xuXG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX3BhdGhSZWZzID0gcGF0aFJlZnM7IF9pIDwgX3BhdGhSZWZzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGF0aFJlZiA9IF9wYXRoUmVmc1tfaV07XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcblxuICAgICAgICB2YXIgX3BhcmVudE5vZGVFbnRyeSA9IF9zbGljZWRUb0FycmF5KHBhcmVudE5vZGVFbnRyeSwgMiksXG4gICAgICAgICAgICBwYXJlbnQgPSBfcGFyZW50Tm9kZUVudHJ5WzBdLFxuICAgICAgICAgICAgcGFyZW50UGF0aCA9IF9wYXJlbnROb2RlRW50cnlbMV07XG5cbiAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFyIHRvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHRvUGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiBwYXJlbnRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YXIgX3RvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogX3RvUGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiBfdG9QYXRoMixcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWVyZ2UgYSBub2RlIGF0IGEgbG9jYXRpb24gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBvZiB0aGUgc2FtZSBkZXB0aCxcclxuICAgKiByZW1vdmluZyBhbnkgZW1wdHkgY29udGFpbmluZyBub2RlcyBhZnRlciB0aGUgbWVyZ2UgaWYgbmVjZXNzYXJ5LlxyXG4gICAqL1xuICBtZXJnZU5vZGVzOiBmdW5jdGlvbiBtZXJnZU5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBfb3B0aW9ucyRhdDIgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQyID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQyO1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmcyID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nMixcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMyxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlMyA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTMgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDEpLFxuICAgICAgICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDJbMF07XG5cbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNFsxXTtcblxuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX0VkaXRvciRub2RlczMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pLFxuICAgICAgICAgIF9FZGl0b3Ikbm9kZXM0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlczMsIDEpLFxuICAgICAgICAgIGN1cnJlbnQgPSBfRWRpdG9yJG5vZGVzNFswXTtcblxuICAgICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2N1cnJlbnQgPSBfc2xpY2VkVG9BcnJheShjdXJyZW50LCAyKSxcbiAgICAgICAgICBub2RlID0gX2N1cnJlbnRbMF0sXG4gICAgICAgICAgcGF0aCA9IF9jdXJyZW50WzFdO1xuXG4gICAgICB2YXIgX3ByZXYgPSBfc2xpY2VkVG9BcnJheShwcmV2LCAyKSxcbiAgICAgICAgICBwcmV2Tm9kZSA9IF9wcmV2WzBdLFxuICAgICAgICAgIHByZXZQYXRoID0gX3ByZXZbMV07XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KSwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAxKSxcbiAgICAgICAgICAgIG4gPSBfcmVmNFswXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0pLnNsaWNlKGNvbW1vblBhdGgubGVuZ3RoKS5zbGljZSgwLCAtMSk7IC8vIERldGVybWluZSBpZiB0aGUgbWVyZ2Ugd2lsbCBsZWF2ZSBhbiBhbmNlc3RvciBvZiB0aGUgcGF0aCBlbXB0eSBhcyBhXG4gICAgICAvLyByZXN1bHQsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byByZW1vdmUgaXQgYWZ0ZXIgbWVyZ2luZy5cblxuICAgICAgdmFyIGVtcHR5QW5jZXN0b3IgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIGxldmVscy5pbmNsdWRlcyhuKSAmJiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSk7XG4gICAgICB2YXIgcHJvcGVydGllcztcbiAgICAgIHZhciBwb3NpdGlvbjsgLy8gRW5zdXJlIHRoYXQgdGhlIG5vZGVzIGFyZSBlcXVpdmFsZW50LCBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBwb3NpdGlvblxuICAgICAgLy8gYW5kIGV4dHJhIHByb3BlcnRpZXMgb2YgdGhlIG1lcmdlIHdpbGwgYmUuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0LmlzVGV4dChwcmV2Tm9kZSkpIHtcbiAgICAgICAgbm9kZS50ZXh0O1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLnRleHQubGVuZ3RoO1xuICAgICAgICBwcm9wZXJ0aWVzID0gcmVzdDtcbiAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSBfcmVzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0aGUgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIHdpdGggdGhlIHByZXZpb3VzIHNpYmxpbmcgYmVjYXVzZSBpdCBpcyBub3QgdGhlIHNhbWUga2luZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXZOb2RlKSkpO1xuICAgICAgfSAvLyBJZiB0aGUgbm9kZSBpc24ndCBhbHJlYWR5IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIHByZXZpb3VzIG5vZGUsIG1vdmVcbiAgICAgIC8vIGl0IHNvIHRoYXQgaXQgaXMgYmVmb3JlIG1lcmdpbmcuXG5cblxuICAgICAgaWYgKCFpc1ByZXZpb3VzU2libGluZykge1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogbmV3UGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZXJlIHdhcyBnb2luZyB0byBiZSBhbiBlbXB0eSBhbmNlc3RvciBvZiB0aGUgbm9kZSB0aGF0IHdhcyBtZXJnZWQsXG4gICAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cblxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW1wdHlSZWYuY3VycmVudCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAgICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4gICAgICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnICYmIHByZXZQYXRoW3ByZXZQYXRoLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHByZXZQYXRoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgICBlbXB0eVJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gdG8gYSBuZXcgbG9jYXRpb24uXHJcbiAgICovXG4gIG1vdmVOb2RlczogZnVuY3Rpb24gbW92ZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdG8gPSBvcHRpb25zLnRvLFxuICAgICAgICAgIF9vcHRpb25zJGF0MyA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDMgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDMsXG4gICAgICAgICAgX29wdGlvbnMkbW9kZTQgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU0ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU0LFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzNCA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM0O1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICAgICAgICBwID0gX3JlZjZbMV07XG5cbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3BhdGhSZWZzMiA9IHBhdGhSZWZzOyBfaTIgPCBfcGF0aFJlZnMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHBhdGhSZWYgPSBfcGF0aFJlZnMyW19pMl07XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgbmV3UGF0aCA9IHRvUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3ZlX25vZGUnLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGg6IG5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b1JlZi5jdXJyZW50ICYmIFBhdGguaXNTaWJsaW5nKG5ld1BhdGgsIHBhdGgpICYmIFBhdGguaXNBZnRlcihuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIHNpYmxpbmcgbW92ZSB0byBhIGxhdGVyIGluZGV4LCB0aGUgcGF0aCBhdCB0aGUgZGVzdGluYXRpb24gaXMgc2hpZnRlZFxuICAgICAgICAgIC8vIHRvIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIHBvaW50IGluc3RlYWQgb2YgYWZ0ZXIuIFRvIGVuc3VyZSBvdXIgZ3JvdXAgb2Ygbm9kZXMgYXJlIGluc2VydGVkXG4gICAgICAgICAgLy8gaW4gdGhlIGNvcnJlY3Qgb3JkZXIgd2UgaW5jcmVtZW50IHRvUmVmIHRvIGFjY291bnQgZm9yIHRoYXRcbiAgICAgICAgICB0b1JlZi5jdXJyZW50ID0gUGF0aC5uZXh0KHRvUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvUmVmLnVucmVmKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgcmVtb3ZlTm9kZXM6IGZ1bmN0aW9uIHJlbW92ZU5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmczID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nMyxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczUgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM1ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNSxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlNSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTU7XG4gICAgICB2YXIgX29wdGlvbnMkYXQ0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0NCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NCxcbiAgICAgICAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGhzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20oZGVwdGhzLCBmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWY4WzFdO1xuXG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9wYXRoUmVmczMgPSBwYXRoUmVmczsgX2kzIDwgX3BhdGhSZWZzMy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciBwYXRoUmVmID0gX3BhdGhSZWZzM1tfaTNdO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBfRWRpdG9yJG5vZGUgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgICAgICBfRWRpdG9yJG5vZGUyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlLCAxKSxcbiAgICAgICAgICAgICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF07XG5cbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHNldE5vZGVzOiBmdW5jdGlvbiBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICAgIF9vcHRpb25zJGF0NSA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDUgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDUsXG4gICAgICAgICAgY29tcGFyZSA9IG9wdGlvbnMuY29tcGFyZSxcbiAgICAgICAgICBtZXJnZSA9IG9wdGlvbnMubWVyZ2U7XG4gICAgICB2YXIgX29wdGlvbnMkaGFuZ2luZzQgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmc0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmc0LFxuICAgICAgICAgIF9vcHRpb25zJG1vZGU2ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlNiA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlNixcbiAgICAgICAgICBfb3B0aW9ucyRzcGxpdCA9IG9wdGlvbnMuc3BsaXQsXG4gICAgICAgICAgc3BsaXQgPSBfb3B0aW9ucyRzcGxpdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzcGxpdCxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczYgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM2ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNjtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpICYmIEVkaXRvci5sZWFmKGVkaXRvciwgYXQuYW5jaG9yKVswXS50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkIGluIGEgbm9uLWVtcHR5IG5vZGUgYW5kICdzcGxpdCcgaXMgdHJ1ZSwgdGhlcmUncyBub3RoaW5nIHRvXG4gICAgICAgICAgLy8gc2V0IHRoYXQgd29uJ3QgZ2V0IG5vcm1hbGl6ZWQgYXdheVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXM1ID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgX1JhbmdlJGVkZ2VzNiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczUsIDIpLFxuICAgICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM2WzBdLFxuICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNlsxXTtcblxuICAgICAgICB2YXIgc3BsaXRNb2RlID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JztcbiAgICAgICAgdmFyIGVuZEF0RW5kT2ZOb2RlID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgZW5kLCBlbmQucGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICAgIGFsd2F5czogIWVuZEF0RW5kT2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3RhcnRBdFN0YXJ0T2ZOb2RlID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBzdGFydCwgc3RhcnQucGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShwcm9wLCBub2RlUHJvcCkge1xuICAgICAgICAgIHJldHVybiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSkpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgbm9kZSA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgcGF0aCA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhhc0NoYW5nZXMgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlOyAvLyBPbWl0IG5ldyBwcm9wZXJ0aWVzIGZyb20gdGhlIG9sZCBwcm9wZXJ0aWVzIGxpc3RcblxuICAgICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrKSkgcHJvcGVydGllc1trXSA9IG5vZGVba107IC8vIE9taXQgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG5ldyBwcm9wZXJ0aWVzIGxpc3RcblxuICAgICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IG1lcmdlKG5vZGVba10sIHByb3BzW2tdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU3BsaXQgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXHJcbiAgICovXG4gIHNwbGl0Tm9kZXM6IGZ1bmN0aW9uIHNwbGl0Tm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkbW9kZTcgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU3ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU3LFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzNyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM3O1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBfb3B0aW9ucyRhdDYgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQ2ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ2LFxuICAgICAgICAgIF9vcHRpb25zJGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICAgIGhlaWdodCA9IF9vcHRpb25zJGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJGhlaWdodCxcbiAgICAgICAgICBfb3B0aW9ucyRhbHdheXMgPSBvcHRpb25zLmFsd2F5cyxcbiAgICAgICAgICBhbHdheXMgPSBfb3B0aW9ucyRhbHdheXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx3YXlzO1xuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gZGVsZXRlUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgaXMgYSBwYXRoLCB0aGUgZGVmYXVsdCBoZWlnaHQtc2tpcHBpbmcgYW5kIHBvc2l0aW9uXG4gICAgICAvLyBjb3VudGVycyBuZWVkIHRvIGFjY291bnQgZm9yIHVzIHBvdGVudGlhbGx5IHNwbGl0dGluZyBhdCBhIG5vbi1sZWFmLlxuXG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIHBhdGggPSBhdDtcbiAgICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50MyA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50MywgMSksXG4gICAgICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDRbMF07XG5cbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIG4gPT09IHBhcmVudDtcbiAgICAgICAgfTtcblxuICAgICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgYXQgPSBwb2ludDtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJSZWY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfRWRpdG9yJG5vZGVzNSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgX0VkaXRvciRub2RlczYgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzNSwgMSksXG4gICAgICAgICAgICBoaWdoZXN0ID0gX0VkaXRvciRub2RlczZbMF07XG5cbiAgICAgICAgaWYgKCFoaWdoZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZvaWRNYXRjaCA9IEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG51ZGdlID0gMDtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIHZvaWRNYXRjaCkge1xuICAgICAgICAgIHZhciBfdm9pZE1hdGNoID0gX3NsaWNlZFRvQXJyYXkodm9pZE1hdGNoLCAyKSxcbiAgICAgICAgICAgICAgdm9pZE5vZGUgPSBfdm9pZE1hdGNoWzBdLFxuICAgICAgICAgICAgICB2b2lkUGF0aCA9IF92b2lkTWF0Y2hbMV07XG5cbiAgICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQodm9pZE5vZGUpICYmIGVkaXRvci5pc0lubGluZSh2b2lkTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIHZvaWRQYXRoKTtcblxuICAgICAgICAgICAgaWYgKCFhZnRlcikge1xuICAgICAgICAgICAgICB2YXIgdGV4dCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2YXIgYWZ0ZXJQYXRoID0gUGF0aC5uZXh0KHZvaWRQYXRoKTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHRleHQsIHtcbiAgICAgICAgICAgICAgICBhdDogYWZ0ZXJQYXRoLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG5cbiAgICAgICAgdmFyIF9oaWdoZXN0ID0gX3NsaWNlZFRvQXJyYXkoaGlnaGVzdCwgMiksXG4gICAgICAgICAgICBoaWdoZXN0UGF0aCA9IF9oaWdoZXN0WzFdO1xuXG4gICAgICAgIHZhciBsb3dlc3RQYXRoID0gYXQucGF0aC5zbGljZSgwLCBkZXB0aCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGhlaWdodCA9PT0gMCA/IGF0Lm9mZnNldCA6IGF0LnBhdGhbZGVwdGhdICsgbnVkZ2U7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSkpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIG5vZGUgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgX3BhdGgyID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKF9wYXRoMi5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgyLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX3BvaW50MiA9IGJlZm9yZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50MiwgX3BhdGgyKTtcblxuICAgICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50MiwgX3BhdGgyKSkge1xuICAgICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gTm9kZS5leHRyYWN0UHJvcHMobm9kZSk7XG4gICAgICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICAgIHBhdGg6IF9wYXRoMixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24gPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdICsgKHNwbGl0IHx8IGlzRW5kID8gMSA6IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wb2ludCA9IGFmdGVyUmVmLmN1cnJlbnQgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdmFyIF9hZnRlclJlZjtcblxuICAgICAgICBiZWZvcmVSZWYudW5yZWYoKTtcbiAgICAgICAgKF9hZnRlclJlZiA9IGFmdGVyUmVmKSA9PT0gbnVsbCB8fCBfYWZ0ZXJSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hZnRlclJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVuc2V0IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHVuc2V0Tm9kZXM6IGZ1bmN0aW9uIHVuc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgIHByb3BzID0gW3Byb3BzXTtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEocHJvcHMpLFxuICAgICAgICBfc3RlcDQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGtleSA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgb2JqW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBmcm9tIGEgcGFyZW50IG5vZGUsIHNwbGl0dGluZyB0aGUgcGFyZW50IGlmXHJcbiAgICogbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHVud3JhcHBlZC5cclxuICAgKi9cbiAgdW53cmFwTm9kZXM6IGZ1bmN0aW9uIHVud3JhcE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJG1vZGU4ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlOCA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlOCxcbiAgICAgICAgICBfb3B0aW9ucyRzcGxpdDIgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgICAgIHNwbGl0ID0gX29wdGlvbnMkc3BsaXQyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0MixcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczggPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM4ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzODtcbiAgICAgIHZhciBfb3B0aW9ucyRhdDcgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQ3ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ3LFxuICAgICAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICAgICAgdmFyIF9yZWYxMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5LCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmMTBbMV07XG5cbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9IC8vIHVud3JhcE5vZGUgd2lsbCBjYWxsIGxpZnROb2RlIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgc3BsaXR0aW5nIHRoZSBub2RlIHdoZW4gbmVzdGVkLlxuICAgICAgLy8gSWYgd2UgZG8gbm90IHJldmVyc2UgdGhlIG9yZGVyIGFuZCBjYWxsIGl0IGZyb20gdG9wIHRvIHRoZSBib3R0b20sIGl0IHdpbGwgcmVtb3ZlIGFsbCBibG9ja3NcbiAgICAgIC8vIHRoYXQgd3JhcCB0YXJnZXQgbm9kZS4gU28gd2UgcmV2ZXJzZSB0aGUgb3JkZXIuXG4gICAgICApLnJldmVyc2UoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKHBhdGhSZWZzKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZTMgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgICAgICBfRWRpdG9yJG5vZGU0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlMywgMSksXG4gICAgICAgICAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGU0WzBdO1xuXG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgICBpZiAoc3BsaXQgJiYgcmFuZ2VSZWYpIHtcbiAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlUmVmLmN1cnJlbnQsIHJhbmdlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLmxpZnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgICAgcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBXcmFwIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIGluIGEgbmV3IGNvbnRhaW5lciBub2RlLCBzcGxpdHRpbmcgdGhlIGVkZ2VzXHJcbiAgICogb2YgdGhlIHJhbmdlIGZpcnN0IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHdyYXBwZWQuXHJcbiAgICovXG4gIHdyYXBOb2RlczogZnVuY3Rpb24gd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJG1vZGU5ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlOSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlOSxcbiAgICAgICAgICBfb3B0aW9ucyRzcGxpdDMgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgICAgIHNwbGl0ID0gX29wdGlvbnMkc3BsaXQzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0MyxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczkgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzOTtcbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgICAgX29wdGlvbnMkYXQ4ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0OCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0ODtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChlZGl0b3IsIGF0KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkpIHtcbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSB8fCBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlczcgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICBfUmFuZ2UkZWRnZXM4ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNywgMiksXG4gICAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczhbMF0sXG4gICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM4WzFdO1xuXG4gICAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFZGl0b3IuaXNFZGl0b3Iobik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pKTtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX3Jvb3RzID0gcm9vdHM7IF9pNCA8IF9yb290cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBfcm9vdHMkX2kgPSBfc2xpY2VkVG9BcnJheShfcm9vdHNbX2k0XSwgMiksXG4gICAgICAgICAgICByb290UGF0aCA9IF9yb290cyRfaVsxXTtcblxuICAgICAgICB2YXIgYSA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gUmFuZ2UuaW50ZXJzZWN0aW9uKGF0LCBFZGl0b3IucmFuZ2UoZWRpdG9yLCByb290UGF0aCkpIDogYXQ7XG5cbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0Y2hlcyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVzID0gX3NsaWNlZFRvQXJyYXkobWF0Y2hlcywgMSksXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBfbWF0Y2hlc1swXTtcblxuICAgICAgICAgICAgdmFyIGxhc3QgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIHZhciBfZmlyc3QgPSBfc2xpY2VkVG9BcnJheShmaXJzdCwgMiksXG4gICAgICAgICAgICAgICAgZmlyc3RQYXRoID0gX2ZpcnN0WzFdO1xuXG4gICAgICAgICAgICB2YXIgX2xhc3QgPSBfc2xpY2VkVG9BcnJheShsYXN0LCAyKSxcbiAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IF9sYXN0WzFdO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RQYXRoLmxlbmd0aCA9PT0gMCAmJiBsYXN0UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtYXRjaGluZyBwYXJlbnQgLSB1c3VhbGx5IG1lYW5zIHRoZSBub2RlIGlzIGFuIGVkaXRvciAtIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5lcXVhbHMoZmlyc3RQYXRoLCBsYXN0UGF0aCkgPyBQYXRoLnBhcmVudChmaXJzdFBhdGgpIDogUGF0aC5jb21tb24oZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICAgIHZhciBjb21tb25Ob2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGNvbW1vblBhdGgpO1xuXG4gICAgICAgICAgICB2YXIgX2NvbW1vbk5vZGVFbnRyeSA9IF9zbGljZWRUb0FycmF5KGNvbW1vbk5vZGVFbnRyeSwgMSksXG4gICAgICAgICAgICAgICAgY29tbW9uTm9kZSA9IF9jb21tb25Ob2RlRW50cnlbMF07XG5cbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGNvbW1vblBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyUGF0aCA9IFBhdGgubmV4dChsYXN0UGF0aC5zbGljZSgwLCBkZXB0aCkpO1xuXG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgd3JhcHBlciwge1xuICAgICAgICAgICAgICBhdDogd3JhcHBlclBhdGgsXG4gICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaGFzU2luZ2xlQ2hpbGROZXN0ID0gZnVuY3Rpb24gaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbm9kZSkge1xuICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG5cbiAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgZWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuLyoqXHJcbiAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgcG9pbnQgYnkgZGVsZXRpbmcgaXQncyBjb250ZW50LlxyXG4gKi9cblxuXG52YXIgZGVsZXRlUmFuZ2UgPSBmdW5jdGlvbiBkZWxldGVSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2UuYW5jaG9yO1xuICB9IGVsc2Uge1xuICAgIHZhciBfUmFuZ2UkZWRnZXM5ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMxMCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczksIDIpLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMxMFsxXTtcblxuICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gZnVuY3Rpb24gbWF0Y2hQYXRoKGVkaXRvciwgcGF0aCkge1xuICB2YXIgX0VkaXRvciRub2RlNSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCksXG4gICAgICBfRWRpdG9yJG5vZGU2ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlNSwgMSksXG4gICAgICBub2RlID0gX0VkaXRvciRub2RlNlswXTtcblxuICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbiA9PT0gbm9kZTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogQ29sbGFwc2UgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkZWRnZSA9IG9wdGlvbnMuZWRnZSxcbiAgICAgICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UgPT09IHZvaWQgMCA/ICdhbmNob3InIDogX29wdGlvbnMkZWRnZTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDEpLFxuICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXTtcblxuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzdGFydCk7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVuc2V0IHRoZSBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgc2VsZWN0aW9uJ3MgcG9pbnQgZm9yd2FyZCBvciBiYWNrd2FyZC5cclxuICAgKi9cbiAgbW92ZTogZnVuY3Rpb24gbW92ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2UgPSBfb3B0aW9ucyRkaXN0YW5jZSA9PT0gdm9pZCAwID8gMSA6IF9vcHRpb25zJGRpc3RhbmNlLFxuICAgICAgICBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgICAgICB1bml0ID0gX29wdGlvbnMkdW5pdCA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0LFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgIHZhciBfb3B0aW9ucyRlZGdlMiA9IG9wdGlvbnMuZWRnZSxcbiAgICAgICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UyID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnMkZWRnZTI7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICB9XG5cbiAgICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICB1bml0OiB1bml0XG4gICAgfTtcbiAgICB2YXIgcHJvcHMgPSB7fTtcblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYW5jaG9yLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvciwgb3B0cyk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBwcm9wcy5hbmNob3IgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIHZhciBfcG9pbnQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGZvY3VzLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGZvY3VzLCBvcHRzKTtcblxuICAgICAgaWYgKF9wb2ludCkge1xuICAgICAgICBwcm9wcy5mb2N1cyA9IF9wb2ludDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiB0byBhIG5ldyB2YWx1ZS5cclxuICAgKi9cbiAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQ6IGZ1bmN0aW9uIHNldFBvaW50KGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIF9vcHRpb25zJGVkZ2UzID0gb3B0aW9ucy5lZGdlLFxuICAgICAgICBlZGdlID0gX29wdGlvbnMkZWRnZTMgPT09IHZvaWQgMCA/ICdib3RoJyA6IF9vcHRpb25zJGVkZ2UzO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCBfZGVmaW5lUHJvcGVydHkoe30sIGVkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnLCBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBwb2ludCksIHByb3BzKSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiB0aGUgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIG9sZFByb3BzID0ge307XG4gICAgdmFyIG5ld1Byb3BzID0ge307XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrID09PSAnYW5jaG9yJyAmJiBwcm9wcy5hbmNob3IgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmFuY2hvciwgc2VsZWN0aW9uLmFuY2hvcikgfHwgayA9PT0gJ2ZvY3VzJyAmJiBwcm9wcy5mb2N1cyAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuZm9jdXMsIHNlbGVjdGlvbi5mb2N1cykgfHwgayAhPT0gJ2FuY2hvcicgJiYgayAhPT0gJ2ZvY3VzJyAmJiBwcm9wc1trXSAhPT0gc2VsZWN0aW9uW2tdKSB7XG4gICAgICAgIG9sZFByb3BzW2tdID0gc2VsZWN0aW9uW2tdO1xuICAgICAgICBuZXdQcm9wc1trXSA9IHByb3BzW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhvbGRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgICBwcm9wZXJ0aWVzOiBvbGRQcm9wcyxcbiAgICAgICAgbmV3UHJvcGVydGllczogbmV3UHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIFRleHRUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBcImRlbGV0ZVwiOiBmdW5jdGlvbiBfZGVsZXRlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZSxcbiAgICAgICAgICBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQsXG4gICAgICAgICAgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgICAgICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZSxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgICAgIF9vcHRpb25zJGhhbmdpbmcgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgICB2YXIgZnVydGhlc3RWb2lkID0gRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgZnVydGhlc3RWb2lkKSB7XG4gICAgICAgICAgdmFyIF9mdXJ0aGVzdFZvaWQgPSBfc2xpY2VkVG9BcnJheShmdXJ0aGVzdFZvaWQsIDIpLFxuICAgICAgICAgICAgICB2b2lkUGF0aCA9IF9mdXJ0aGVzdFZvaWRbMV07XG5cbiAgICAgICAgICBhdCA9IHZvaWRQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICAgIGF0ID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgICAgX2VuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM0WzBdLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczRbMV07XG5cbiAgICAgIHZhciBzdGFydEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgaXNBY3Jvc3NCbG9ja3MgPSBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSk7XG4gICAgICB2YXIgaXNTaW5nbGVUZXh0ID0gUGF0aC5lcXVhbHMoc3RhcnQucGF0aCwgZW5kLnBhdGgpO1xuICAgICAgdmFyIHN0YXJ0Vm9pZCA9IHZvaWRzID8gbnVsbCA6IEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTsgLy8gSWYgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludHMgYXJlIGluc2lkZSBhbiBpbmxpbmUgdm9pZCwgbnVkZ2UgdGhlbSBvdXQuXG5cbiAgICAgIGlmIChzdGFydFZvaWQpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGJlZm9yZSAmJiBzdGFydEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihzdGFydEJsb2NrWzFdLCBiZWZvcmUucGF0aCkpIHtcbiAgICAgICAgICBzdGFydCA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlbmQpO1xuXG4gICAgICAgIGlmIChhZnRlciAmJiBlbmRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3IoZW5kQmxvY2tbMV0sIGFmdGVyLnBhdGgpKSB7XG4gICAgICAgICAgZW5kID0gYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gR2V0IHRoZSBoaWdoZXN0IG5vZGVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgaW5zaWRlIHRoZSByYW5nZSwgYXMgd2VsbCBhc1xuICAgICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMuXG5cblxuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgIHZhciBsYXN0UGF0aDtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfZW50cnkgPSBfc2xpY2VkVG9BcnJheShlbnRyeSwgMiksXG4gICAgICAgICAgICAgIF9ub2RlMiA9IF9lbnRyeVswXSxcbiAgICAgICAgICAgICAgX3BhdGgyID0gX2VudHJ5WzFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShfcGF0aDIsIGxhc3RQYXRoKSA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChfbm9kZTIpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBfbm9kZTIpIHx8ICFQYXRoLmlzQ29tbW9uKF9wYXRoMiwgc3RhcnQucGF0aCkgJiYgIVBhdGguaXNDb21tb24oX3BhdGgyLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICBsYXN0UGF0aCA9IF9wYXRoMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmMlsxXTtcblxuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICB2YXIgcmVtb3ZlZFRleHQgPSAnJztcblxuICAgICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgIXN0YXJ0Vm9pZCkge1xuICAgICAgICB2YXIgX3BvaW50ID0gc3RhcnRSZWYuY3VycmVudDtcblxuICAgICAgICB2YXIgX0VkaXRvciRsZWFmID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQpLFxuICAgICAgICAgICAgX0VkaXRvciRsZWFmMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZiwgMSksXG4gICAgICAgICAgICBub2RlID0gX0VkaXRvciRsZWFmMlswXTtcblxuICAgICAgICB2YXIgcGF0aCA9IF9wb2ludC5wYXRoO1xuICAgICAgICB2YXIgX3N0YXJ0ID0gc3RhcnQsXG4gICAgICAgICAgICBvZmZzZXQgPSBfc3RhcnQub2Zmc2V0O1xuICAgICAgICB2YXIgdGV4dCA9IG5vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1vdmVkVGV4dCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGF0aFJlZnMucmV2ZXJzZSgpLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gci51bnJlZigpO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByICE9PSBudWxsO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbmRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgdmFyIF9FZGl0b3IkbGVhZjMgPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludDIpLFxuICAgICAgICAgICAgX0VkaXRvciRsZWFmNCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZjMsIDEpLFxuICAgICAgICAgICAgX25vZGUgPSBfRWRpdG9yJGxlYWY0WzBdO1xuXG4gICAgICAgIHZhciBfcGF0aCA9IF9wb2ludDIucGF0aDtcblxuICAgICAgICB2YXIgX29mZnNldCA9IGlzU2luZ2xlVGV4dCA/IHN0YXJ0Lm9mZnNldCA6IDA7XG5cbiAgICAgICAgdmFyIF90ZXh0ID0gX25vZGUudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcblxuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbW92ZWRUZXh0ID0gX3RleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgaXNBY3Jvc3NCbG9ja3MgJiYgZW5kUmVmLmN1cnJlbnQgJiYgc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICAgIGhhbmdpbmc6IHRydWUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGb3IgVGhhaSBzY3JpcHQsIGRlbGV0aW5nIE4gY2hhcmFjdGVyKHMpIGJhY2t3YXJkIHNob3VsZCBkZWxldGVcbiAgICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuXG5cbiAgICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHJlbW92ZWRUZXh0LnNsaWNlKDAsIHJlbW92ZWRUZXh0Lmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFVucmVmID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRoYW5naW5nMiA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZzIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZzIsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHMyID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczI7XG4gICAgICB2YXIgX29wdGlvbnMkYXQyID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0MiA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MjtcblxuICAgICAgaWYgKCFmcmFnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9SYW5nZSRlZGdlczUgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNlsxXTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIElmIHRoZSBpbnNlcnQgcG9pbnQgaXMgYXQgdGhlIGVkZ2Ugb2YgYW4gaW5saW5lIG5vZGUsIG1vdmUgaXQgb3V0c2lkZVxuICAgICAgLy8gaW5zdGVhZCBzaW5jZSBpdCB3aWxsIG5lZWQgdG8gYmUgc3BsaXQgb3RoZXJ3aXNlLlxuXG5cbiAgICAgIHZhciBpbmxpbmVFbGVtZW50TWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlubGluZUVsZW1lbnRNYXRjaCkge1xuICAgICAgICB2YXIgX2lubGluZUVsZW1lbnRNYXRjaCA9IF9zbGljZWRUb0FycmF5KGlubGluZUVsZW1lbnRNYXRjaCwgMiksXG4gICAgICAgICAgICBfaW5saW5lUGF0aCA9IF9pbmxpbmVFbGVtZW50TWF0Y2hbMV07XG5cbiAgICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgICBhdCA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2Jsb2NrTWF0Y2ggPSBfc2xpY2VkVG9BcnJheShibG9ja01hdGNoLCAyKSxcbiAgICAgICAgICBibG9ja1BhdGggPSBfYmxvY2tNYXRjaFsxXTtcblxuICAgICAgdmFyIGlzQmxvY2tTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgICB2YXIgaXNCbG9ja0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgICAgdmFyIGlzQmxvY2tFbXB0eSA9IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgICAgdmFyIG1lcmdlU3RhcnQgPSAhaXNCbG9ja1N0YXJ0IHx8IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgICAgdmFyIG1lcmdlRW5kID0gIWlzQmxvY2tFbmQ7XG5cbiAgICAgIHZhciBfTm9kZSRmaXJzdCA9IE5vZGUuZmlyc3Qoe1xuICAgICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICAgIH0sIFtdKSxcbiAgICAgICAgICBfTm9kZSRmaXJzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRmaXJzdCwgMiksXG4gICAgICAgICAgZmlyc3RQYXRoID0gX05vZGUkZmlyc3QyWzFdO1xuXG4gICAgICB2YXIgX05vZGUkbGFzdCA9IE5vZGUubGFzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pLFxuICAgICAgICAgIF9Ob2RlJGxhc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkbGFzdCwgMiksXG4gICAgICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0MlsxXTtcblxuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgdmFyIG1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaGVyKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgIG4gPSBfcmVmNFswXSxcbiAgICAgICAgICAgIHAgPSBfcmVmNFsxXTtcblxuICAgICAgICB2YXIgaXNSb290ID0gcC5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Jsb2NrRW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZVN0YXJ0ICYmIFBhdGguaXNBbmNlc3RvcihwLCBmaXJzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKE5vZGUubm9kZXMoe1xuICAgICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICAgIH0sIHtcbiAgICAgICAgcGFzczogbWF0Y2hlclxuICAgICAgfSkpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgICAgdmFyIG1pZGRsZXMgPSBbXTtcbiAgICAgIHZhciBlbmRzID0gW107XG4gICAgICB2YXIgc3RhcnRpbmcgPSB0cnVlO1xuICAgICAgdmFyIGhhc0Jsb2NrcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9tYXRjaGVzID0gbWF0Y2hlczsgX2kgPCBfbWF0Y2hlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9tYXRjaGVzJF9pID0gX3NsaWNlZFRvQXJyYXkoX21hdGNoZXNbX2ldLCAxKSxcbiAgICAgICAgICAgIG5vZGUgPSBfbWF0Y2hlcyRfaVswXTtcblxuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgaGFzQmxvY2tzID0gdHJ1ZTtcbiAgICAgICAgICBtaWRkbGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgICBzdGFydHMucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9FZGl0b3Ikbm9kZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KSxcbiAgICAgICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgICAgIGlubGluZU1hdGNoID0gX0VkaXRvciRub2RlczJbMF07XG5cbiAgICAgIHZhciBfaW5saW5lTWF0Y2ggPSBfc2xpY2VkVG9BcnJheShpbmxpbmVNYXRjaCwgMiksXG4gICAgICAgICAgaW5saW5lUGF0aCA9IF9pbmxpbmVNYXRjaFsxXTtcblxuICAgICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICAgIHZhciBpc0lubGluZUVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICAgIHZhciBtaWRkbGVSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzQmxvY2tFbmQgJiYgIWVuZHMubGVuZ3RoID8gUGF0aC5uZXh0KGJsb2NrUGF0aCkgOiBibG9ja1BhdGgpO1xuICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBoYXNCbG9ja3MgPyBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgICBhbHdheXM6IGhhc0Jsb2NrcyAmJiAoIWlzQmxvY2tTdGFydCB8fCBzdGFydHMubGVuZ3RoID4gMCkgJiYgKCFpc0Jsb2NrRW5kIHx8IGVuZHMubGVuZ3RoID4gMCksXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0Jsb2NrRW1wdHkgJiYgIXN0YXJ0cy5sZW5ndGggJiYgbWlkZGxlcy5sZW5ndGggJiYgIWVuZHMubGVuZ3RoKSB7XG4gICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBtaWRkbGVzLCB7XG4gICAgICAgIGF0OiBtaWRkbGVSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZW5kcywge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5hdCkge1xuICAgICAgICB2YXIgcGF0aDtcblxuICAgICAgICBpZiAoZW5kcy5sZW5ndGggPiAwICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBfZW5kMiA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICAgIGVuZFJlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHN0cmluZyBvZiB0ZXh0IGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkdm9pZHMzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczM7XG4gICAgICB2YXIgX29wdGlvbnMkYXQzID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0MyA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFJhbmdlLmVuZChhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgICAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICAgICAgdmFyIGVuZFBvaW50ID0gZW5kUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBzdGFydFBvaW50IHx8IGVuZFBvaW50O1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfYXQgPSBhdCxcbiAgICAgICAgICBwYXRoID0gX2F0LnBhdGgsXG4gICAgICAgICAgb2Zmc2V0ID0gX2F0Lm9mZnNldDtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBHZW5lcmFsVHJhbnNmb3JtcyksIE5vZGVUcmFuc2Zvcm1zKSwgU2VsZWN0aW9uVHJhbnNmb3JtcyksIFRleHRUcmFuc2Zvcm1zKTtcblxuZXhwb3J0cy5FZGl0b3IgPSBFZGl0b3I7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Mb2NhdGlvbiA9IExvY2F0aW9uO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuT3BlcmF0aW9uID0gT3BlcmF0aW9uO1xuZXhwb3J0cy5QYXRoID0gUGF0aDtcbmV4cG9ydHMuUGF0aFJlZiA9IFBhdGhSZWY7XG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLlBvaW50UmVmID0gUG9pbnRSZWY7XG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5leHBvcnRzLlJhbmdlUmVmID0gUmFuZ2VSZWY7XG5leHBvcnRzLlNjcnViYmVyID0gU2NydWJiZXI7XG5leHBvcnRzLlNwYW4gPSBTcGFuO1xuZXhwb3J0cy5UZXh0ID0gVGV4dDtcbmV4cG9ydHMuVHJhbnNmb3JtcyA9IFRyYW5zZm9ybXM7XG5leHBvcnRzLmNyZWF0ZUVkaXRvciA9IGNyZWF0ZUVkaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate/dist/index.js\n");

/***/ })

};
;